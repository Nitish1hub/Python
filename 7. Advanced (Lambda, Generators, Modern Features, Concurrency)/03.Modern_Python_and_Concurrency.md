# Modern Python Features & Concurrency

## Table of Contents
1. [Introduction - Latest Python Features](#introduction---latest-python-features)
2. [Type Hints & Annotations](#type-hints--annotations)
3. [Dataclasses](#dataclasses)
4. [Walrus Operator (:=)](#walrus-operator-)
5. [Match-Case Statements](#match-case-statements)
6. [Context Managers](#context-managers)
7. [Threading Basics](#threading-basics)
8. [Multiprocessing](#multiprocessing)
9. [Asyncio Introduction](#asyncio-introduction)
10. [Modern String Formatting](#modern-string-formatting)
11. [Real-Life Practical Examples](#real-life-practical-examples)
12. [Common Mistakes](#common-mistakes)
13. [Best Practices](#best-practices)
14. [Summary](#summary)
15. [Practice Exercises](#practice-exercises)
16. [Congratulations!](#congratulations)

---

## Introduction - Latest Python Features

Python keeps evolving! Let's learn modern features that make code cleaner, safer, and faster.

**Real-World Analogy:**
- **Type hints:** Like labeling boxes ("Fragile", "Electronics")
- **Dataclasses:** Pre-built furniture (no assembly required)
- **Walrus operator:** Take-and-use in one step
- **Match-case:** Smart traffic routing system
- **Threading:** Multiple workers on separate tasks
- **Async:** One chef juggling multiple orders

**In this blog, you'll learn:**
- Type hints for better code
- Dataclasses for easy classes
- Walrus operator for cleaner code
- Match-case for better conditionals
- Threading and multiprocessing
- Async programming basics

---

## Type Hints & Annotations

**Define: Type hints** - Optional annotations that indicate expected data types (Python 3.5+).

### Why Type Hints?

```python
# Without type hints - unclear what types expected
def add(a, b):
    return a + b

# With type hints - clear expectations!
def add(a: int, b: int) -> int:
    return a + b
```

### Basic Type Hints

```python
# Variables
name: str = "Alice"
age: int = 25
height: float = 5.8
is_student: bool = True

# Functions
def greet(name: str) -> str:
    return f"Hello, {name}!"

def add(x: int, y: int) -> int:
    return x + y

def process_data(data: list) -> dict:
    return {"count": len(data)}
```

### Collection Type Hints

```python
from typing import List, Dict, Tuple, Set, Optional

# List of integers
numbers: List[int] = [1, 2, 3, 4, 5]

# Dictionary with string keys and int values
scores: Dict[str, int] = {"Alice": 95, "Bob": 87}

# Tuple with specific types
coordinates: Tuple[float, float] = (10.5, 20.3)

# Set of strings
unique_names: Set[str] = {"Alice", "Bob", "Charlie"}

# Optional (can be None)
middle_name: Optional[str] = None  # str or None

def find_user(user_id: int) -> Optional[Dict[str, str]]:
    """Returns user dict or None if not found"""
    if user_id > 0:
        return {"name": "Alice", "email": "alice@example.com"}
    return None
```

### Advanced Type Hints

```python
from typing import List, Dict, Union, Callable, Any

# Union - multiple possible types
def process(value: Union[int, str]) -> str:
    return str(value)

# Callable - function type
def execute(func: Callable[[int, int], int], x: int, y: int) -> int:
    return func(x, y)

# Any - any type (avoid when possible)
def process_anything(data: Any) -> Any:
    return data

# List of dictionaries
users: List[Dict[str, Union[str, int]]] = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30}
]
```

### Type Aliases

```python
from typing import List, Dict

# Create type alias for complex types
Vector = List[float]
Matrix = List[Vector]
UserDict = Dict[str, Union[str, int]]

def add_vectors(v1: Vector, v2: Vector) -> Vector:
    return [a + b for a, b in zip(v1, v2)]

users: List[UserDict] = [
    {"name": "Alice", "age": 25},
    {"name": "Bob", "age": 30}
]
```

### Type Checking

**Note:** Type hints don't enforce types at runtime!

```python
def add(x: int, y: int) -> int:
    return x + y

# Python allows this (type hints don't enforce!)
result = add("hello", "world")  # No error!
print(result)  # helloworld

# Use mypy for static type checking:
# $ pip install mypy
# $ mypy your_code.py
```

---

## Dataclasses

**Define: Dataclass** - Auto-generates common methods for classes that mainly store data (Python 3.7+).

### Without Dataclass

```python
class Person:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email
    
    def __repr__(self):
        return f"Person(name={self.name}, age={self.age}, email={self.email})"
    
    def __eq__(self, other):
        if not isinstance(other, Person):
            return False
        return (self.name == other.name and 
                self.age == other.age and 
                self.email == other.email)
```

### With Dataclass

```python
from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int
    email: str

# That's it! Auto-generates __init__, __repr__, __eq__, and more!

person = Person("Alice", 25, "alice@example.com")
print(person)  # Person(name='Alice', age=25, email='alice@example.com')

person2 = Person("Alice", 25, "alice@example.com")
print(person == person2)  # True (auto __eq__)
```

### Dataclass Features

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Product:
    name: str
    price: float
    quantity: int = 0  # Default value
    tags: List[str] = field(default_factory=list)  # Mutable default
    
    def total_value(self) -> float:
        """Can still add custom methods"""
        return self.price * self.quantity

product = Product("Laptop", 999.99)
print(product)  # Product(name='Laptop', price=999.99, quantity=0, tags=[])

product2 = Product("Mouse", 29.99, 10, ["electronics", "gaming"])
print(product2.total_value())  # 299.9
```

### Dataclass Options

```python
from dataclasses import dataclass

@dataclass(frozen=True)  # Make immutable
class Point:
    x: float
    y: float

point = Point(10, 20)
# point.x = 30  # Error! Frozen

@dataclass(order=True)  # Add comparison methods
class Student:
    name: str
    grade: int

students = [Student("Bob", 85), Student("Alice", 95), Student("Charlie", 90)]
print(sorted(students))  # Sorted by fields
```

### Post-Init Processing

```python
from dataclasses import dataclass

@dataclass
class Rectangle:
    width: float
    height: float
    area: float = 0.0
    
    def __post_init__(self):
        """Called after __init__"""
        self.area = self.width * self.height

rect = Rectangle(5, 10)
print(rect.area)  # 50.0 (calculated automatically!)
```

---

## Walrus Operator (:=)

**Define: Walrus operator** - Assign and use value in one expression (Python 3.8+).

### Why Walrus Operator?

**Before (Python <3.8):**
```python
# Calculate and check
data = get_data()
if data:
    process(data)

# Or repeat calculation
if len(get_data()) > 10:
    # Need to call get_data() again...
```

**After (Python 3.8+):**
```python
# Assign AND use in one step!
if (data := get_data()):
    process(data)

if (length := len(get_data())) > 10:
    print(f"Data has {length} items")
```

### Basic Examples

```python
# Regular if
name = input("Enter name: ")
if name:
    print(f"Hello, {name}!")

# With walrus
if (name := input("Enter name: ")):
    print(f"Hello, {name}!")

# While loop
line = file.readline()
while line:
    process(line)
    line = file.readline()

# With walrus
while (line := file.readline()):
    process(line)
```

### Practical Walrus Examples

```python
# List comprehension with filtering
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Without walrus - calculate twice
squares = [x*x for x in numbers if x*x > 20]

# With walrus - calculate once
squares = [square for x in numbers if (square := x*x) > 20]
print(squares)  # [25, 36, 49, 64, 81, 100]

# Processing with intermediate result
data = [1, 2, 3, 4, 5]
processed = [(x, x*2, total) for x in data if (total := x + x*2) > 5]
print(processed)  # [(2, 4, 6), (3, 6, 9), (4, 8, 12), (5, 10, 15)]
```

### Real-World Usage

```python
import re

# Email validation
def validate_email(email):
    if (match := re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email)):
        print(f"Valid email: {match.group()}")
        return True
    return False

# File processing
def process_file(filename):
    with open(filename) as f:
        while (line := f.readline()):
            if (match := re.search(r'ERROR', line)):
                print(f"Found error: {line}")

# API response
def handle_api_response(response):
    if (data := response.get('data')) and (items := data.get('items')):
        return len(items)
    return 0
```

---

## Match-Case Statements

**Define: Match-case** - Pattern matching like switch-case but more powerful (Python 3.10+).

### Basic Match-Case

```python
def http_status(status):
    match status:
        case 200:
            return "OK"
        case 404:
            return "Not Found"
        case 500:
            return "Server Error"
        case _:  # Default case
            return "Unknown"

print(http_status(200))  # OK
print(http_status(404))  # Not Found
print(http_status(999))  # Unknown
```

### Pattern Matching

```python
def describe_type(value):
    match value:
        case int():
            return "It's an integer"
        case str():
            return "It's a string"
        case list():
            return "It's a list"
        case _:
            return "Unknown type"

print(describe_type(42))      # It's an integer
print(describe_type("hello")) # It's a string
print(describe_type([1, 2]))  # It's a list
```

### Matching Multiple Patterns

```python
def describe_number(num):
    match num:
        case 0:
            return "Zero"
        case 1 | 2 | 3:  # OR pattern
            return "Small number"
        case n if n < 0:  # Guard
            return "Negative"
        case n if n < 10:
            return "Single digit"
        case _:
            return "Large number"

print(describe_number(0))   # Zero
print(describe_number(2))   # Small number
print(describe_number(-5))  # Negative
print(describe_number(7))   # Single digit
print(describe_number(100)) # Large number
```

### Matching Sequences

```python
def process_point(point):
    match point:
        case [0, 0]:
            return "Origin"
        case [0, y]:
            return f"On Y-axis at {y}"
        case [x, 0]:
            return f"On X-axis at {x}"
        case [x, y]:
            return f"Point at ({x}, {y})"
        case _:
            return "Not a 2D point"

print(process_point([0, 0]))   # Origin
print(process_point([0, 5]))   # On Y-axis at 5
print(process_point([3, 0]))   # On X-axis at 3
print(process_point([3, 4]))   # Point at (3, 4)
```

### Matching Dictionaries

```python
def process_user(user):
    match user:
        case {"name": name, "role": "admin"}:
            return f"Admin: {name}"
        case {"name": name, "role": "user", "age": age} if age >= 18:
            return f"Adult user: {name}"
        case {"name": name}:
            return f"User: {name}"
        case _:
            return "Invalid user"

print(process_user({"name": "Alice", "role": "admin"}))
# Admin: Alice

print(process_user({"name": "Bob", "role": "user", "age": 25}))
# Adult user: Bob
```

### Match-Case vs If-Elif

```python
# If-elif (old way)
def get_grade_old(score):
    if score >= 90:
        return 'A'
    elif score >= 80:
        return 'B'
    elif score >= 70:
        return 'C'
    elif score >= 60:
        return 'D'
    else:
        return 'F'

# Match-case (Python 3.10+)
def get_grade_new(score):
    match score:
        case s if s >= 90:
            return 'A'
        case s if s >= 80:
            return 'B'
        case s if s >= 70:
            return 'C'
        case s if s >= 60:
            return 'D'
        case _:
            return 'F'
```

---

## Context Managers

**Define: Context manager** - Object that manages setup and cleanup automatically using `with` statement.

### Creating Context Manager with Class

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """Called when entering 'with' block"""
        print(f"Opening {self.filename}")
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Called when exiting 'with' block"""
        print(f"Closing {self.filename}")
        if self.file:
            self.file.close()
        # Return False to propagate exceptions
        return False

# Use it
with FileManager('test.txt', 'w') as f:
    f.write('Hello, World!')
# File automatically closed!
```

### Context Manager with contextlib

```python
from contextlib import contextmanager

@contextmanager
def timer(name):
    """Time code execution"""
    import time
    start = time.time()
    print(f"Starting {name}...")
    
    try:
        yield  # Code block runs here
    finally:
        end = time.time()
        print(f"{name} took {end - start:.4f} seconds")

# Use it
with timer("Data processing"):
    # Your code here
    sum(range(1000000))

# Output:
# Starting Data processing...
# Data processing took 0.0234 seconds
```

### Practical Context Managers

```python
from contextlib import contextmanager
import os

@contextmanager
def change_directory(path):
    """Temporarily change directory"""
    old_dir = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(old_dir)

# Use it
print(f"Current: {os.getcwd()}")
with change_directory('/tmp'):
    print(f"Inside with: {os.getcwd()}")
print(f"After with: {os.getcwd()}")

@contextmanager
def suppress_errors():
    """Suppress all exceptions"""
    try:
        yield
    except Exception as e:
        print(f"Error suppressed: {e}")

# Use it
with suppress_errors():
    result = 10 / 0  # Would normally crash
print("Continued execution")
```

---

## Threading Basics

**Define: Threading** - Running multiple threads (workers) concurrently in same program.

### Why Threading?

**Without threading:**
```python
import time

def task(name):
    print(f"{name} starting")
    time.sleep(2)
    print(f"{name} finished")

# Sequential - takes 6 seconds
task("Task 1")
task("Task 2")
task("Task 3")
```

**With threading:**
```python
import threading
import time

def task(name):
    print(f"{name} starting")
    time.sleep(2)
    print(f"{name} finished")

# Concurrent - takes ~2 seconds!
threads = []
for i in range(3):
    t = threading.Thread(target=task, args=(f"Task {i+1}",))
    threads.append(t)
    t.start()

# Wait for all to finish
for t in threads:
    t.join()

print("All tasks complete!")
```

### Basic Threading

```python
import threading
import time

def count(name, n):
    for i in range(n):
        print(f"{name}: {i}")
        time.sleep(0.5)

# Create threads
t1 = threading.Thread(target=count, args=("Thread-1", 5))
t2 = threading.Thread(target=count, args=("Thread-2", 5))

# Start threads
t1.start()
t2.start()

# Wait for completion
t1.join()
t2.join()

print("Done!")
```

### Thread with Return Value

```python
import threading

class ThreadWithReturn(threading.Thread):
    def __init__(self, target, args=()):
        super().__init__()
        self.target = target
        self.args = args
        self.result = None
    
    def run(self):
        self.result = self.target(*self.args)
    
    def get_result(self):
        return self.result

def calculate_square(n):
    return n * n

# Use it
thread = ThreadWithReturn(target=calculate_square, args=(5,))
thread.start()
thread.join()
print(f"Result: {thread.get_result()}")  # 25
```

### Thread Safety with Locks

```python
import threading

counter = 0
lock = threading.Lock()

def increment():
    global counter
    for _ in range(100000):
        with lock:  # Thread-safe
            counter += 1

threads = [threading.Thread(target=increment) for _ in range(10)]

for t in threads:
    t.start()

for t in threads:
    t.join()

print(f"Counter: {counter}")  # 1000000 (correct with lock!)
```

---

## Multiprocessing

**Define: Multiprocessing** - Running multiple processes (separate programs) in parallel.

### Threading vs Multiprocessing

**Threading:**
- Shared memory
- Good for I/O-bound tasks (network, files)
- Limited by GIL (Global Interpreter Lock)

**Multiprocessing:**
- Separate memory
- Good for CPU-bound tasks (calculations)
- True parallelism

### Basic Multiprocessing

```python
from multiprocessing import Process
import time

def task(name):
    print(f"{name} starting")
    time.sleep(2)
    print(f"{name} finished")

if __name__ == '__main__':
    # Create processes
    processes = []
    for i in range(3):
        p = Process(target=task, args=(f"Process {i+1}",))
        processes.append(p)
        p.start()
    
    # Wait for all
    for p in processes:
        p.join()
    
    print("All processes complete!")
```

### Process Pool

```python
from multiprocessing import Pool

def square(n):
    return n * n

if __name__ == '__main__':
    numbers = [1, 2, 3, 4, 5]
    
    # Create pool of workers
    with Pool(processes=4) as pool:
        results = pool.map(square, numbers)
    
    print(results)  # [1, 4, 9, 16, 25]
```

### CPU-Bound Task Example

```python
from multiprocessing import Pool
import time

def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

def calculate_fibs(numbers):
    return [fibonacci(n) for n in numbers]

if __name__ == '__main__':
    nums = [35, 35, 35, 35]
    
    # Sequential
    start = time.time()
    results = calculate_fibs(nums)
    print(f"Sequential: {time.time() - start:.2f}s")
    
    # Parallel
    start = time.time()
    with Pool() as pool:
        results = pool.map(fibonacci, nums)
    print(f"Parallel: {time.time() - start:.2f}s")
```

---

## Asyncio Introduction

**Define: Asyncio** - Asynchronous I/O - concurrent code using async/await (Python 3.5+).

### Basic Async/Await

```python
import asyncio

async def say_hello(name, delay):
    """Async function (coroutine)"""
    print(f"Hello {name}, starting...")
    await asyncio.sleep(delay)  # Async sleep
    print(f"Hello {name}, finished!")
    return f"Greeted {name}"

async def main():
    """Run multiple coroutines concurrently"""
    # Run concurrently
    results = await asyncio.gather(
        say_hello("Alice", 1),
        say_hello("Bob", 2),
        say_hello("Charlie", 1)
    )
    print("Results:", results)

# Run async program
asyncio.run(main())
```

### Async for I/O Operations

```python
import asyncio
import aiohttp  # pip install aiohttp

async def fetch_url(url):
    """Fetch URL asynchronously"""
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    urls = [
        'http://example.com',
        'http://example.org',
        'http://example.net'
    ]
    
    # Fetch all concurrently
    results = await asyncio.gather(*[fetch_url(url) for url in urls])
    print(f"Fetched {len(results)} pages")

# asyncio.run(main())
```

### When to Use Async

**‚úÖ Use async for:**
- Many I/O operations (network requests, file I/O)
- Web servers handling many connections
- Real-time applications

**‚ùå Don't use async for:**
- CPU-intensive tasks (use multiprocessing)
- Simple scripts
- When threading is sufficient

---

## Modern String Formatting

### F-String Features (Python 3.6+)

```python
# Basic f-strings
name = "Alice"
age = 25
print(f"Name: {name}, Age: {age}")

# Expressions in f-strings
print(f"Next year: {age + 1}")
print(f"Uppercase: {name.upper()}")

# Format specifiers
price = 19.99
print(f"Price: ${price:.2f}")  # $19.99

# Alignment
print(f"{'Left':<10}|")   # Left      |
print(f"{'Center':^10}|")  #   Center  |
print(f"{'Right':>10}|")   #      Right|

# Python 3.8+: = for debug
x = 10
print(f"{x=}")  # x=10

# Python 3.8+: Numeric separator
big_num = 1_000_000
print(f"{big_num:,}")  # 1,000,000
```

### Multi-line F-Strings

```python
name = "Alice"
age = 25
city = "NYC"

# Multi-line
info = f"""
Name: {name}
Age: {age}
City: {city}
"""
print(info)

# With expressions
data = {
    "users": 150,
    "active": 120
}

report = f"""
Total Users: {data['users']}
Active Users: {data['active']}
Percentage: {data['active']/data['users']*100:.1f}%
"""
print(report)
```

---

## Real-Life Practical Examples

### Example 1: Web Scraper with Threading

```python
import threading
import time
from typing import List

class WebScraper:
    def __init__(self):
        self.results = []
        self.lock = threading.Lock()
    
    def scrape_page(self, url: str):
        """Simulate scraping a page"""
        print(f"Scraping {url}...")
        time.sleep(1)  # Simulate network delay
        
        data = f"Data from {url}"
        
        with self.lock:
            self.results.append(data)
        
        print(f"Finished {url}")
    
    def scrape_all(self, urls: List[str]):
        """Scrape all URLs concurrently"""
        threads = []
        
        for url in urls:
            t = threading.Thread(target=self.scrape_page, args=(url,))
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        
        return self.results

# Use it
scraper = WebScraper()
urls = [
    "http://example.com/page1",
    "http://example.com/page2",
    "http://example.com/page3"
]

results = scraper.scrape_all(urls)
print(f"Scraped {len(results)} pages")
```

### Example 2: Data Processor with Type Hints

```python
from typing import List, Dict, Optional
from dataclasses import dataclass

@dataclass
class Student:
    name: str
    grades: List[int]
    
    def average(self) -> float:
        return sum(self.grades) / len(self.grades) if self.grades else 0.0
    
    def letter_grade(self) -> str:
        avg = self.average()
        match avg:
            case a if a >= 90:
                return 'A'
            case b if b >= 80:
                return 'B'
            case c if c >= 70:
                return 'C'
            case d if d >= 60:
                return 'D'
            case _:
                return 'F'

def process_students(students: List[Student]) -> Dict[str, List[str]]:
    """Group students by letter grade"""
    groups: Dict[str, List[str]] = {}
    
    for student in students:
        grade = student.letter_grade()
        if grade not in groups:
            groups[grade] = []
        groups[grade].append(student.name)
    
    return groups

# Use it
students = [
    Student("Alice", [95, 92, 98]),
    Student("Bob", [82, 85, 80]),
    Student("Charlie", [75, 72, 78])
]

grouped = process_students(students)
for grade, names in sorted(grouped.items()):
    print(f"Grade {grade}: {', '.join(names)}")
```

### Example 3: Resource Manager with Context Manager

```python
from contextlib import contextmanager
import time

@contextmanager
def performance_monitor(task_name: str):
    """Monitor performance of code block"""
    start_time = time.time()
    start_memory = 0  # Simplified - use tracemalloc for real memory
    
    print(f"‚è±Ô∏è  Starting: {task_name}")
    
    try:
        yield
    finally:
        elapsed = time.time() - start_time
        print(f"‚úÖ Completed: {task_name}")
        print(f"   Time: {elapsed:.4f}s")

# Use it
with performance_monitor("Data Processing"):
    # Process large dataset
    data = [i**2 for i in range(1000000)]
    total = sum(data)

with performance_monitor("File Writing"):
    with open('data.txt', 'w') as f:
        for i in range(10000):
            f.write(f"Line {i}\n")
```

---

## Common Mistakes

### Mistake 1: Type Hints Don't Enforce Types

**Remember:**
```python
def add(x: int, y: int) -> int:
    return x + y

# This works (type hints don't enforce!)
result = add("hello", "world")
print(result)  # helloworld

# Use mypy for static type checking
```

### Mistake 2: Forgetting if __name__ == '__main__' with Multiprocessing

**‚ùå Wrong:**
```python
from multiprocessing import Process

def task():
    print("Task")

# This will cause errors!
p = Process(target=task)
p.start()
```

**‚úÖ Correct:**
```python
from multiprocessing import Process

def task():
    print("Task")

if __name__ == '__main__':
    p = Process(target=task)
    p.start()
    p.join()
```

### Mistake 3: Mixing Threading and Multiprocessing

**Know when to use each:**
- Threading: I/O-bound (network, files)
- Multiprocessing: CPU-bound (calculations)

---

## Best Practices

### ‚úÖ Do This:

1. **Use Type Hints**
   ```python
   def process(data: List[int]) -> Dict[str, int]:
       ...
   ```

2. **Use Dataclasses  for Data**
   ```python
   @dataclass
   class Config:
       host: str
       port: int
   ```

3. **Walrus for Assignment + Check**
   ```python
   if (data := fetch_data()):
       process(data)
   ```

4. **Match-Case for Complex Conditions**
   ```python
   match value:
       case pattern1:
           ...
       case pattern2:
           ...
   ```

5. **Threading for I/O, Multiprocessing for CPU**

### ‚ùå Avoid This:

1. **Don't Rely on Type Hints for Runtime**
2. **Don't Overuse Threading (GIL limitations)**
3. **Don't Use Async Without Understanding**
4. **Don't Forget Thread Safety**

---

## Summary

Congratulations! You've mastered modern Python features! üéâ

**üéØ Key Takeaways:**

**üìå Type Hints**
- `variable: type = value`
- `def func(arg: type) -> return_type`
- Use mypy for checking
- Improves code clarity

**üìå Dataclasses**
- `@dataclass` decorator
- Auto-generates methods
- Clean data classes
- Type hints required

**üìå Walrus Operator**
- `:=` assign and use
- Python 3.8+
- Reduces code duplication
- Great for conditions

**üìå Match-Case**
- Python 3.10+
- Pattern matching
- More powerful than if-elif
- Guards with `if`

**üìå Context Managers**
- `__enter__` and `__exit__`
- `@contextmanager` decorator
- Automatic cleanup
- Resource management

**üìå Threading**
- Concurrent execution
- Good for I/O
- Shared memory
- Use locks for safety

**üìå Multiprocessing**
- Parallel execution
- Good for CPU work
- Separate memory
- True parallelism

**üìå Asyncio**
- async/await
- Concurrent I/O
- Single-threaded
- Event loop

**üí° Remember:**
- Type hints = clarity
- Dataclasses = less code
- Walrus = concise
- Threads (I/O) vs Processes (CPU)
- Context managers = safe resources

---

## Practice Exercises

### Exercise 1: Type Hints
Add complete type hints to function that processes list of dictionaries.

---

### Exercise 2: Dataclass
Create dataclass for Book with title, author, pages, and method to calculate reading time.

---

### Exercise 3: Walrus Operator
Refactor code to use walrus operator in while loop and list comprehension.

---

### Exercise 4: Match-Case
Create calculator using match-case for operations (+, -, *, /).

---

### Exercise 5: Context Manager
Create context manager that times code execution and prints result.

---

### Exercise 6: Threading
Create multi-threaded file downloader simulation.

---

### Exercise 7: Multiprocessing
Use multiprocessing to calculate primes in parallel.

---

### Exercise 8: Async Basics
Create async function that simulates multiple API calls.

---

### Exercise 9: Combined Features
Build data processor using dataclass, type hints, and threading.

---

### Exercise 10: Modern Python Project
Create complete project using all modern features learned.

---

## Congratulations!

**üéâ YOU'VE COMPLETED THE ENTIRE PYTHON MASTERY SERIES! üéâ**

You've now learned:

**‚úÖ Python Fundamentals** (Chapters 1-3)
- Variables, data types, operators
- Conditionals and control flow

**‚úÖ Core Programming** (Chapters 4-5)
- Loops and iterations
- Functions and scope

**‚úÖ Data Structures** (Chapters 6-7)
- Lists, tuples, sets
- Dictionaries and comprehensions

**‚úÖ Advanced Python** (Chapters 8-10)
- String manipulation
- File handling
- Exception handling

**‚úÖ Object-Oriented Programming** (Chapters 11-15)
- Classes and objects
- Encapsulation
- Inheritance
- Polymorphism
- Abstraction

**‚úÖ Practical Applications** (Chapters 16-17)
- Automation scripts
- Complete project

**‚úÖ Advanced Topics** (Chapters 18-20)
- Lambda, map, filter, decorators
- Generators and iterators
- Modern Python features
- Concurrency

**üöÄ What's Next?**

1. **Build Projects:**
   - Web apps (Flask/Django)
   - Data analysis (Pandas/NumPy)
   - Machine Learning (Scikit-learn)
   - Game development (Pygame)

2. **Contribute to Open Source:**
   - GitHub projects
   - Python packages

3. **Keep Learning:**
   - Design patterns
   - Testing (pytest)
   - Deployment (Docker)
   - Cloud services (AWS/Azure)

4. **Join Communities:**
   - Python Discord
   - Reddit r/learnpython
   - Stack Overflow
   - Local Python meetups

**You're now a Python developer!** üêç‚ú®

Go build amazing things! üöÄ

Remember: The best way to learn is by doing. Start coding today!

---

**Thank you for completing this journey!** üôè

Keep coding, keep learning, keep growing! üí™
