# Generators, Iterators & Comprehensions

## Table of Contents
1. [Introduction - Memory-Efficient Data Processing](#introduction---memory-efficient-data-processing)
2. [What Are Iterators?](#what-are-iterators)
3. [Creating Custom Iterators](#creating-custom-iterators)
4. [Generator Functions with yield](#generator-functions-with-yield)
5. [Generator Expressions](#generator-expressions)
6. [Set Comprehensions](#set-comprehensions)
7. [Advanced Comprehensions](#advanced-comprehensions)
8. [Practical Generator Examples](#practical-generator-examples)
9. [Infinite Generators](#infinite-generators)
10. [Generator Pipelines](#generator-pipelines)
11. [Real-Life Practical Examples](#real-life-practical-examples)
12. [Common Mistakes](#common-mistakes)
13. [Best Practices](#best-practices)
14. [Summary](#summary)
15. [Practice Exercises](#practice-exercises)
16. [What's Next?](#whats-next)

---

## Introduction - Memory-Efficient Data Processing

Imagine reading a 10GB file. Loading it all at once would crash your computer! Generators let you process data one piece at a time.

**Real-World Analogy:**
- **List (eager):** Downloading entire movie before watching (uses lots of memory)
- **Generator (lazy):** Streaming movie as you watch (loads only what's needed)

**In this blog, you'll learn:**
- Iterators and the iteration protocol
- Generator functions with `yield`
- Generator expressions
- Set comprehensions
- Advanced comprehension patterns
- Memory-efficient data processing

---

## What Are Iterators?

**Define: Iterator** - An object that returns one item at a time when you call `next()` on it.

### Built-in Iterables

```python
# Lists, strings, tuples are iterable
numbers = [1, 2, 3]
text = "hello"

# Get iterator from iterable
numbers_iter = iter(numbers)
text_iter = iter(text)

# Get items one by one
print(next(numbers_iter))  # 1
print(next(numbers_iter))  # 2
print(next(numbers_iter))  # 3
# print(next(numbers_iter))  # StopIteration error!

print(next(text_iter))  # h
print(next(text_iter))  # e
print(next(text_iter))  # l
```

### How for Loop Works

```python
# This for loop:
for item in [1, 2, 3]:
    print(item)

# Is actually doing this behind the scenes:
iterator = iter([1, 2, 3])
while True:
    try:
        item = next(iterator)
        print(item)
    except StopIteration:
        break
```

### Iterator vs Iterable

**Iterable:** Object you can loop over (list, string, tuple)
**Iterator:** Object that does the looping (from `iter()`)

```python
# List is iterable, not iterator
numbers = [1, 2, 3]
# next(numbers)  # Error!

# Get iterator from iterable
it = iter(numbers)
print(next(it))  # 1 - Works!
```

---

## Creating Custom Iterators

### Iterator Protocol

To make a class iterable:
1. Implement `__iter__()` - returns iterator object
2. Implement `__next__()` - returns next item or raises `StopIteration`

### Simple Counter Iterator

```python
class Counter:
    def __init__(self, start, end):
        self.current = start
        self.end = end
    
    def __iter__(self):
        # Return self because this class is its own iterator
        return self
    
    def __next__(self):
        if self.current > self.end:
            raise StopIteration
        
        value = self.current
        self.current += 1
        return value

# Use like any iterable!
counter = Counter(1, 5)
for num in counter:
    print(num)  # 1, 2, 3, 4, 5

# Or manually
counter2 = Counter(10, 12)
print(next(counter2))  # 10
print(next(counter2))  # 11
print(next(counter2))  # 12
# print(next(counter2))  # StopIteration
```

### Range-like Iterator

```python
class MyRange:
    def __init__(self, start, stop, step=1):
        self.start = start
        self.stop = stop
        self.step = step
    
    def __iter__(self):
        current = self.start
        while current < self.stop:
            yield current
            current += self.step

# Use it
for num in MyRange(0, 10, 2):
    print(num)  # 0, 2, 4, 6, 8
```

### Fibonacci Iterator

```python
class Fibonacci:
    def __init__(self, max_count):
        self.max_count = max_count
        self.count = 0
        self.a = 0
        self.b = 1
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.count >= self.max_count:
            raise StopIteration
        
        value = self.a
        self.a, self.b = self.b, self.a + self.b
        self.count += 1
        return value

# First 10 Fibonacci numbers
for num in Fibonacci(10):
    print(num, end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

---

## Generator Functions with yield

**Define: Generator** - A function that uses `yield` to return values one at a time (lazy evaluation).

### Basic Generator

```python
def simple_generator():
    print("Start")
    yield 1
    print("After first yield")
    yield 2
    print("After second yield")
    yield 3
    print("End")

# Create generator
gen = simple_generator()

# Generator doesn't run until you ask for values!
print("Generator created")

print(next(gen))  # Start, then returns 1
print(next(gen))  # After first yield, then returns 2
print(next(gen))  # After second yield, then returns 3
# print(next(gen))  # End, then StopIteration
```

### Generator vs Regular Function

```python
# Regular function - returns list (all at once)
def get_numbers():
    result = []
    for i in range(5):
        result.append(i)
    return result

# Generator function - yields values (one at a time)
def generate_numbers():
    for i in range(5):
        yield i

# Regular function
numbers = get_numbers()
print(numbers)  # [0, 1, 2, 3, 4] (whole list in memory!)

# Generator
gen = generate_numbers()
print(gen)  # <generator object> (no values yet!)
print(list(gen))  # [0, 1, 2, 3, 4] (generate all when needed)
```

### Why Generators?

**Memory Efficiency:**
```python
# List - loads all million numbers into memory!
def million_numbers_list():
    return [i for i in range(1000000)]

# Generator - generates one at a time!
def million_numbers_gen():
    for i in range(1000000):
        yield i

# List version uses ~8MB memory
# Generator version uses almost no memory!
```

### Simple Generator Examples

```python
def countdown(n):
    """Count down from n to 1"""
    while n > 0:
        yield n
        n -= 1

for i in countdown(5):
    print(i)  # 5, 4, 3, 2, 1

def even_numbers(max_num):
    """Generate even numbers up to max"""
    n = 0
    while n <= max_num:
        yield n
        n += 2

for num in even_numbers(10):
    print(num)  # 0, 2, 4, 6, 8, 10

def fibonacci(max_count):
    """Generate Fibonacci sequence"""
    a, b = 0, 1
    count = 0
    
    while count < max_count:
        yield a
        a, b = b, a + b
        count += 1

print(list(fibonacci(10)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

---

## Generator Expressions

**Define: Generator expression** - Like list comprehension but with `()` instead of `[]` - creates generator, not list.

### Syntax Comparison

```python
# List comprehension - creates list immediately
squares_list = [x**2 for x in range(10)]
print(type(squares_list))  # <class 'list'>
print(squares_list)        # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Generator expression - creates generator
squares_gen = (x**2 for x in range(10))
print(type(squares_gen))  # <class 'generator'>
print(squares_gen)        # <generator object>
print(list(squares_gen))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### Memory Comparison

```python
import sys

# List - all in memory
list_comp = [x for x in range(10000)]
print(f"List size: {sys.getsizeof(list_comp)} bytes")  # ~87,000 bytes

# Generator - minimal memory
gen_expr = (x for x in range(10000))
print(f"Generator size: {sys.getsizeof(gen_expr)} bytes")  # ~128 bytes
```

### Generator Expression Examples

```python
# Even numbers
evens = (x for x in range(20) if x % 2 == 0)
print(list(evens))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# String lengths
words = ["hello", "world", "python"]
lengths = (len(w) for w in words)
print(list(lengths))  # [5, 5, 6]

# Squared evens
squared_evens = (x**2 for x in range(10) if x % 2 == 0)
print(list(squared_evens))  # [0, 4, 16, 36, 64]

# Can use in functions that accept iterables
print(sum(x**2 for x in range(5)))  # 30 (0+1+4+9+16)
print(max(x*2 for x in [1, 5, 3]))  # 10
```

---

## Set Comprehensions

**Define: Set comprehension** - Like list comprehension but creates a set (unique values, unordered).

### Basic Set Comprehension

```python
# Regular set creation
numbers = {1, 2, 3, 4, 5}

# Set comprehension
squares = {x**2 for x in range(10)}
print(squares)  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
```

### Set Comprehension Examples

```python
# Remove duplicates with transformation
numbers = [1, 2, 2, 3, 3, 3, 4, 5]
unique_doubled = {x * 2 for x in numbers}
print(unique_doubled)  # {2, 4, 6, 8, 10}

# First letters
words = ["apple", "banana", "avocado", "cherry", "apricot"]
first_letters = {w[0] for w in words}
print(first_letters)  # {'a', 'b', 'c'}

# Unique lengths
words = ["hi", "hello", "hey", "greetings", "hi"]
lengths = {len(w) for w in words}
print(lengths)  # {2, 3, 5, 9}

# Even numbers (unique by definition)
evens = {x for x in range(20) if x % 2 == 0}
print(evens)  # {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}

# Characters in string (unique)
text = "hello world"
chars = {c for c in text if c != ' '}
print(chars)  # {'h', 'e', 'l', 'o', 'w', 'r', 'd'}
```

### Set vs List Comprehension

```python
# List - keeps duplicates, maintains order
list_result = [x % 3 for x in range(10)]
print(list_result)  # [0, 1, 2, 0, 1, 2, 0, 1, 2, 0]

# Set - removes duplicates, no order
set_result = {x % 3 for x in range(10)}
print(set_result)  # {0, 1, 2}
```

---

## Advanced Comprehensions

### Nested List Comprehension

```python
# Flatten 2D list
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row]
print(flat)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# Create multiplication table
table = [[i * j for j in range(1, 6)] for i in range(1, 6)]
for row in table:
    print(row)
# [1, 2, 3, 4, 5]
# [2, 4, 6, 8, 10]
# [3, 6, 9, 12, 15]
# [4, 8, 12, 16, 20]
# [5, 10, 15, 20, 25]
```

### Dictionary Comprehension with Conditions

```python
# Square only even numbers
squares = {x: x**2 for x in range(10) if x % 2 == 0}
print(squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# Swap keys and values
original = {"a": 1, "b": 2, "c": 3}
swapped = {v: k for k, v in original.items()}
print(swapped)  # {1: 'a', 2: 'b', 3: 'c'}

# Filter dictionary
people = {"Alice": 25, "Bob": 17, "Charlie": 30, "David": 16}
adults = {name: age for name, age in people.items() if age >= 18}
print(adults)  # {'Alice': 25, 'Charlie': 30}
```

### Conditional Expressions in Comprehensions

```python
# If-else in comprehension
numbers = [1, 2, 3, 4, 5, 6]
result = ["even" if x % 2 == 0 else "odd" for x in numbers]
print(result)  # ['odd', 'even', 'odd', 'even', 'odd', 'even']

# Multiple conditions
numbers = range(20)
result = [
    "FizzBuzz" if x % 15 == 0
    else "Fizz" if x % 3 == 0
    else "Buzz" if x % 5 == 0
    else x
    for x in numbers
]
print(result)
```

---

## Practical Generator Examples

### File Reader Generator

```python
def read_large_file(filename):
    """Read file line by line without loading all into memory"""
    with open(filename, 'r') as f:
        for line in f:
            yield line.strip()

# Memory efficient - processes one line at a time!
# for line in read_large_file('huge_file.txt'):
#     process(line)
```

### Batch Generator

```python
def batch(iterable, size):
    """Generate batches of specified size"""
    batch = []
    for item in iterable:
        batch.append(item)
        if len(batch) == size:
            yield batch
            batch = []
    
    # Yield remaining items
    if batch:
        yield batch

# Process data in batches
numbers = range(10)
for group in batch(numbers, 3):
    print(group)
# [0, 1, 2]
# [3, 4, 5]
# [6, 7, 8]
# [9]
```

### Pagination Generator

```python
def paginate(items, page_size):
    """Generate pages of items"""
    for i in range(0, len(items), page_size):
        yield items[i:i + page_size]

items = list(range(25))
for page_num, page in enumerate(paginate(items, 10), 1):
    print(f"Page {page_num}: {page}")
# Page 1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# Page 2: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Page 3: [20, 21, 22, 23, 24]
```

### CSV Parser Generator

```python
def parse_csv(filename):
    """Parse CSV file line by line"""
    with open(filename, 'r') as f:
        headers = next(f).strip().split(',')
        
        for line in f:
            values = line.strip().split(',')
            yield dict(zip(headers, values))

# Use it
# for row in parse_csv('data.csv'):
#     print(row)  # {'name': 'Alice', 'age': '25', ...}
```

---

## Infinite Generators

### Count Forever

```python
def count(start=0, step=1):
    """Count infinitely"""
    current = start
    while True:
        yield current
        current += step

# Use with caution - infinite!
counter = count(10, 2)
print(next(counter))  # 10
print(next(counter))  # 12
print(next(counter))  # 14

# Use with limits
from itertools import islice
limited = list(islice(count(), 5))  # First 5
print(limited)  # [0, 1, 2, 3, 4]
```

### Cycle Through Items

```python
def cycle(iterable):
    """Cycle through items infinitely"""
    while True:
        for item in iterable:
            yield item

# Traffic light
lights = cycle(['Red', 'Yellow', 'Green'])
for _ in range(10):
    print(next(lights))
# Red, Yellow, Green, Red, Yellow, Green, Red, Yellow, Green, Red
```

### Random Number Generator

```python
import random

def random_numbers(min_val, max_val):
    """Generate random numbers infinitely"""
    while True:
        yield random.randint(min_val, max_val)

# Generate random dice rolls
dice = random_numbers(1, 6)
rolls = [next(dice) for _ in range(10)]
print(rolls)  # [3, 1, 6, 2, 5, 1, 4, 6, 2, 3]
```

---

## Generator Pipelines

### Chaining Generators

```python
def get_numbers():
    """Generate numbers"""
    for i in range(20):
        yield i

def square(numbers):
    """Square each number"""
    for n in numbers:
        yield n ** 2

def evens_only(numbers):
    """Filter even numbers only"""
    for n in numbers:
        if n % 2 == 0:
            yield n

# Chain generators together!
pipeline = evens_only(square(get_numbers()))
result = list(pipeline)
print(result)  # [0, 4, 16, 36, 64, 100, 144, 196, 256, 324]
```

### Data Processing Pipeline

```python
def read_data():
    """Simulate reading data"""
    data = [
        "  hello  ",
        "WORLD",
        "  Python  ",
        "PROGRAMMING"
    ]
    for item in data:
        yield item

def clean(items):
    """Clean data"""
    for item in items:
        yield item.strip()

def lowercase(items):
    """Convert to lowercase"""
    for item in items:
        yield item.lower()

def capitalize(items):
    """Capitalize first letter"""
    for item in items:
        yield item.capitalize()

# Build pipeline
pipeline = capitalize(lowercase(clean(read_data())))
result = list(pipeline)
print(result)  # ['Hello', 'World', 'Python', 'Programming']
```

---

## Real-Life Practical Examples

### Example 1: Log File Analyzer

```python
def read_logs(filename):
    """Read log file line by line"""
    with open(filename, 'r') as f:
        for line in f:
            yield line.strip()

def filter_errors(lines):
    """Filter only error lines"""
    for line in lines:
        if 'ERROR' in line:
            yield line

def extract_message(lines):
    """Extract error message"""
    for line in lines:
        parts = line.split(' - ')
        if len(parts) >= 2:
            yield parts[-1]

# Process logs efficiently without loading entire file!
# error_messages = extract_message(filter_errors(read_logs('server.log')))
# for msg in error_messages:
#     print(msg)
```

### Example 2: Data Stream Processor

```python
def simulate_sensor_data():
    """Simulate infinite sensor readings"""
    import random
    while True:
        temperature = round(random.uniform(20, 30), 2)
        humidity = round(random.uniform(40, 80), 2)
        yield {'temp': temperature, 'humidity': humidity}

def filter_anomalies(readings):
    """Filter abnormal readings"""
    for reading in readings:
        if reading['temp'] > 28 or reading['humidity'] < 45:
            yield reading

def alert(readings):
    """Generate alerts"""
    for reading in readings:
        alert_msg = f"âš ï¸ Anomaly detected! Temp: {reading['temp']}Â°C, Humidity: {reading['humidity']}%"
        yield alert_msg

# Process sensor stream
from itertools import islice

sensor_stream = simulate_sensor_data()
anomalies = filter_anomalies(sensor_stream)
alerts = alert(anomalies)

# Get first 5 anomalies
for alert_msg in islice(alerts, 5):
    print(alert_msg)
```

### Example 3: API Pagination Handler

```python
def fetch_paginated_data(api_url, page_size=100):
    """Fetch data from paginated API"""
    page = 1
    
    while True:
        # Simulate API call
        print(f"Fetching page {page}...")
        
        # In real code: response = requests.get(f"{api_url}?page={page}&size={page_size}")
        # Simulate data
        data = [f"item_{page}_{i}" for i in range(page_size)]
        
        if not data:
            break
        
        for item in data:
            yield item
        
        page += 1
        
        if page > 3:  # Limit for demo
            break

# Use it
from itertools import islice

items = list(islice(fetch_paginated_data("api.example.com/items"), 250))
print(f"Fetched {len(items)} items")  # 250 items from 3 pages
```

### Example 4: Fibonacci Memoization

```python
def fibonacci_gen():
    """Generate Fibonacci sequence efficiently"""
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

# Get specific Fibonacci numbers
fib = fibonacci_gen()
fib_20 = list(islice(fib, 20))
print(fib_20)

# Cache for reuse
from itertools import islice

def get_fibonacci_numbers(count):
    """Get first n Fibonacci numbers"""
    return list(islice(fibonacci_gen(), count))

print(get_fibonacci_numbers(10))
```

---

## Common Mistakes

### Mistake 1: Iterating Generator Twice

**âŒ Wrong:**
```python
gen = (x**2 for x in range(5))

print(list(gen))  # [0, 1, 4, 9, 16]
print(list(gen))  # [] - Already exhausted!
```

**âœ… Correct:**
```python
# Option 1: Create new generator
gen1 = (x**2 for x in range(5))
gen2 = (x**2 for x in range(5))

print(list(gen1))  # [0, 1, 4, 9, 16]
print(list(gen2))  # [0, 1, 4, 9, 16]

# Option 2: Use list if need multiple iterations
squares = list(x**2 for x in range(5))
print(squares)  # Can use multiple times
print(squares)  # Still works!
```

### Mistake 2: Forgetting to Convert Generator

**âŒ Wrong:**
```python
gen = (x for x in range(5))
print(gen)  # <generator object> - not values!
```

**âœ… Correct:**
```python
gen = (x for x in range(5))
print(list(gen))  # [0, 1, 2, 3, 4]

# Or iterate
for x in (x**2 for x in range(5)):
    print(x)
```

### Mistake 3: Using List When Generator Better

**âŒ Inefficient:**
```python
# Loads all million numbers!
def get_data():
    return [i for i in range(1000000)]

total = sum(get_data())  # Wastes memory
```

**âœ… Efficient:**
```python
# Generates on-demand
def get_data():
    return (i for i in range(1000000))

total = sum(get_data())  # Memory efficient!
```

---

## Best Practices

### âœ… Do This:

1. **Use Generators for Large Data**
   ```python
   # Good for large files
   def read_file(filename):
       with open(filename) as f:
           for line in f:
               yield line.strip()
   ```

2. **Generator Expression for Simple Cases**
   ```python
   # Clean and efficient
   squares = (x**2 for x in range(1000))
   ```

3. **Set Comprehension for Unique Values**
   ```python
   unique_lengths = {len(word) for word in words}
   ```

4. **Pipeline Generators**
   ```python
   pipeline = process(transform(filter(read_data())))
   ```

### âŒ Avoid This:

1. **Don't Use Generator If Need Multiple Passes**
2. **Don't Forget Generators Are Exhausted After One Use**
3. **Don't Use List When Generator Sufficient**
4. **Don't Create Infinite Generator Without Control**

---

## Summary

Congratulations! You've mastered generators, iterators, and comprehensions! ğŸ‰

**ğŸ¯ Key Takeaways:**

**ğŸ“Œ Iterators**
- `__iter__()` and `__next__()`
- One-time iteration
- Behind every for loop

**ğŸ“Œ Generators**
- Use `yield` instead of `return`
- Lazy evaluation (on-demand)
- Memory efficient
- Can be infinite

**ğŸ“Œ Generator Expressions**
- `(expression for item in iterable)`
- Like list comprehension with ()
- Creates generator, not list

**ğŸ“Œ Set Comprehensions**
- `{expression for item in iterable}`
- Returns set (unique values)
- Good for deduplication

**ğŸ“Œ Advanced Comprehensions**
- Nested loops
- Conditional expressions
- Dictionary transformations

**ğŸ’¡ Remember:**
- Generators for large data
- One-time iteration
- Yields values lazily
- Comprehensions for readability
- Sets for uniqueness

---

## Practice Exercises

### Exercise 1: Create Iterator
Create custom iterator that generates prime numbers up to n.

---

### Exercise 2: Simple Generator
Create generator function that yields powers of 2 (2^0, 2^1, 2^2, ...).

---

### Exercise 3: Generator Expression
Use generator expression to calculate sum of squares of even numbers from 1 to 100.

---

### Exercise 4: Set Comprehension
Given list with duplicates, create set comprehension to get unique word lengths.

---

### Exercise 5: File Parser Generator
Create generator that reads CSV file and yields each row as dictionary.

---

### Exercise 6: Batch Generator
Create generator that takes iterable and yields batches of size n.

---

### Exercise 7: Filter Pipeline
Create pipeline: read numbers â†’ filter evens â†’ square â†’ sum.

---

### Exercise 8: Infinite Generator
Create infinite generator that yields alternating 1 and -1.

---

### Exercise 9: Nested Comprehension
Flatten 3D list using nested list comprehension.

---

### Exercise 10: Data Stream
Create generator that simulates infinite data stream with filtering.

---

## What's Next?

You've mastered generators and iterators! ğŸ‰

In the next blog, **Chapter 20: Modern Python & Concurrency**, you'll learn:

- Type hints and annotations
- Dataclasses
- Walrus operator (`:=`)
- Match-case statements (Python 3.10+)
- Threading basics
- Multiprocessing
- Asyncio introduction
- Context managers (`__enter__`, `__exit__`)

**Why this matters:** Modern Python features make code cleaner, safer, and faster!

**Get ready to:** Write cutting-edge Python code with the latest features! ğŸš€

---

**Keep practicing!** Generators are powerful tools for memory-efficient programming!

Remember: Be lazy - generate only what you need, when you need it! ğŸ¯
