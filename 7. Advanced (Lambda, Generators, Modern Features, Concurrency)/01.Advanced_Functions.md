# Advanced Functions - Lambda, Map, Filter, and Decorators

## Table of Contents
1. [Introduction - Powerful Function Techniques](#introduction---powerful-function-techniques)
2. [Lambda Functions - Anonymous Functions](#lambda-functions---anonymous-functions)
3. [Map Function - Transform Collections](#map-function---transform-collections)
4. [Filter Function - Select Items](#filter-function---select-items)
5. [Reduce Function - Aggregate Values](#reduce-function---aggregate-values)
6. [Combining Map, Filter, and Lambda](#combining-map-filter-and-lambda)
7. [Closures - Functions Remembering State](#closures---functions-remembering-state)
8. [Decorators - Wrapping Functions](#decorators---wrapping-functions)
9. [Creating Custom Decorators](#creating-custom-decorators)
10. [Decorators with Arguments](#decorators-with-arguments)
11. [Real-Life Practical Examples](#real-life-practical-examples)
12. [Common Mistakes](#common-mistakes)
13. [Best Practices](#best-practices)
14. [Summary](#summary)
15. [Practice Exercises](#practice-exercises)
16. [What's Next?](#whats-next)

---

## Introduction - Powerful Function Techniques

You know how to create functions. Now let's learn advanced techniques that make your code shorter, cleaner, and more powerful!

**Real-World Analogy:** 
- **Regular function:** Writing a full recipe every time
- **Lambda function:** Quick cooking instruction on a sticky note
- **Map/Filter:** Assembly line processing items
- **Decorator:** Gift wrapping (adds extra features without changing the gift)

**In this blog, you'll learn:**
- Lambda functions for quick operations
- Map, filter, reduce for data transformation
- Closures for remembering state
- Decorators for adding functionality
- Real-world applications

---

## Lambda Functions - Anonymous Functions

**Define: Lambda function** - A small anonymous function defined in one line without a name.

### Why Lambda?

**Regular function:**
```python
def double(x):
    return x * 2

result = double(5)
print(result)  # 10
```

**Lambda function:**
```python
double = lambda x: x * 2

result = double(5)
print(result)  # 10
```

### Lambda Syntax

```python
lambda arguments: expression
```

- **lambda** - keyword
- **arguments** - input parameters
- **expression** - what to return (must be single expression)

### Simple Lambda Examples

```python
# No arguments
greeting = lambda: "Hello, World!"
print(greeting())  # Hello, World!

# One argument
square = lambda x: x ** 2
print(square(4))  # 16

# Multiple arguments
add = lambda a, b: a + b
print(add(3, 5))  # 8

multiply = lambda x, y, z: x * y * z
print(multiply(2, 3, 4))  # 24

# With conditional
max_value = lambda a, b: a if a > b else b
print(max_value(10, 5))  # 10
```

### When to Use Lambda?

**‚úÖ Use lambda for:**
- Quick, simple operations
- Passing functions as arguments
- Sorting with custom keys

**‚ùå Don't use lambda for:**
- Complex logic
- Multiple statements
- Anything needing documentation

### Lambda vs Regular Function

```python
# ‚ùå Too complex for lambda
def calculate_grade(score):
    if score >= 90:
        return 'A'
    elif score >= 80:
        return 'B'
    elif score >= 70:
        return 'C'
    else:
        return 'F'

# ‚úÖ Good for lambda
is_even = lambda x: x % 2 == 0
print(is_even(4))   # True
print(is_even(7))   # False
```

---

## Map Function - Transform Collections

**Define: map()** - Applies a function to every item in a collection.

### Basic Map Syntax

```python
map(function, iterable)
```

Returns a map object (convert to list to see results).

### Simple Map Examples

```python
# Double all numbers
numbers = [1, 2, 3, 4, 5]

def double(x):
    return x * 2

result = map(double, numbers)
print(list(result))  # [2, 4, 6, 8, 10]
```

### Map with Lambda

```python
numbers = [1, 2, 3, 4, 5]

# Square each number
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # [1, 4, 9, 16, 25]

# Convert to strings
text = map(lambda x: str(x), numbers)
print(list(text))  # ['1', '2', '3', '4', '5']
```

### Map with Multiple Iterables

```python
# Add corresponding elements
list1 = [1, 2, 3]
list2 = [10, 20, 30]

result = map(lambda x, y: x + y, list1, list2)
print(list(result))  # [11, 22, 33]

# Multiply three lists
a = [1, 2, 3]
b = [4, 5, 6]
c = [7, 8, 9]

result = map(lambda x, y, z: x * y * z, a, b, c)
print(list(result))  # [28, 80, 162]
```

### Practical Map Examples

```python
# Convert temperatures from Celsius to Fahrenheit
celsius = [0, 10, 20, 30, 40]
fahrenheit = map(lambda c: (c * 9/5) + 32, celsius)
print(list(fahrenheit))  # [32.0, 50.0, 68.0, 86.0, 104.0]

# Get lengths of strings
words = ["Python", "is", "awesome"]
lengths = map(len, words)
print(list(lengths))  # [6, 2, 7]

# Uppercase all names
names = ["alice", "bob", "charlie"]
upper_names = map(str.upper, names)
print(list(upper_names))  # ['ALICE', 'BOB', 'CHARLIE']
```

---

## Filter Function - Select Items

**Define: filter()** - Selects items from a collection that pass a test (return True).

### Basic Filter Syntax

```python
filter(function, iterable)
```

Returns only items where function returns True.

### Simple Filter Examples

```python
# Filter even numbers
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

def is_even(x):
    return x % 2 == 0

result = filter(is_even, numbers)
print(list(result))  # [2, 4, 6, 8, 10]
```

### Filter with Lambda

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Get odd numbers
odds = filter(lambda x: x % 2 != 0, numbers)
print(list(odds))  # [1, 3, 5, 7, 9]

# Get numbers greater than 5
greater = filter(lambda x: x > 5, numbers)
print(list(greater))  # [6, 7, 8, 9, 10]

# Get numbers divisible by 3
div_by_3 = filter(lambda x: x % 3 == 0, numbers)
print(list(div_by_3))  # [3, 6, 9]
```

### Practical Filter Examples

```python
# Filter long strings
words = ["hi", "hello", "hey", "greetings", "salutations"]
long_words = filter(lambda w: len(w) > 5, words)
print(list(long_words))  # ['greetings', 'salutations']

# Filter positive numbers
numbers = [-5, -2, 0, 3, 7, -1, 10]
positives = filter(lambda x: x > 0, numbers)
print(list(positives))  # [3, 7, 10]

# Filter valid emails (simple check)
emails = ["user@email.com", "invalid", "test@test.com", "nope"]
valid = filter(lambda e: '@' in e and '.' in e, emails)
print(list(valid))  # ['user@email.com', 'test@test.com']

# Filter students who passed
students = [
    {"name": "Alice", "score": 85},
    {"name": "Bob", "score": 55},
    {"name": "Charlie", "score": 92}
]
passed = filter(lambda s: s["score"] >= 60, students)
for student in passed:
    print(f"{student['name']} passed with {student['score']}")
# Alice passed with 85
# Charlie passed with 92
```

---

## Reduce Function - Aggregate Values

**Define: reduce()** - Repeatedly applies a function to reduce collection to single value.

### Import Reduce

```python
from functools import reduce
```

### Basic Reduce Syntax

```python
reduce(function, iterable, initializer=None)
```

### How Reduce Works

```python
# Sum all numbers
from functools import reduce

numbers = [1, 2, 3, 4, 5]

def add(x, y):
    return x + y

result = reduce(add, numbers)
print(result)  # 15

# How it works:
# Step 1: add(1, 2) = 3
# Step 2: add(3, 3) = 6
# Step 3: add(6, 4) = 10
# Step 4: add(10, 5) = 15
```

### Reduce with Lambda

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# Sum
total = reduce(lambda x, y: x + y, numbers)
print(total)  # 15

# Product
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 120

# Maximum
maximum = reduce(lambda x, y: x if x > y else y, numbers)
print(maximum)  # 5

# Minimum
minimum = reduce(lambda x, y: x if x < y else y, numbers)
print(minimum)  # 1
```

### Reduce with Initial Value

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]

# Sum with initial 10
total = reduce(lambda x, y: x + y, numbers, 10)
print(total)  # 25 (10 + 1 + 2 + 3 + 4 + 5)

# Product with initial 2
product = reduce(lambda x, y: x * y, numbers, 2)
print(product)  # 240 (2 * 1 * 2 * 3 * 4 * 5)
```

### Practical Reduce Examples

```python
from functools import reduce

# Concatenate strings
words = ["Python", "is", "awesome"]
sentence = reduce(lambda x, y: x + " " + y, words)
print(sentence)  # Python is awesome

# Flatten list of lists
lists = [[1, 2], [3, 4], [5, 6]]
flat = reduce(lambda x, y: x + y, lists)
print(flat)  # [1, 2, 3, 4, 5, 6]

# Count total characters
words = ["hello", "world", "python"]
total_chars = reduce(lambda count, word: count + len(word), words, 0)
print(total_chars)  # 16

# Merge dictionaries
dicts = [{"a": 1}, {"b": 2}, {"c": 3}]
merged = reduce(lambda x, y: {**x, **y}, dicts)
print(merged)  # {'a': 1, 'b': 2, 'c': 3}
```

---

## Combining Map, Filter, and Lambda

### Chaining Operations

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Get squares of even numbers
result = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, numbers)))
print(result)  # [4, 16, 36, 64, 100]

# Or step by step for clarity:
evens = filter(lambda x: x % 2 == 0, numbers)  # [2, 4, 6, 8, 10]
squares = map(lambda x: x ** 2, evens)         # [4, 16, 36, 64, 100]
print(list(squares))
```

### Real-World Example: Data Processing

```python
# Process product data
products = [
    {"name": "Laptop", "price": 1000, "stock": 5},
    {"name": "Mouse", "price": 25, "stock": 0},
    {"name": "Keyboard", "price": 75, "stock": 10},
    {"name": "Monitor", "price": 300, "stock": 0},
    {"name": "Headphones", "price": 50, "stock": 15}
]

# Get prices of in-stock items, with 10% discount
in_stock = filter(lambda p: p["stock"] > 0, products)
discounted = map(lambda p: p["price"] * 0.9, in_stock)
prices = list(discounted)
print(prices)  # [900.0, 67.5, 45.0]

# One line version:
prices = list(map(
    lambda p: p["price"] * 0.9,
    filter(lambda p: p["stock"] > 0, products)
))
print(prices)  # [900.0, 67.5, 45.0]
```

### Map vs List Comprehension

```python
numbers = [1, 2, 3, 4, 5]

# Map
result1 = list(map(lambda x: x ** 2, numbers))

# List comprehension (often clearer)
result2 = [x ** 2 for x in numbers]

print(result1)  # [1, 4, 9, 16, 25]
print(result2)  # [1, 4, 9, 16, 25]

# Filter
evens1 = list(filter(lambda x: x % 2 == 0, numbers))
evens2 = [x for x in numbers if x % 2 == 0]
```

**üí° Tip:** List comprehensions are often more readable than map/filter!

---

## Closures - Functions Remembering State

**Define: Closure** - A function that remembers values from enclosing scope even after outer function finishes.

### Basic Closure

```python
def outer_function(message):
    # This is the outer scope
    
    def inner_function():
        # Inner function can access outer's variables
        print(message)
    
    return inner_function

# Create closures
say_hello = outer_function("Hello!")
say_goodbye = outer_function("Goodbye!")

say_hello()    # Hello!
say_goodbye()  # Goodbye!
```

### Closure with State

```python
def counter():
    count = 0
    
    def increment():
        nonlocal count  # Access outer variable
        count += 1
        return count
    
    return increment

# Each counter maintains its own state
counter1 = counter()
counter2 = counter()

print(counter1())  # 1
print(counter1())  # 2
print(counter1())  # 3

print(counter2())  # 1 (separate count!)
print(counter2())  # 2
```

### Practical Closure Examples

```python
def multiplier(n):
    """Creates function that multiplies by n"""
    def multiply(x):
        return x * n
    return multiply

double = multiplier(2)
triple = multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15

# Power function
def power(exp):
    return lambda x: x ** exp

square = power(2)
cube = power(3)

print(square(4))  # 16
print(cube(4))    # 64
```

---

## Decorators - Wrapping Functions

**Define: Decorator** - A function that modifies or enhances another function without changing its code.

### Why Decorators?

```python
# Without decorator - repetitive logging
def add(a, b):
    print("Function called")
    result = a + b
    print("Function finished")
    return result

def subtract(a, b):
    print("Function called")
    result = a - b
    print("Function finished")
    return result

# With decorator - add logging automatically!
```

### Basic Decorator

```python
def my_decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

# Manual decoration
def say_hello():
    print("Hello!")

say_hello = my_decorator(say_hello)
say_hello()

# Output:
# Before function
# Hello!
# After function
```

### Decorator Syntax with @

```python
def my_decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

@my_decorator  # This is decorator syntax!
def say_hello():
    print("Hello!")

say_hello()
# Same output as before
```

### Decorator with Function Arguments

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):  # Accept any arguments
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} finished")
        return result
    return wrapper

@my_decorator
def add(a, b):
    return a + b

@my_decorator
def greet(name):
    return f"Hello, {name}!"

print(add(3, 5))        # 8
print(greet("Alice"))   # Hello, Alice!
```

---

## Creating Custom Decorators

### Timer Decorator

```python
import time

def timer(func):
    """Measure function execution time"""
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f} seconds")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "Done"

@timer
def fast_function():
    return sum(range(1000))

print(slow_function())  # slow_function took 1.0012 seconds
print(fast_function())  # fast_function took 0.0001 seconds
```

### Debug Decorator

```python
def debug(func):
    """Print function calls and results"""
    def wrapper(*args, **kwargs):
        args_repr = [repr(a) for a in args]
        kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
        signature = ", ".join(args_repr + kwargs_repr)
        
        print(f"Calling {func.__name__}({signature})")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result!r}")
        
        return result
    return wrapper

@debug
def add(a, b):
    return a + b

@debug
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

add(3, 5)
# Calling add(3, 5)
# add returned 8

greet("Alice")
# Calling greet('Alice')
# greet returned 'Hello, Alice!'
```

### Repeat Decorator

```python
def repeat(times):
    """Run function multiple times"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
# Hello, Alice!
# Hello, Alice!
# Hello, Alice!
```

---

## Decorators with Arguments

### Basic Decorator with Arguments

```python
def repeat(times):
    """Decorator factory"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def say_hello():
    print("Hello!")

say_hello()
# Hello!
# Hello!
# Hello!
```

### Cache Decorator

```python
def cache(func):
    """Cache function results"""
    cached_results = {}
    
    def wrapper(*args):
        if args in cached_results:
            print(f"Cache hit for {args}")
            return cached_results[args]
        
        print(f"Computing for {args}")
        result = func(*args)
        cached_results[args] = result
        return result
    
    return wrapper

@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))  # Computes once, uses cache
print(fibonacci(5))  # Cache hit!
```

### Access Control Decorator

```python
def require_admin(func):
    """Only allow admin users"""
    def wrapper(user, *args, **kwargs):
        if user.get("role") != "admin":
            print("‚ùå Access denied! Admin only.")
            return None
        return func(user, *args, **kwargs)
    return wrapper

@require_admin
def delete_user(user, target_user_id):
    print(f"‚úÖ {user['name']} deleted user {target_user_id}")

admin = {"name": "Alice", "role": "admin"}
regular = {"name": "Bob", "role": "user"}

delete_user(admin, 123)    # ‚úÖ Alice deleted user 123
delete_user(regular, 456)  # ‚ùå Access denied! Admin only.
```

---

## Real-Life Practical Examples

### Example 1: Data Pipeline

```python
# Processing sales data
sales = [
    {"product": "Laptop", "price": 1000, "quantity": 2},
    {"product": "Mouse", "price": 25, "quantity": 5},
    {"product": "Keyboard", "price": 75, "quantity": 3},
    {"product": "Monitor", "price": 300, "quantity": 1}
]

# Calculate total revenue
from functools import reduce

# Method 1: Using map and reduce
revenues = map(lambda s: s["price"] * s["quantity"], sales)
total = reduce(lambda x, y: x + y, revenues)
print(f"Total revenue: ${total}")  # $3350

# Method 2: One line
total = reduce(
    lambda acc, sale: acc + (sale["price"] * sale["quantity"]),
    sales,
    0
)
print(f"Total revenue: ${total}")  # $3350
```

### Example 2: API Rate Limiter

```python
import time
from functools import wraps

def rate_limit(max_calls, time_window):
    """Limit function calls per time window"""
    calls = []
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            nonlocal calls
            now = time.time()
            
            # Remove old calls
            calls = [c for c in calls if now - c < time_window]
            
            if len(calls) >= max_calls:
                print(f"‚ùå Rate limit exceeded! Max {max_calls} calls per {time_window}s")
                return None
            
            calls.append(now)
            return func(*args, **kwargs)
        
        return wrapper
    return decorator

@rate_limit(max_calls=3, time_window=10)
def api_call(endpoint):
    print(f"‚úÖ Called API: {endpoint}")
    return {"status": "success"}

# Try calling 5 times
for i in range(5):
    api_call(f"/endpoint{i}")
    time.sleep(1)

# First 3 succeed, last 2 are rate limited
```

### Example 3: Retry Decorator

```python
import time
from functools import wraps

def retry(max_attempts=3, delay=1):
    """Retry function on failure"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"Attempt {attempt} failed: {e}")
                    if attempt < max_attempts:
                        time.sleep(delay)
                    else:
                        print("Max retries reached")
                        raise
        return wrapper
    return decorator

@retry(max_attempts=3, delay=1)
def unreliable_network_call():
    import random
    if random.random() < 0.7:  # 70% chance of failure
        raise ConnectionError("Network error")
    return "Success!"

try:
    result = unreliable_network_call()
    print(result)
except ConnectionError:
    print("Failed after retries")
```

### Example 4: Validation Decorator

```python
from functools import wraps

def validate_positive(func):
    """Ensure all arguments are positive numbers"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        for arg in args:
            if isinstance(arg, (int, float)) and arg <= 0:
                raise ValueError(f"All arguments must be positive, got {arg}")
        return func(*args, **kwargs)
    return wrapper

@validate_positive
def calculate_area(length, width):
    return length * width

print(calculate_area(5, 10))  # 50
# print(calculate_area(-5, 10))  # ValueError!
```

---

## Common Mistakes

### Mistake 1: Lambda with Multiple Statements

**‚ùå Wrong:**
```python
# Can't do this!
calculate = lambda x: (
    result = x * 2
    return result  # Error!
)
```

**‚úÖ Correct:**
```python
def calculate(x):
    result = x * 2
    return result

# Or if simple enough:
calculate = lambda x: x * 2
```

### Mistake 2: Forgetting to Return Function in Decorator

**‚ùå Wrong:**
```python
def my_decorator(func):
    def wrapper():
        func()
    # Forgot to return wrapper!

@my_decorator
def say_hello():
    print("Hello")

# say_hello is None!
```

**‚úÖ Correct:**
```python
def my_decorator(func):
    def wrapper():
        func()
    return wrapper  # Return the wrapper!
```

### Mistake 3: Decorator Losing Function Metadata

**‚ùå Problem:**
```python
def decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@decorator
def my_function():
    """This is my function"""
    pass

print(my_function.__name__)  # wrapper (wrong!)
```

**‚úÖ Solution:**
```python
from functools import wraps

def decorator(func):
    @wraps(func)  # Preserve metadata
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@decorator
def my_function():
    """This is my function"""
    pass

print(my_function.__name__)  # my_function (correct!)
```

---

## Best Practices

### ‚úÖ Do This:

1. **Use Lambda for Simple Operations**
   ```python
   # Good
   squared = map(lambda x: x ** 2, numbers)
   
   # Avoid
   complex_calc = lambda x: (x + 5) * 2 if x > 10 else (x - 3) * 4
   ```

2. **Prefer List Comprehensions for Readability**
   ```python
   # Often clearer than map/filter
   result = [x ** 2 for x in numbers if x % 2 == 0]
   ```

3. **Use @wraps in Decorators**
   ```python
   from functools import wraps
   
   def decorator(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           return func(*args, **kwargs)
       return wrapper
   ```

4. **Name Lambda When Reusing**
   ```python
   is_adult = lambda age: age >= 18
   
   adults = filter(is_adult, ages)
   ```

### ‚ùå Avoid This:

1. **Don't Overuse Lambda**
2. **Don't Make Decorators Too Complex**
3. **Don't Forget *args, **kwargs in Wrapper**
4. **Don't Chain Too Many Map/Filter Operations**

---

## Summary

Congratulations! You've mastered advanced function techniques! üéâ

**üéØ Key Takeaways:**

**üìå Lambda Functions**
- `lambda args: expression`
- For simple, one-line operations
- Great with map, filter, sort

**üìå Map Function**
- `map(func, iterable)`
- Transform all items
- Returns map object (convert to list)

**üìå Filter Function**
- `filter(func, iterable)`
- Select items that pass test
- Returns filter object

**üìå Reduce Function**
- `reduce(func, iterable, initial)`
- Aggregate to single value
- Import from functools

**üìå Closures**
- Inner function remembering outer variables
- Maintains state between calls
- Use `nonlocal` to modify

**üìå Decorators**
- `@decorator` syntax
- Add functionality without changing code
- Use `@wraps` to preserve metadata
- Can have arguments (decorator factory)

**üí° Remember:**
- Lambda for simple operations
- Comprehensions often clearer than map/filter
- Decorators add behavior
- Use closures for state
- `@wraps` preserves function metadata

---

## Practice Exercises

### Exercise 1: Lambda Basics
Create lambda functions for: absolute value, is_odd, string length, max of two numbers.

---

### Exercise 2: Map Practice
Use map to: convert Fahrenheit list to Celsius, add "Hello " to list of names, calculate squares and cubes.

---

### Exercise 3: Filter Practice
Filter list to get: numbers > 100, strings starting with 'A', dictionaries where age > 18.

---

### Exercise 4: Reduce Practice
Use reduce to: find maximum in list, concatenate all strings, calculate factorial.

---

### Exercise 5: Combined Operations
Get sum of squares of even numbers from list using filter, map, and reduce.

---

### Exercise 6: Simple Decorator
Create `@uppercase` decorator that converts function's string return value to uppercase.

---

### Exercise 7: Logging Decorator
Create `@log` decorator that prints when function is called and what it returns.

---

### Exercise 8: Timing Decorator
Create `@time_it` decorator that measures and prints execution time.

---

### Exercise 9: Validation Decorator
Create `@validate_types` decorator that checks if arguments are correct types.

---

### Exercise 10: Counter Closure
Create closure that counts function calls and returns count.

---

## What's Next?

You've mastered advanced functions! üéâ

In the next blog, **Chapter 19: Generators & Iterators**, you'll learn:

- What are iterators?
- Iterator protocol (`__iter__`, `__next__`)
- Generator functions with `yield`
- Generator expressions
- Memory-efficient data processing
- Infinite sequences
- Real-world generator applications

**Why this matters:** Generators let you work with huge datasets efficiently without loading everything into memory!

**Get ready to:** Create lazy, memory-efficient data pipelines! üöÄ

---

**Keep practicing!** Lambda, map, filter, and decorators are everywhere in professional Python code!

Remember: Functions are first-class objects - treat them like data! üéØ
