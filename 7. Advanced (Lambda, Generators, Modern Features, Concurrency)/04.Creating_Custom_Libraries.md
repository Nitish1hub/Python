# Creating Custom Libraries & Packages

## Table of Contents
1. [Introduction - Why Create Libraries?](#introduction---why-create-libraries)
2. [Understanding Modules](#understanding-modules)
3. [Creating Your First Module](#creating-your-first-module)
4. [Organizing Code with Packages](#organizing-code-with-packages)
5. [The __init__.py File](#the-__init__py-file)
6. [Importing from Your Library](#importing-from-your-library)
7. [Best Practices for Library Design](#best-practices-for-library-design)
8. [Adding Documentation](#adding-documentation)
9. [Creating Installable Packages](#creating-installable-packages)
10. [Publishing to PyPI](#publishing-to-pypi)
11. [Real-Life Practical Examples](#real-life-practical-examples)
12. [Common Mistakes](#common-mistakes)
13. [Best Practices](#best-practices)
14. [Summary](#summary)
15. [Practice Exercises](#practice-exercises)
16. [What's Next?](#whats-next)

---

## Introduction - Why Create Libraries?

Creating your own libraries helps you write **reusable, organized, and maintainable** code!

**Real-World Analogy:**
- **Using libraries:** Borrowing books from a library
- **Creating libraries:** Writing your own books for others to use
- **Modules:** Individual chapters
- **Packages:** Complete book series

**In this blog, you'll learn:**
- Create reusable modules
- Organize code into packages
- Share your code with others
- Publish libraries to PyPI
- Follow Python best practices

---

## Understanding Modules

**Define: Module** - A Python file (.py) containing functions, classes, and variables that can be imported into other programs.

### Why Modules?

**Without Modules:**
```python
# main.py - Everything in one file (messy!)

def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    return a / b

def validate_email(email):
    return "@" in email

def format_name(name):
    return name.title()

# ... hundreds more functions ...

# Your actual program
result = add(5, 3)
```

**With Modules:**
```python
# math_utils.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# string_utils.py
def validate_email(email):
    return "@" in email

def format_name(name):
    return name.title()

# main.py - Clean and organized!
import math_utils
import string_utils

result = math_utils.add(5, 3)
name = string_utils.format_name("john")
```

**Benefits:**
- âœ… **Organization** - Related code together
- âœ… **Reusability** - Use in multiple projects
- âœ… **Maintainability** - Easy to find and fix
- âœ… **Collaboration** - Team members work on different modules

---

## Creating Your First Module

### Step 1: Create a Simple Module

**File: calculator.py**
```python
"""
Simple calculator module
Provides basic math operations
"""

def add(a, b):
    """Add two numbers"""
    return a + b

def subtract(a, b):
    """Subtract b from a"""
    return a - b

def multiply(a, b):
    """Multiply two numbers"""
    return a * b

def divide(a, b):
    """Divide a by b"""
    if b == 0:
        raise ValueError("Cannot divide by zero!")
    return a / b

# Module-level variable
PI = 3.14159

# Module-level function
def circle_area(radius):
    """Calculate circle area"""
    return PI * radius ** 2
```

### Step 2: Use Your Module

**File: main.py (in same folder)**
```python
# Import the module
import calculator

# Use functions
result1 = calculator.add(10, 5)
result2 = calculator.subtract(10, 5)
result3 = calculator.multiply(10, 5)
result4 = calculator.divide(10, 5)

print(f"Add: {result1}")        # 15
print(f"Subtract: {result2}")   # 5
print(f"Multiply: {result3}")   # 50
print(f"Divide: {result4}")     # 2.0

# Use module variable
print(f"PI = {calculator.PI}")

# Use module function
area = calculator.circle_area(5)
print(f"Area: {area}")
```

### Different Import Methods

```python
# Method 1: Import entire module
import calculator
result = calculator.add(5, 3)

# Method 2: Import with alias
import calculator as calc
result = calc.add(5, 3)

# Method 3: Import specific function
from calculator import add
result = add(5, 3)

# Method 4: Import multiple items
from calculator import add, subtract, PI
result = add(5, 3)

# Method 5: Import everything (not recommended)
from calculator import *
result = add(5, 3)
```

---

## Organizing Code with Packages

**Define: Package** - A directory containing multiple modules with an `__init__.py` file.

### Creating a Package Structure

```
myproject/
â”‚
â”œâ”€â”€ main.py
â”‚
â””â”€â”€ mylib/                  # Package folder
    â”œâ”€â”€ __init__.py         # Makes it a package
    â”œâ”€â”€ math_ops.py         # Module 1
    â”œâ”€â”€ string_ops.py       # Module 2
    â””â”€â”€ file_ops.py         # Module 3
```

### Example Package Files

**File: mylib/__init__.py**
```python
"""
MyLib - Custom utility library
"""

# Package metadata
__version__ = "1.0.0"
__author__ = "Your Name"

# Make functions available at package level
from .math_ops import add, subtract
from .string_ops import capitalize_words

# Package initializes here
print(f"MyLib v{__version__} loaded")
```

**File: mylib/math_ops.py**
```python
"""Math operations module"""

def add(a, b):
    """Add two numbers"""
    return a + b

def subtract(a, b):
    """Subtract b from a"""
    return a - b

def multiply(a, b):
    """Multiply two numbers"""
    return a * b

def power(base, exponent):
    """Calculate base to the power of exponent"""
    return base ** exponent
```

**File: mylib/string_ops.py**
```python
"""String operations module"""

def capitalize_words(text):
    """Capitalize first letter of each word"""
    return text.title()

def reverse_string(text):
    """Reverse a string"""
    return text[::-1]

def count_vowels(text):
    """Count vowels in text"""
    vowels = "aeiouAEIOU"
    return sum(1 for char in text if char in vowels)

def remove_spaces(text):
    """Remove all spaces from text"""
    return text.replace(" ", "")
```

**File: mylib/file_ops.py**
```python
"""File operations module"""

def read_file(filename):
    """Read entire file content"""
    try:
        with open(filename, 'r') as f:
            return f.read()
    except FileNotFoundError:
        return None

def write_file(filename, content):
    """Write content to file"""
    with open(filename, 'w') as f:
        f.write(content)

def append_file(filename, content):
    """Append content to file"""
    with open(filename, 'a') as f:
        f.write(content)

def count_lines(filename):
    """Count number of lines in file"""
    try:
        with open(filename, 'r') as f:
            return len(f.readlines())
    except FileNotFoundError:
        return 0
```

### Using Your Package

**File: main.py**
```python
# Import entire package
import mylib

# Import specific module
from mylib import math_ops
from mylib import string_ops

# Use functions
result = math_ops.add(10, 5)
print(f"10 + 5 = {result}")

text = string_ops.capitalize_words("hello world")
print(f"Capitalized: {text}")

# Import from package level (defined in __init__.py)
from mylib import add, subtract
print(f"Add: {add(10, 5)}")
```

---

## The __init__.py File

**Define:** `__init__.py` is a special file that marks a directory as a Python package.

### Empty __init__.py

```python
# mylib/__init__.py
# Empty file - just marks directory as package
```

### Simple __init__.py

```python
# mylib/__init__.py
"""MyLib - Custom utility library"""

__version__ = "1.0.0"
```

### Advanced __init__.py

```python
# mylib/__init__.py
"""
MyLib - Custom utility library
Provides math, string, and file operations
"""

__version__ = "1.0.0"
__author__ = "Your Name"
__email__ = "your.email@example.com"

# Import key functions to package level
from .math_ops import add, subtract, multiply, power
from .string_ops import capitalize_words, reverse_string
from .file_ops import read_file, write_file

# Define what's exported with "from mylib import *"
__all__ = [
    'add', 'subtract', 'multiply', 'power',
    'capitalize_words', 'reverse_string',
    'read_file', 'write_file'
]

# Initialization code
def _initialize():
    """Private initialization function"""
    print(f"MyLib v{__version__} initialized")

_initialize()
```

### Package with Subpackages

```
mylib/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ math/                   # Subpackage
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ basic.py
â”‚   â””â”€â”€ advanced.py
â”œâ”€â”€ strings/                # Subpackage
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ formatting.py
â”‚   â””â”€â”€ validation.py
â””â”€â”€ files/                  # Subpackage
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ readers.py
    â””â”€â”€ writers.py
```

**Using subpackages:**
```python
# Import from subpackage
from mylib.math import basic
from mylib.strings.formatting import capitalize

result = basic.add(5, 3)
text = capitalize("hello")
```

---

## Importing from Your Library

### Relative Imports (Within Package)

**File: mylib/string_ops.py**
```python
# Import from sibling module in same package
from .math_ops import add

def repeat_string(text, times):
    """Repeat string n times"""
    # Use function from math_ops
    count = add(times, 0)  # Just an example
    return text * count
```

### Absolute Imports

```python
# From outside package
from mylib.math_ops import add
from mylib.string_ops import capitalize_words

# Or
import mylib.math_ops
```

### Conditional Imports

```python
# Import different modules based on conditions
import sys

if sys.version_info >= (3, 8):
    from .modern_features import new_function
else:
    from .legacy_features import old_function
```

---

## Best Practices for Library Design

### 1. Clear Module Organization

```python
# Good
mylib/
â”œâ”€â”€ math_ops.py      # Clear purpose
â”œâ”€â”€ string_ops.py
â””â”€â”€ file_ops.py

# Bad
mylib/
â”œâ”€â”€ utils.py         # Too vague
â”œâ”€â”€ helpers.py
â””â”€â”€ stuff.py
```

### 2. Descriptive Function Names

```python
# Good
def calculate_circle_area(radius):
    return 3.14159 * radius ** 2

# Bad
def calc(r):  # Unclear
    return 3.14159 * r ** 2
```

### 3. Type Hints

```python
from typing import List, Optional

def process_numbers(numbers: List[int]) -> int:
    """Calculate sum of numbers"""
    return sum(numbers)

def find_user(user_id: int) -> Optional[dict]:
    """Find user by ID, return None if not found"""
    # ... implementation
    return user_data
```

### 4. Error Handling

```python
def divide(a, b):
    """Divide a by b with error handling"""
    if not isinstance(a, (int, float)):
        raise TypeError("a must be a number")
    if not isinstance(b, (int, float)):
        raise TypeError("b must be a number")
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
```

### 5. Default Arguments

```python
def greet(name, greeting="Hello"):
    """Greet user with custom greeting"""
    return f"{greeting}, {name}!"

# Use with default
print(greet("Alice"))  # Hello, Alice!

# Use with custom
print(greet("Bob", "Hi"))  # Hi, Bob!
```

---

## Adding Documentation

### Module Docstrings

```python
"""
mylib.math_ops
~~~~~~~~~~~~~~

Provides mathematical operations.

Usage:
    from mylib import math_ops
    result = math_ops.add(5, 3)

:copyright: (c) 2024 Your Name
:license: MIT
"""

def add(a, b):
    """
    Add two numbers.
    
    Args:
        a (int|float): First number
        b (int|float): Second number
    
    Returns:
        int|float: Sum of a and b
    
    Example:
        >>> add(5, 3)
        8
        >>> add(2.5, 1.5)
        4.0
    """
    return a + b
```

### Package Documentation

**File: mylib/README.md**
```markdown
# MyLib

Custom Python library for common operations.

## Installation

```python
pip install mylib
```

## Usage

```python
from mylib import add, capitalize_words

result = add(5, 3)
text = capitalize_words("hello world")
```

## Modules

- **math_ops**: Mathematical operations
- **string_ops**: String manipulation
- **file_ops**: File handling
```

---

## Creating Installable Packages

### Package Structure

```
mylib_project/
â”œâ”€â”€ mylib/              # Your package
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ math_ops.py
â”‚   â””â”€â”€ string_ops.py
â”œâ”€â”€ tests/              # Tests
â”‚   â””â”€â”€ test_math_ops.py
â”œâ”€â”€ setup.py            # Installation script
â”œâ”€â”€ README.md           # Documentation
â”œâ”€â”€ LICENSE             # License file
â””â”€â”€ requirements.txt    # Dependencies
```

### setup.py File

```python
from setuptools import setup, find_packages

# Read long description from README
with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

setup(
    name="mylib",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="Custom utility library",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/yourusername/mylib",
    packages=find_packages(),
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    python_requires='>=3.7',
    install_requires=[
        # List dependencies here
        # "requests>=2.25.0",
    ],
)
```

### Installing Locally

```bash
# Install in development mode (editable)
pip install -e .

# Install normally
pip install .

# Create distribution
python setup.py sdist bdist_wheel
```

### Using setup.cfg (Modern Approach)

**File: setup.cfg**
```ini
[metadata]
name = mylib
version = 1.0.0
author = Your Name
author_email = your.email@example.com
description = Custom utility library
long_description = file: README.md
long_description_content_type = text/markdown
url = https://github.com/yourusername/mylib
classifiers =
    Programming Language :: Python :: 3
    License :: OSI Approved :: MIT License

[options]
packages = find:
python_requires = >=3.7
install_requires =
    # Add dependencies
```

**File: setup.py (minimal)**
```python
from setuptools import setup
setup()
```

---

## Publishing to PyPI

### Step 1: Create Accounts

1. Register at [https://pypi.org/](https://pypi.org/)
2. Register at [https://test.pypi.org/](https://test.pypi.org/) (for testing)

### Step 2: Install Tools

```bash
pip install twine
pip install build
```

### Step 3: Build Package

```bash
# Build distribution files
python -m build

# Creates:
# dist/mylib-1.0.0.tar.gz
# dist/mylib-1.0.0-py3-none-any.whl
```

### Step 4: Upload to Test PyPI

```bash
# Upload to test server first
twine upload --repository testpypi dist/*

# Test installation
pip install --index-url https://test.pypi.org/simple/ mylib
```

### Step 5: Upload to PyPI

```bash
# Upload to real PyPI
twine upload dist/*

# Anyone can now install
pip install mylib
```

### Step 6: API Token Setup

```bash
# Create .pypirc file in home directory
# ~/.pypirc (Linux/Mac) or %USERPROFILE%\.pypirc (Windows)

[pypi]
username = __token__
password = pypi-your-api-token-here
```

---

## Real-Life Practical Examples

### Example 1: Data Validation Library

**File: validators/__init__.py**
```python
"""Data validation library"""
__version__ = "1.0.0"

from .email import is_valid_email
from .phone import is_valid_phone
from .password import is_strong_password
```

**File: validators/email.py**
```python
"""Email validation"""
import re

def is_valid_email(email):
    """
    Validate email address
    
    Args:
        email (str): Email to validate
    
    Returns:
        bool: True if valid
    
    Example:
        >>> is_valid_email("user@example.com")
        True
    """
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    return bool(re.match(pattern, email))

def get_domain(email):
    """Extract domain from email"""
    if is_valid_email(email):
        return email.split('@')[1]
    return None
```

**File: validators/password.py**
```python
"""Password validation"""

def is_strong_password(password):
    """
    Check if password is strong
    Requirements: 8+ chars, uppercase, lowercase, number
    """
    if len(password) < 8:
        return False
    
    has_upper = any(c.isupper() for c in password)
    has_lower = any(c.islower() for c in password)
    has_digit = any(c.isdigit() for c in password)
    
    return has_upper and has_lower and has_digit

def password_strength(password):
    """Rate password strength"""
    score = 0
    
    if len(password) >= 8:
        score += 1
    if len(password) >= 12:
        score += 1
    if any(c.isupper() for c in password):
        score += 1
    if any(c.islower() for c in password):
        score += 1
    if any(c.isdigit() for c in password):
        score += 1
    if any(c in "!@#$%^&*" for c in password):
        score += 1
    
    levels = ["Very Weak", "Weak", "Fair", "Good", "Strong", "Very Strong"]
    index = min(score, len(levels) - 1)
    return levels[index]
```

**Usage:**
```python
from validators import is_valid_email, is_strong_password

email = "user@example.com"
password = "MyPass123"

if is_valid_email(email):
    print("Valid email")

if is_strong_password(password):
    print("Strong password")
```

### Example 2: File Processing Library

**File: file_tools/__init__.py**
```python
"""File processing utilities"""
__version__ = "1.0.0"

from .readers import read_csv, read_json, read_txt
from .writers import write_csv, write_json
from .analyzers import file_stats, find_duplicates
```

**File: file_tools/readers.py**
```python
"""File reading utilities"""
import csv
import json

def read_csv(filename, has_header=True):
    """Read CSV file and return list of dictionaries"""
    with open(filename, 'r') as f:
        if has_header:
            reader = csv.DictReader(f)
            return list(reader)
        else:
            reader = csv.reader(f)
            return list(reader)

def read_json(filename):
    """Read JSON file"""
    with open(filename, 'r') as f:
        return json.load(f)

def read_txt(filename):
    """Read text file, return lines"""
    with open(filename, 'r') as f:
        return f.readlines()
```

**File: file_tools/writers.py**
```python
"""File writing utilities"""
import csv
import json

def write_csv(filename, data, fieldnames=None):
    """Write data to CSV file"""
    if not data:
        return
    
    if fieldnames is None:
        fieldnames = data[0].keys()
    
    with open(filename, 'w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(data)

def write_json(filename, data, indent=2):
    """Write data to JSON file"""
    with open(filename, 'w') as f:
        json.dump(data, f, indent=indent)
```

**File: file_tools/analyzers.py**
```python
"""File analysis utilities"""
import os

def file_stats(filename):
    """Get file statistics"""
    stats = {}
    stats['size_bytes'] = os.path.getsize(filename)
    stats['size_kb'] = stats['size_bytes'] / 1024
    
    with open(filename, 'r') as f:
        content = f.read()
        stats['lines'] = content.count('\n') + 1
        stats['words'] = len(content.split())
        stats['chars'] = len(content)
    
    return stats

def find_duplicates(directory, extension='.txt'):
    """Find duplicate files by size"""
    file_sizes = {}
    
    for filename in os.listdir(directory):
        if filename.endswith(extension):
            filepath = os.path.join(directory, filename)
            size = os.path.getsize(filepath)
            
            if size in file_sizes:
                file_sizes[size].append(filename)
            else:
                file_sizes[size] = [filename]
    
    # Return only sizes with duplicates
    return {size: files for size, files in file_sizes.items() if len(files) > 1}
```

**Usage:**
```python
from file_tools import read_csv, write_json, file_stats

# Read CSV
data = read_csv('users.csv')

# Convert to JSON
write_json('users.json', data)

# Analyze file
stats = file_stats('data.txt')
print(f"File has {stats['lines']} lines")
```

### Example 3: API Helper Library

**File: api_helper/__init__.py**
```python
"""API helper utilities"""
__version__ = "1.0.0"

from .client import APIClient
from .decorators import rate_limit, retry
from .response import parse_json, handle_errors
```

**File: api_helper/client.py**
```python
"""API client"""
import requests
from typing import Optional, Dict

class APIClient:
    """Simple API client with common features"""
    
    def __init__(self, base_url: str, auth_token: Optional[str] = None):
        self.base_url = base_url.rstrip('/')
        self.auth_token = auth_token
        self.session = requests.Session()
        
        if auth_token:
            self.session.headers.update({
                'Authorization': f'Bearer {auth_token}'
            })
    
    def get(self, endpoint: str, params: Optional[Dict] = None):
        """Make GET request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        response = self.session.get(url, params=params)
        response.raise_for_status()
        return response.json()
    
    def post(self, endpoint: str, data: Dict):
        """Make POST request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        response = self.session.post(url, json=data)
        response.raise_for_status()
        return response.json()
    
    def put(self, endpoint: str, data: Dict):
        """Make PUT request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        response = self.session.put(url, json=data)
        response.raise_for_status()
        return response.json()
    
    def delete(self, endpoint: str):
        """Make DELETE request"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        response = self.session.delete(url)
        response.raise_for_status()
        return response.status_code == 204
```

**Usage:**
```python
from api_helper import APIClient

# Create client
api = APIClient('https://api.example.com', auth_token='your-token')

# Make requests
users = api.get('/users')
new_user = api.post('/users', {'name': 'Alice', 'email': 'alice@example.com'})
```

---

## Common Mistakes

### Mistake 1: Circular Imports

**âŒ Wrong:**
```python
# module_a.py
from module_b import funcB

def funcA():
    return funcB()

# module_b.py
from module_a import funcA  # Circular!

def funcB():
    return funcA()
```

**âœ… Correct:**
```python
# module_a.py
def funcA():
    from module_b import funcB  # Import inside function
    return funcB()

# Or restructure to avoid circular dependency
```

### Mistake 2: Missing __init__.py

**âŒ Wrong:**
```
mylib/
â”œâ”€â”€ math_ops.py
â””â”€â”€ string_ops.py

# Can't import as package!
```

**âœ… Correct:**
```
mylib/
â”œâ”€â”€ __init__.py  # Makes it a package
â”œâ”€â”€ math_ops.py
â””â”€â”€ string_ops.py
```

### Mistake 3: Using Mutable Default Arguments

**âŒ Wrong:**
```python
def add_item(item, items=[]):  # Dangerous!
    items.append(item)
    return items

# Same list is reused!
list1 = add_item(1)  # [1]
list2 = add_item(2)  # [1, 2] - unexpected!
```

**âœ… Correct:**
```python
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

---

## Best Practices

### âœ… Do This:

1. **Clear Module Names**
   ```python
   # Good
   math_operations.py
   string_utilities.py
   
   # Bad
   utils.py
   helpers.py
   ```

2. **Type Hints**
   ```python
   def process(data: List[int]) -> int:
       return sum(data)
   ```

3. **Docstrings**
   ```python
   def add(a, b):
       """Add two numbers and return result"""
       return a + b
   ```

4. **Version Your Package**
   ```python
   # __init__.py
   __version__ = "1.0.0"
   ```

5. **Write Tests**
   ```python
   # tests/test_math_ops.py
   def test_add():
       assert add(2, 3) == 5
   ```

### âŒ Avoid This:

1. **Don't Use `from module import *`**
2. **Don't Have Circular Imports**
3. **Don't Put Too Much in One Module**
4. **Don't Forget Error Handling**
5. **Don't Skip Documentation**

---

## Summary

Congratulations! You've learned how to create custom libraries! ğŸ‰

**ğŸ¯ Key Takeaways:**

**ğŸ“Œ Modules**
- Single Python file (.py)
- Contains functions, classes, variables
- Import with `import module_name`

**ğŸ“Œ Packages**
- Directory with `__init__.py`
- Contains multiple modules
- Organized code structure

**ğŸ“Œ __init__.py**
- Marks directory as package
- Can import key functions
- Package initialization code

**ğŸ“Œ Library Design**
- Clear organization
- Type hints
- Documentation
- Error handling
- Tests

**ğŸ“Œ Distribution**
- setup.py for installation
- PyPI for sharing
- pip install your-package

**ğŸ’¡ Remember:**
- Modules = Reusable code
- Packages = Organized modules
- Documentation = Happy users
- Tests = Reliable code
- PyPI = Share with world

---

## Practice Exercises

### Exercise 1: Simple Module
Create a `temperature.py` module with functions to convert between Celsius, Fahrenheit, and Kelvin.

---

### Exercise 2: String Utils Package
Create a `stringutils` package with modules for: formatting, validation, and analysis.

---

### Exercise 3: Math Library
Create a `mathlib` package with modules for: basic operations, geometry, and statistics.

---

### Exercise 4: File Manager
Create a library that manages files: read, write, backup, and restore.

---

### Exercise 5: Data Processor
Create a package to process CSV, JSON, and Excel files with common operations.

---

### Exercise 6: API Wrapper
Create a library that wraps a public API (weather, quotes, etc.) with easy functions.

---

### Exercise 7: Logger Library
Create a custom logging library with different log levels and file output.

---

### Exercise 8: Config Manager
Create a library to read/write configuration files (JSON, YAML, INI).

---

### Exercise 9: Test Framework
Create a simple testing library with assertion functions.

---

### Exercise 10: Complete Library
Build a complete utility library with documentation and publish to Test PyPI.

---

## What's Next?

**Congratulations on completing the Python Mastery Series!** ğŸŠ

You've learned:
- âœ… Python fundamentals
- âœ… Data structures
- âœ… OOP principles
- âœ… File handling
- âœ… Functional programming
- âœ… Modern Python features
- âœ… Creating libraries

**Continue Your Journey:**

1. **Build Real Projects**
   - Web applications (Flask/Django)
   - Data analysis projects
   - Automation scripts
   - Machine learning models

2. **Contribute to Open Source**
   - Find projects on GitHub
   - Fix bugs, add features
   - Learn from experienced developers

3. **Specialize**
   - Web Development
   - Data Science
   - Machine Learning
   - DevOps/Automation
   - Game Development

4. **Keep Learning**
   - Advanced design patterns
   - Performance optimization
   - Asynchronous programming
   - Testing strategies
   - Cloud deployment

**You're now a Python developer!** ğŸâœ¨

Go build amazing things! ğŸš€

---

**Thank you for completing this series!** ğŸ™

Remember: The best way to learn is by building. Start your next project today!

Happy coding! ğŸ’»
