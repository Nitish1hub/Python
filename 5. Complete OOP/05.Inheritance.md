# Inheritance - Building on Existing Classes

## Table of Contents
1. [Introduction - Building Class Families](#introduction---building-class-families)
2. [What is Inheritance?](#what-is-inheritance)
3. [Creating Child Classes](#creating-child-classes)
4. [Inheriting Attributes and Methods](#inheriting-attributes-and-methods)
5. [The super() Function](#the-super-function)
6. [Method Overriding](#method-overriding)
7. [Adding New Methods](#adding-new-methods)
8. [Multi-Level Inheritance](#multi-level-inheritance)
9. [isinstance() and issubclass()](#isinstance-and-issubclass)
10. [Real-Life Practical Examples](#real-life-practical-examples)
11. [Common Mistakes](#common-mistakes)
12. [Best Practices](#best-practices)
13. [Summary](#summary)
14. [Practice Exercises](#practice-exercises)
15. [What's Next?](#whats-next)

---

## Introduction - Building Class Families

Instead of writing similar classes from scratch, inherit from existing classes and extend them! This promotes code reuse and models real-world relationships.

**Real-World Analogy:** Think of family inheritance:
- **Parent** = Has certain traits (eye color, height)
- **Child** = Inherits parent's traits + has unique traits
- You don't start from zero - you build on what parents have!

**In this blog, you'll learn:**
- Creating child classes from parent classes
- Inheriting and using parent's methods
- Overriding parent methods
- Using super() to call parent methods
- Building class hierarchies

---

## What is Inheritance?

**Define: Inheritance** - Creating a new class based on an existing class.

**Define: Parent class** - The class being inherited from (also called base class or superclass).

**Define: Child class** - The class inheriting (also called derived class or subclass).

### Why Inheritance?

**Without inheritance:**
```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name} is eating")
    
    def sleep(self):
        print(f"{self.name} is sleeping")

class Cat:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name} is eating")
    
    def sleep(self):
        print(f"{self.name} is sleeping")

# Lots of duplicate code! üòü
```

**With inheritance:**
```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name} is eating")
    
    def sleep(self):
        print(f"{self.name} is sleeping")

class Dog(Animal):  # Inherits from Animal
    pass

class Cat(Animal):  # Inherits from Animal
    pass

# No duplicate code! üéâ
dog = Dog("Buddy", 3)
dog.eat()  # Works! Inherited from Animal
```

---

## Creating Child Classes

### Basic Syntax

```python
class ParentClass:
    # Parent code
    pass

class ChildClass(ParentClass):  # ChildClass inherits from ParentClass
    # Child code
    pass
```

### Example: Animal Family

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(f"{self.name} makes a sound")

# Dog inherits from Animal
class Dog(Animal):
    pass

# Create a dog
dog = Dog("Buddy")
dog.speak()  # Buddy makes a sound (inherited method!)
```

---

## Inheriting Attributes and Methods

### Child Has Everything from Parent

```python
class Vehicle:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
    
    def start(self):
        print(f"{self.brand} {self.model} is starting")
    
    def stop(self):
        print(f"{self.brand} {self.model} is stopping")

class Car(Vehicle):
    pass  # Inherits everything!

# Create a car
car = Car("Toyota", "Camry")

# Has all Vehicle attributes
print(car.brand)  # Toyota
print(car.model)  # Camry

# Has all Vehicle methods
car.start()  # Toyota Camry is starting
car.stop()   # Toyota Camry is stopping
```

### Multiple Children

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        print(f"{self.name} is eating")

class Dog(Animal):
    pass

class Cat(Animal):
    pass

class Bird(Animal):
    pass

# All children inherit from Animal
dog = Dog("Buddy")
cat = Cat("Whiskers")
bird = Bird("Tweety")

dog.eat()   # Buddy is eating
cat.eat()   # Whiskers is eating
bird.eat()  # Tweety is eating
```

---

## The super() Function

**Define: super()** - Calls methods from the parent class.

### Why super()?

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Dog(Animal):
    def __init__(self, name, age, breed):
        # Need to initialize parent's attributes
        # Option 1: Call parent directly (not recommended)
        # Animal.__init__(self, name, age)
        
        # Option 2: Use super() (recommended!)
        super().__init__(name, age)
        
        # Then add child-specific attribute
        self.breed = breed

dog = Dog("Buddy", 3, "Golden Retriever")
print(f"{dog.name}, {dog.age}, {dog.breed}")
# Buddy, 3, Golden Retriever
```

### super() in __init__

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(f"Person created: {name}")

class Student(Person):
    def __init__(self, name, age, student_id):
        # Call parent's __init__
        super().__init__(name, age)
        
        # Add student-specific attribute
        self.student_id = student_id
        print(f"Student ID: {student_id}")

student = Student("Alice", 20, "S12345")
# Output:
# Person created: Alice
# Student ID: S12345

print(f"{student.name}, {student.age}, {student.student_id}")
# Alice, 20, S12345
```

### super() with Methods

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def speak(self):
        print(f"{self.name} makes a sound")

class Dog(Animal):
    def speak(self):
        # Call parent's speak first
        super().speak()
        # Then add dog-specific behavior
        print(f"{self.name} barks: Woof!")

dog = Dog("Buddy")
dog.speak()
# Output:
# Buddy makes a sound
# Buddy barks: Woof!
```

---

## Method Overriding

**Define: Method overriding** - Child class provides its own implementation of parent's method.

### Basic Override

```python
class Animal:
    def speak(self):
        print("Animal makes a sound")

class Dog(Animal):
    def speak(self):  # Override!
        print("Woof!")

class Cat(Animal):
    def speak(self):  # Override!
        print("Meow!")

# Each child has different behavior
animal = Animal()
dog = Dog()
cat = Cat()

animal.speak()  # Animal makes a sound
dog.speak()     # Woof!
cat.speak()     # Meow!
```

### Override with super()

```python
class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def get_details(self):
        return f"Employee: {self.name}, Salary: ${self.salary}"

class Manager(Employee):
    def __init__(self, name, salary, department):
        super().__init__(name, salary)
        self.department = department
    
    def get_details(self):  # Override
        # Call parent's version first
        details = super().get_details()
        # Add manager-specific info
        return f"{details}, Department: {self.department}"

manager = Manager("Alice", 80000, "Engineering")
print(manager.get_details())
# Employee: Alice, Salary: $80000, Department: Engineering
```

### Complete Override Example

```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand
    
    def start(self):
        print(f"{self.brand} vehicle is starting...")

class ElectricCar(Vehicle):
    def start(self):  # Completely override (no super())
        print(f"{self.brand} electric car powering on silently...")

class GasCar(Vehicle):
    def start(self):  # Override with super()
        super().start()  # Call parent version
        print("Engine roaring!")

electric = ElectricCar("Tesla")
gas = GasCar("Ford")

electric.start()
# Tesla electric car powering on silently...

gas.start()
# Ford vehicle is starting...
# Engine roaring!
```

---

## Adding New Methods

### Child-Specific Methods

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        print(f"{self.name} is eating")

class Dog(Animal):
    # New method not in parent
    def fetch(self):
        print(f"{self.name} is fetching the ball!")
    
    def roll_over(self):
        print(f"{self.name} rolls over!")

dog = Dog("Buddy")

# Inherited methods
dog.eat()  # Buddy is eating

# Dog-specific methods
dog.fetch()      # Buddy is fetching the ball!
dog.roll_over()  # Buddy rolls over!

# Animal doesn't have these methods
animal = Animal("Generic")
animal.eat()  # Works
# animal.fetch()  # AttributeError!
```

### Example: BankAccount Hierarchy

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner
        self.balance = balance
    
    def deposit(self, amount):
        self.balance = self.balance + amount
        print(f"Deposited ${amount}. Balance: ${self.balance}")
    
    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds!")
            return
        self.balance = self.balance - amount
        print(f"Withdrew ${amount}. Balance: ${self.balance}")

class SavingsAccount(BankAccount):
    def __init__(self, owner, balance, interest_rate):
        super().__init__(owner, balance)
        self.interest_rate = interest_rate
    
    # New method unique to savings account
    def add_interest(self):
        interest = self.balance * self.interest_rate
        self.balance = self.balance + interest
        print(f"Interest added: ${interest:.2f}. Balance: ${self.balance:.2f}")

# Use savings account
savings = SavingsAccount("Alice", 1000, 0.02)

# Inherited methods
savings.deposit(500)   # Deposited $500. Balance: $1500
savings.withdraw(200)  # Withdrew $200. Balance: $1300

# Savings-specific method
savings.add_interest()  # Interest added: $26.00. Balance: $1326.00
```

---

## Multi-Level Inheritance

**Define: Multi-level inheritance** - Child class inherits from another child class.

### Grandparent ‚Üí Parent ‚Üí Child

```python
class LivingThing:
    def __init__(self, name):
        self.name = name
    
    def breathe(self):
        print(f"{self.name} is breathing")

class Animal(LivingThing):
    def move(self):
        print(f"{self.name} is moving")

class Dog(Animal):
    def bark(self):
        print(f"{self.name} says Woof!")

# Dog inherits from Animal, which inherits from LivingThing
dog = Dog("Buddy")

dog.breathe()  # From LivingThing
dog.move()     # From Animal
dog.bark()     # From Dog

# Output:
# Buddy is breathing
# Buddy is moving
# Buddy says Woof!
```

### Example: Vehicle Hierarchy

```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand
    
    def start(self):
        print(f"{self.brand} is starting")

class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)
        self.model = model
    
    def drive(self):
        print(f"Driving {self.brand} {self.model}")

class ElectricCar(Car):
    def __init__(self, brand, model, battery_capacity):
        super().__init__(brand, model)
        self.battery_capacity = battery_capacity
    
    def charge(self):
        print(f"Charging {self.battery_capacity}kWh battery")

# ElectricCar has methods from all ancestors
tesla = ElectricCar("Tesla", "Model 3", 75)

tesla.start()   # From Vehicle
tesla.drive()   # From Car
tesla.charge()  # From ElectricCar

# Output:
# Tesla is starting
# Driving Tesla Model 3
# Charging 75kWh battery
```

---

## isinstance() and issubclass()

### isinstance() - Check Object Type

```python
class Animal:
    pass

class Dog(Animal):
    pass

dog = Dog()

# Check if object is instance of a class
print(isinstance(dog, Dog))     # True
print(isinstance(dog, Animal))  # True (Dog is subclass of Animal)
print(isinstance(dog, object))  # True (everything inherits from object)

# Check against specific type
print(isinstance(dog, str))     # False
```

### issubclass() - Check Class Relationship

```python
class Animal:
    pass

class Dog(Animal):
    pass

# Check if class is subclass of another
print(issubclass(Dog, Animal))   # True
print(issubclass(Animal, Dog))   # False
print(issubclass(Dog, object))   # True
print(issubclass(Dog, str))      # False
```

### Practical Use

```python
class Animal:
    def speak(self):
        print("Generic sound")

class Dog(Animal):
    def speak(self):
        print("Woof!")

class Cat(Animal):
    def speak(self):
        print("Meow!")

def make_animal_speak(animal):
    # Check if it's actually an Animal
    if isinstance(animal, Animal):
        animal.speak()
    else:
        print("Not an animal!")

dog = Dog()
cat = Cat()
number = 42

make_animal_speak(dog)     # Woof!
make_animal_speak(cat)     # Meow!
make_animal_speak(number)  # Not an animal!
```

---

## Real-Life Practical Examples

### Example 1: Employee Hierarchy

```python
class Employee:
    def __init__(self, name, employee_id, salary):
        self.name = name
        self.employee_id = employee_id
        self.salary = salary
    
    def get_details(self):
        return f"ID: {self.employee_id}, Name: {self.name}, Salary: ${self.salary}"
    
    def work(self):
        print(f"{self.name} is working")

class Developer(Employee):
    def __init__(self, name, employee_id, salary, programming_languages):
        super().__init__(name, employee_id, salary)
        self.programming_languages = programming_languages
    
    def work(self):  # Override
        print(f"{self.name} is coding in {', '.join(self.programming_languages)}")
    
    def code_review(self):
        print(f"{self.name} is reviewing code")

class Manager(Employee):
    def __init__(self, name, employee_id, salary, team_size):
        super().__init__(name, employee_id, salary)
        self.team_size = team_size
    
    def work(self):  # Override
        print(f"{self.name} is managing a team of {self.team_size}")
    
    def hold_meeting(self):
        print(f"{self.name} is holding a team meeting")

# Create employees
dev = Developer("Alice", "E001", 90000, ["Python", "JavaScript"])
manager = Manager("Bob", "E002", 120000, 10)

# Use inherited methods
print(dev.get_details())
print(manager.get_details())

# Use overridden methods
dev.work()      # Alice is coding in Python, JavaScript
manager.work()  # Bob is managing a team of 10

# Use specific methods
dev.code_review()      # Alice is reviewing code
manager.hold_meeting() # Bob is holding a team meeting
```

### Example 2: Shape Hierarchy

```python
class Shape:
    def __init__(self, color):
        self.color = color
    
    def describe(self):
        print(f"This is a {self.color} shape")

class Rectangle(Shape):
    def __init__(self, color, width, height):
        super().__init__(color)
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    def describe(self):  # Override
        super().describe()
        print(f"Rectangle: {self.width}x{self.height}")

class Circle(Shape):
    def __init__(self, color, radius):
        super().__init__(color)
        self.radius = radius
    
    def area(self):
        return 3.14159 * (self.radius ** 2)
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius
    
    def describe(self):  # Override
        super().describe()
        print(f"Circle: radius {self.radius}")

# Create shapes
rect = Rectangle("blue", 5, 10)
circle = Circle("red", 7)

# Use methods
rect.describe()
print(f"Area: {rect.area()}")
print(f"Perimeter: {rect.perimeter()}")

print()

circle.describe()
print(f"Area: {circle.area():.2f}")
print(f"Perimeter: {circle.perimeter():.2f}")

# Output:
# This is a blue shape
# Rectangle: 5x10
# Area: 50
# Perimeter: 30
#
# This is a red shape
# Circle: radius 7
# Area: 153.94
# Perimeter: 43.98
```

### Example 3: Game Character Hierarchy

```python
class Character:
    def __init__(self, name, health, attack):
        self.name = name
        self.health = health
        self.attack = attack
    
    def take_damage(self, damage):
        self.health = self.health - damage
        print(f"{self.name} took {damage} damage. Health: {self.health}")
        if self.health <= 0:
            print(f"{self.name} has been defeated!")
    
    def attack_target(self, target):
        print(f"{self.name} attacks {target.name}!")
        target.take_damage(self.attack)

class Warrior(Character):
    def __init__(self, name, health, attack, armor):
        super().__init__(name, health, attack)
        self.armor = armor
    
    def take_damage(self, damage):  # Override
        # Armor reduces damage
        reduced_damage = max(0, damage - self.armor)
        print(f"{self.name}'s armor blocks {damage - reduced_damage} damage!")
        super().take_damage(reduced_damage)
    
    def special_attack(self, target):
        print(f"{self.name} uses Power Strike!")
        critical_damage = self.attack * 2
        target.take_damage(critical_damage)

class Mage(Character):
    def __init__(self, name, health, attack, mana):
        super().__init__(name, health, attack)
        self.mana = mana
    
    def cast_spell(self, target):
        if self.mana < 20:
            print(f"{self.name} doesn't have enough mana!")
            return
        
        self.mana = self.mana - 20
        magic_damage = self.attack * 1.5
        print(f"{self.name} casts Fireball! (Mana: {self.mana})")
        target.take_damage(magic_damage)

# Create characters
warrior = Warrior("Conan", 150, 25, 10)
mage = Mage("Gandalf", 100, 30, 100)

# Battle!
print("=== BATTLE START ===\n")

warrior.attack_target(mage)
print()

mage.cast_spell(warrior)
print()

warrior.special_attack(mage)
print()

mage.cast_spell(warrior)

# Output:
# === BATTLE START ===
#
# Conan attacks Gandalf!
# Gandalf took 25 damage. Health: 75
#
# Gandalf casts Fireball! (Mana: 80)
# Conan's armor blocks 10 damage!
# Conan took 35 damage. Health: 115
#
# Conan uses Power Strike!
# Gandalf took 50 damage. Health: 25
#
# Gandalf casts Fireball! (Mana: 60)
# Conan's armor blocks 10 damage!
# Conan took 35 damage. Health: 80
```

### Example 4: Account System

```python
class Account:
    def __init__(self, account_number, owner):
        self.account_number = account_number
        self.owner = owner
        self.balance = 0
        self.transactions = []
    
    def deposit(self, amount):
        self.balance = self.balance + amount
        self.transactions.append(f"Deposit: +${amount}")
        print(f"Deposited ${amount}. Balance: ${self.balance}")
    
    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds!")
            return False
        self.balance = self.balance - amount
        self.transactions.append(f"Withdrawal: -${amount}")
        print(f"Withdrew ${amount}. Balance: ${self.balance}")
        return True
    
    def print_statement(self):
        print(f"\n{'='*40}")
        print(f"Account: {self.account_number}")
        print(f"Owner: {self.owner}")
        print(f"Balance: ${self.balance}")
        print(f"{'='*40}")

class SavingsAccount(Account):
    def __init__(self, account_number, owner, interest_rate):
        super().__init__(account_number, owner)
        self.interest_rate = interest_rate
    
    def add_interest(self):
        interest = self.balance * self.interest_rate
        self.balance = self.balance + interest
        self.transactions.append(f"Interest: +${interest:.2f}")
        print(f"Added interest: ${interest:.2f}. Balance: ${self.balance:.2f}")

class CheckingAccount(Account):
    def __init__(self, account_number, owner):
        super().__init__(account_number, owner)
        self.checks_written = 0
    
    def write_check(self, amount, payee):
        if self.withdraw(amount):  # Use parent's withdraw
            self.checks_written = self.checks_written + 1
            self.transactions[-1] = f"Check #{self.checks_written} to {payee}: -${amount}"
            print(f"Check #{self.checks_written} written to {payee}")

# Use accounts
savings = SavingsAccount("SAV001", "Alice", 0.02)
checking = CheckingAccount("CHK001", "Bob")

savings.deposit(1000)
savings.add_interest()
savings.print_statement()

print()

checking.deposit(500)
checking.write_check(100, "Electric Company")
checking.write_check(50, "Internet Provider")
checking.print_statement()

# Output:
# Deposited $1000. Balance: $1000
# Added interest: $20.00. Balance: $1020.00
# ========================================
# Account: SAV001
# Owner: Alice
# Balance: $1020.0
# ========================================
#
# Deposited $500. Balance: $500
# Withdrew $100. Balance: $400
# Check #1 written to Electric Company
# Withdrew $50. Balance: $350
# Check #2 written to Internet Provider
# ========================================
# Account: CHK001
# Owner: Bob
# Balance: $350
# ========================================
```

---

## Common Mistakes

### Mistake 1: Forgetting super() in __init__

**‚ùå Wrong Way:**
```python
class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, breed):
        # Forgot super().__init__!
        self.breed = breed

dog = Dog("Golden Retriever")
# print(dog.name)  # AttributeError! name was never set
```

**‚úÖ Correct Way:**
```python
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Initialize parent
        self.breed = breed

dog = Dog("Buddy", "Golden Retriever")
print(dog.name)  # Buddy
```

### Mistake 2: Calling Parent Method Incorrectly

**‚ùå Wrong Way:**
```python
class Animal:
    def speak(self):
        print("Some sound")

class Dog(Animal):
    def speak(self):
        Animal.speak()  # Missing self!
        print("Woof!")
```

**‚úÖ Correct Way:**
```python
class Dog(Animal):
    def speak(self):
        super().speak()  # Use super()
        print("Woof!")
```

### Mistake 3: Not Understanding Method Resolution

**‚ùå Wrong Way:**
```python
class Parent:
    def method(self):
        print("Parent method")

class Child(Parent):
    def method(self):
        print("Child method")
        # Forgot super() - parent version never called

child = Child()
child.method()  # Only prints "Child method"
```

**‚úÖ Correct Way (if you want both):**
```python
class Child(Parent):
    def method(self):
        super().method()  # Call parent version
        print("Child method")

child = Child()
child.method()
# Parent method
# Child method
```

---

## Best Practices

### ‚úÖ Do This:

1. **Use super() for Parent Methods**
   ```python
   class Child(Parent):
       def __init__(self, *args):
           super().__init__(*args)
   ```

2. **Override Methods When Behavior Differs**
   ```python
   class Dog(Animal):
       def speak(self):  # Different from Animal
           print("Woof!")
   ```

3. **Use Inheritance for "is-a" Relationships**
   ```python
   # Dog IS-A Animal ‚úì
   class Dog(Animal):
       pass
   
   # Car IS-A Vehicle ‚úì
   class Car(Vehicle):
       pass
   ```

4. **Keep Inheritance Hierarchies Shallow**
   ```python
   # Good: 2-3 levels
   class Animal ‚Üí Dog ‚Üí Puppy
   
   # Avoid: Too many levels
   class A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F
   ```

### ‚ùå Avoid This:

1. **Don't Inherit When You Should Compose**
   ```python
   # Avoid: Engine IS-NOT-A Car
   class Engine(Car):  # Wrong!
       pass
   
   # Better: Car HAS-A Engine
   class Car:
       def __init__(self):
           self.engine = Engine()
   ```

2. **Don't Create Deep Hierarchies**
   ```python
   # Avoid
   class A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F ‚Üí G
   ```

3. **Don't Override Everything**
   ```python
   # If you're overriding all methods,
   # maybe you don't need inheritance?
   ```

---

## Summary

Congratulations! You've mastered the second pillar of OOP! üéâ

**üéØ Key Takeaways:**

**üìå Inheritance**
- Child class inherits from parent class
- `class Child(Parent):`
- Promotes code reuse
- Models "is-a" relationships

**üìå super()**
- Calls parent class methods
- `super().__init__()` in child's `__init__`
- `super().method()` to call parent method

**üìå Method Overriding**
- Child can replace parent's method
- Same method name, different implementation
- Can call parent version with `super()`

**üìå Adding Methods**
- Child can have additional methods
- Not available in parent
- Specializes child class

**üìå Multi-Level Inheritance**
- Grandparent ‚Üí Parent ‚Üí Child
- Child inherits from entire chain
- Keep hierarchies shallow

**üìå Built-in Functions**
- `isinstance(obj, Class)` - check object type
- `issubclass(Child, Parent)` - check class relationship

**üí° Remember:**
- Use inheritance for "is-a" relationships
- Always call `super().__init__()` in child's `__init__`
- Override methods when behavior differs
- Add new methods for specialization
- Keep hierarchies simple

---

## Practice Exercises

### Exercise 1: Vehicle Hierarchy

**Task:** Create `Vehicle` parent class, then `Car` and `Motorcycle` child classes with specific attributes and methods.

---

### Exercise 2: Animal Sounds

**Task:** Create `Animal` parent with `speak()` method. Create 3 children (`Dog`, `Cat`, `Cow`) that override `speak()` with their sounds.

---

### Exercise 3: Employee Types

**Task:** Create `Employee` parent with salary. Create `Manager` and `Developer` children with specific attributes and override `get_salary()` (manager gets bonus).

---

### Exercise 4: Shape Area

**Task:** Create `Shape` parent. Create `Square`, `Circle`, `Triangle` children each with `area()` method implementation.

---

### Exercise 5: Bank Accounts

**Task:** Create `BankAccount` parent. Create `SavingsAccount` (interest) and `CheckingAccount` (overdraft) children.

---

### Exercise 6: Student Types

**Task:** Create `Student` parent. Create `UndergraduateStudent` and `GraduateStudent` children with different fee structures.

---

### Exercise 7: Multi-Level Inheritance

**Task:** Create `LivingThing` ‚Üí `Animal` ‚Üí `Mammal` ‚Üí `Dog` hierarchy. Each level adds attributes/methods.

---

### Exercise 8: Game Characters

**Task:** Create `Character` parent with health/attack. Create `Warrior`, `Mage`, `Archer` with unique special abilities.

---

### Exercise 9: Product Hierarchy

**Task:** Create `Product` parent. Create `Electronics`, `Clothing`, `Food` children with specific attributes (warranty, size, expiry).

---

### Exercise 10: isinstance() Practice

**Task:** Given a class hierarchy, write a function that takes an object and prints information based on its type using `isinstance()`.

---

## What's Next?

You've mastered Inheritance! üéâ

In the next blog, **Chapter 14: Polymorphism**, you'll learn:

- What is polymorphism?
- Method overriding for polymorphism
- Duck typing in Python
- Operator overloading
- Making objects work with built-in functions
- Real-world polymorphic design

**Why this matters:** Polymorphism is the third pillar of OOP! It lets different objects respond to the same method call in their own way, making code flexible and extensible.

**Get ready to:** Write code that works with many different types of objects seamlessly!

---

**Keep practicing!** Try creating real-world class hierarchies. Model things you see around you!

Remember: Inheritance builds class families - code reuse and specialization! üë®‚Äçüë©‚Äçüëß‚Äçüë¶
