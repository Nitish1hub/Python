# Polymorphism - Many Forms of the Same Interface

## Table of Contents
1. [Introduction - One Interface, Many Implementations](#introduction---one-interface-many-implementations)
2. [What is Polymorphism?](#what-is-polymorphism)
3. [Polymorphism Through Inheritance](#polymorphism-through-inheritance)
4. [Duck Typing in Python](#duck-typing-in-python)
5. [Operator Overloading](#operator-overloading)
6. [Special Methods for Built-in Functions](#special-methods-for-built-in-functions)
7. [Method Overloading (Function Overloading)](#method-overloading-function-overloading)
8. [Real-Life Practical Examples](#real-life-practical-examples)
9. [Common Mistakes](#common-mistakes)
10. [Best Practices](#best-practices)
11. [Summary](#summary)
12. [Practice Exercises](#practice-exercises)
13. [What's Next?](#whats-next)

---

## Introduction - One Interface, Many Implementations

Polymorphism lets different objects respond to the same method call in their own way. Same interface, different behavior!

**Real-World Analogy:** Think of a remote control:
- **One button** (interface): "Play"
- **Many devices** respond differently:
  - TV ‚Üí Plays current channel
  - Music player ‚Üí Plays song
  - Game console ‚Üí Plays game
- Same button, different actions based on device!

**In this blog, you'll learn:**
- What polymorphism means
- Polymorphism through method overriding
- Duck typing in Python
- Operator overloading (+, -, *, etc.)
- Making custom classes work with built-ins

---

## What is Polymorphism?

**Define: Polymorphism** - The ability of different objects to respond to the same method call in different ways.

### Simple Example

```python
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

class Cow:
    def speak(self):
        return "Moo!"

# Same method name, different implementations
dog = Dog()
cat = Cat()
cow = Cow()

print(dog.speak())  # Woof!
print(cat.speak())  # Meow!
print(cow.speak())  # Moo!
```

### Polymorphism in Action

```python
def make_animal_speak(animal):
    # Works with ANY object that has speak() method!
    print(animal.speak())

# All these work!
make_animal_speak(Dog())  # Woof!
make_animal_speak(Cat())  # Meow!
make_animal_speak(Cow())  # Moo!
```

### Why Polymorphism?

```python
# Without polymorphism - ugly!
def make_speak(animal):
    if isinstance(animal, Dog):
        print("Woof!")
    elif isinstance(animal, Cat):
        print("Meow!")
    elif isinstance(animal, Cow):
        print("Moo!")
    # Need to add elif for every new animal! üò¢

# With polymorphism - clean!
def make_speak(animal):
    print(animal.speak())
    # Works with any animal! üéâ
```

---

## Polymorphism Through Inheritance

### Method Overriding

```python
class Shape:
    def area(self):
        return 0

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):  # Override!
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):  # Override!
        return 3.14159 * (self.radius ** 2)

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def area(self):  # Override!
        return 0.5 * self.base * self.height

# Polymorphic behavior
shapes = [
    Rectangle(5, 10),
    Circle(7),
    Triangle(6, 8)
]

for shape in shapes:
    print(f"Area: {shape.area()}")

# Output:
# Area: 50
# Area: 153.93804
# Area: 24.0
```

### Example: Payment System

```python
class Payment:
    def process(self, amount):
        raise NotImplementedError("Subclass must implement")

class CreditCard(Payment):
    def __init__(self, card_number):
        self.card_number = card_number
    
    def process(self, amount):
        print(f"Processing ${amount} via Credit Card ending in {self.card_number[-4:]}")

class PayPal(Payment):
    def __init__(self, email):
        self.email = email
    
    def process(self, amount):
        print(f"Processing ${amount} via PayPal account {self.email}")

class Bitcoin(Payment):
    def __init__(self, wallet_address):
        self.wallet_address = wallet_address
    
    def process(self, amount):
        print(f"Processing ${amount} via Bitcoin to {self.wallet_address[:10]}...")

# Polymorphic payment processing
def checkout(payment_method, amount):
    # Works with ANY payment type!
    payment_method.process(amount)

# Different payment methods, same interface
checkout(CreditCard("1234567890123456"), 99.99)
checkout(PayPal("user@email.com"), 49.99)
checkout(Bitcoin("1A2B3C4D5E6F7G8H9I0J"), 149.99)

# Output:
# Processing $99.99 via Credit Card ending in 3456
# Processing $49.99 via PayPal account user@email.com
# Processing $149.99 via Bitcoin to 1A2B3C4D5E...
```

---

## Duck Typing in Python

**Define: Duck typing** - "If it walks like a duck and quacks like a duck, it must be a duck."

**In Python:** If an object has the right methods, it can be used - regardless of its type!

### Duck Typing Example

```python
class Duck:
    def swim(self):
        print("Duck is swimming")
    
    def fly(self):
        print("Duck is flying")

class Airplane:
    def swim(self):
        print("Airplane cannot swim!")
    
    def fly(self):
        print("Airplane is flying")

class Whale:
    def swim(self):
        print("Whale is swimming")
    
    def fly(self):
        print("Whale cannot fly!")

# Function doesn't care about type!
def make_it_fly(thing):
    thing.fly()  # Just needs fly() method

def make_it_swim(thing):
    thing.swim()  # Just needs swim() method

duck = Duck()
plane = Airplane()
whale = Whale()

make_it_fly(duck)    # Duck is flying
make_it_fly(plane)   # Airplane is flying
# make_it_fly(whale)  # Works but says "Whale cannot fly!"

make_it_swim(duck)   # Duck is swimming
make_it_swim(whale)  # Whale is swimming
```

### Example: File-Like Objects

```python
# Any object with write() method can be used like a file!

class MemoryFile:
    def __init__(self):
        self.content = []
    
    def write(self, text):
        self.content.append(text)
    
    def read(self):
        return ''.join(self.content)

class EncryptedFile:
    def __init__(self):
        self.content = []
    
    def write(self, text):
        # "Encrypt" by reversing
        encrypted = text[::-1]
        self.content.append(encrypted)
    
    def read(self):
        # "Decrypt" by reversing back
        decrypted = [text[::-1] for text in self.content]
        return ''.join(decrypted)

def save_data(file_object, data):
    # Works with ANY object that has write()!
    file_object.write(data)

# Both work with same function!
memory_file = MemoryFile()
encrypted_file = EncryptedFile()

save_data(memory_file, "Hello, World!")
save_data(encrypted_file, "Secret Message")

print(memory_file.read())      # Hello, World!
print(encrypted_file.read())   # Secret Message
```

---

## Operator Overloading

**Define: Operator overloading** - Making operators (+, -, *, etc.) work with custom classes.

### Basic Arithmetic Operators

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):  # +
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):  # -
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar):  # *
        return Vector(self.x * scalar, self.y * scalar)
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# Use operators with custom objects!
v1 = Vector(2, 3)
v2 = Vector(4, 5)

v3 = v1 + v2  # Calls __add__
print(v3)  # Vector(6, 8)

v4 = v2 - v1  # Calls __sub__
print(v4)  # Vector(2, 2)

v5 = v1 * 3  # Calls __mul__
print(v5)  # Vector(6, 9)
```

### Comparison Operators

```python
class Money:
    def __init__(self, amount):
        self.amount = amount
    
    def __eq__(self, other):  # ==
        return self.amount == other.amount
    
    def __lt__(self, other):  # <
        return self.amount < other.amount
    
    def __le__(self, other):  # <=
        return self.amount <= other.amount
    
    def __gt__(self, other):  # >
        return self.amount > other.amount
    
    def __ge__(self, other):  # >=
        return self.amount >= other.amount
    
    def __str__(self):
        return f"${self.amount}"

money1 = Money(100)
money2 = Money(150)
money3 = Money(100)

print(money1 == money3)  # True
print(money1 < money2)   # True
print(money2 > money1)   # True
print(money1 <= money3)  # True
```

### Complete Example: Fraction Class

```python
class Fraction:
    def __init__(self, numerator, denominator):
        self.numerator = numerator
        self.denominator = denominator
    
    def __add__(self, other):
        # a/b + c/d = (ad + bc) / bd
        num = self.numerator * other.denominator + other.numerator * self.denominator
        denom = self.denominator * other.denominator
        return Fraction(num, denom)
    
    def __sub__(self, other):
        # a/b - c/d = (ad - bc) / bd
        num = self.numerator * other.denominator - other.numerator * self.denominator
        denom = self.denominator * other.denominator
        return Fraction(num, denom)
    
    def __mul__(self, other):
        # a/b * c/d = ac / bd
        return Fraction(self.numerator * other.numerator,
                       self.denominator * other.denominator)
    
    def __truediv__(self, other):
        # a/b / c/d = ad / bc
        return Fraction(self.numerator * other.denominator,
                       self.denominator * other.numerator)
    
    def __str__(self):
        return f"{self.numerator}/{self.denominator}"

# Use like regular numbers!
f1 = Fraction(1, 2)  # 1/2
f2 = Fraction(1, 3)  # 1/3

print(f"{f1} + {f2} = {f1 + f2}")  # 1/2 + 1/3 = 5/6
print(f"{f1} - {f2} = {f1 - f2}")  # 1/2 - 1/3 = 1/6
print(f"{f1} * {f2} = {f1 * f2}")  # 1/2 * 1/3 = 1/6
print(f"{f1} / {f2} = {f1 / f2}")  # 1/2 / 1/3 = 3/2
```

---

## Special Methods for Built-in Functions

### __len__, __getitem__, __setitem__

```python
class Playlist:
    def __init__(self, name):
        self.name = name
        self.songs = []
    
    def add_song(self, song):
        self.songs.append(song)
    
    def __len__(self):  # Makes len() work
        return len(self.songs)
    
    def __getitem__(self, index):  # Makes [] work for reading
        return self.songs[index]
    
    def __setitem__(self, index, value):  # Makes [] work for writing
        self.songs[index] = value
    
    def __str__(self):
        return f"Playlist '{self.name}' with {len(self)} songs"

playlist = Playlist("Favorites")
playlist.add_song("Song 1")
playlist.add_song("Song 2")
playlist.add_song("Song 3")

# Use len()
print(len(playlist))  # 3

# Use indexing
print(playlist[0])  # Song 1
print(playlist[1])  # Song 2

# Modify with indexing
playlist[0] = "New Song 1"
print(playlist[0])  # New Song 1

# Can iterate
for song in playlist:
    print(song)
```

### __contains__

```python
class ShoppingCart:
    def __init__(self):
        self.items = []
    
    def add(self, item):
        self.items.append(item)
    
    def __contains__(self, item):  # Makes 'in' operator work
        return item in self.items

cart = ShoppingCart()
cart.add("Apple")
cart.add("Banana")
cart.add("Orange")

# Use 'in' operator
print("Apple" in cart)      # True
print("Grape" in cart)      # False
print("Banana" not in cart) # False
```

### __call__

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor
    
    def __call__(self, x):  # Makes object callable like a function
        return x * self.factor

# Create callable object
double = Multiplier(2)
triple = Multiplier(3)

# Call like a function!
print(double(5))  # 10
print(triple(5))  # 15
```

---

## Method Overloading (Function Overloading)

**Note:** Python doesn't support traditional method overloading, but we can simulate it!

### Using Default Arguments

```python
class Calculator:
    def add(self, a, b=0, c=0):
        # Simulates multiple versions of add()
        return a + b + c

calc = Calculator()

print(calc.add(5))        # 5
print(calc.add(5, 3))     # 8
print(calc.add(5, 3, 2))  # 10
```

### Using *args

```python
class Sum:
    def calculate(self, *args):
        # Works with any number of arguments!
        return sum(args)

s = Sum()

print(s.calculate(1))           # 1
print(s.calculate(1, 2))        # 3
print(s.calculate(1, 2, 3))     # 6
print(s.calculate(1, 2, 3, 4))  # 10
```

### Type Checking for Different Behavior

```python
class Processor:
    def process(self, data):
        if isinstance(data, str):
            return data.upper()
        elif isinstance(data, list):
            return sorted(data)
        elif isinstance(data, int):
            return data * 2
        else:
            return None

proc = Processor()

print(proc.process("hello"))        # HELLO
print(proc.process([3, 1, 2]))      # [1, 2, 3]
print(proc.process(5))              # 10
```

---

## Real-Life Practical Examples

### Example 1: Notification System

```python
class Notification:
    def send(self, message):
        raise NotImplementedError

class EmailNotification(Notification):
    def __init__(self, email):
        self.email = email
    
    def send(self, message):
        print(f"üìß Email to {self.email}: {message}")

class SMSNotification(Notification):
    def __init__(self, phone):
        self.phone = phone
    
    def send(self, message):
        print(f"üì± SMS to {self.phone}: {message}")

class PushNotification(Notification):
    def __init__(self, device_id):
        self.device_id = device_id
    
    def send(self, message):
        print(f"üîî Push to device {self.device_id}: {message}")

# Polymorphic notification sending
def notify_user(notification_method, message):
    notification_method.send(message)

# All work with same function!
notify_user(EmailNotification("user@example.com"), "Hello via email!")
notify_user(SMSNotification("555-1234"), "Hello via SMS!")
not Push("device123"), "Hello via push!")

# Output:
# üìß Email to user@example.com: Hello via email!
# üì± SMS to 555-1234: Hello via SMS!
# üîî Push to device device123: Hello via push!
```

### Example 2: Data Export System

```python
class DataExporter:
    def export(self, data):
        raise NotImplementedError

class CSVExporter(DataExporter):
    def export(self, data):
        print("Exporting to CSV:")
        for row in data:
            print(",".join(row))

class JSONExporter(DataExporter):
    def export(self, data):
        print("Exporting to JSON:")
        print("[")
        for i, row in enumerate(data):
            print(f'  {{"item": {i+1}, "data": {row}}}' + ("," if i < len(data)-1 else ""))
        print("]")

class XMLExporter(DataExporter):
    def export(self, data):
        print("Exporting to XML:")
        print("<data>")
        for i, row in enumerate(data):
            print(f"  <item id='{i+1}'>{row}</item>")
        print("</data>")

# Polymorphic export
def save_data(exporter, data):
    exporter.export(data)

data = [
    ["Name", "Age", "City"],
    ["Alice", "25", "NYC"],
    ["Bob", "30", "LA"]
]

save_data(CSVExporter(), data)
print()
save_data(JSONExporter(), data)
print()
save_data(XMLExporter(), data)
```

### Example 3: Shopping Cart with Discounts

```python
class Discount:
    def apply(self, price):
        return price

class PercentageDiscount(Discount):
    def __init__(self, percent):
        self.percent = percent
    
    def apply(self, price):
        return price * (1 - self.percent / 100)

class FixedDiscount(Discount):
    def __init__(self, amount):
        self.amount = amount
    
    def apply(self, price):
        return max(0, price - self.amount)

class BuyOneGetOne(Discount):
    def apply(self, price):
        return price / 2

class ShoppingCart:
    def __init__(self):
        self.items = []
        self.discount = None
    
    def add_item(self, name, price):
        self.items.append({"name": name, "price": price})
    
    def set_discount(self, discount):
        self.discount = discount
    
    def get_total(self):
        subtotal = sum(item["price"] for item in self.items)
        
        if self.discount:
            # Polymorphic discount application!
            final_price = self.discount.apply(subtotal)
        else:
            final_price = subtotal
        
        return subtotal, final_price
    
    def checkout(self):
        subtotal, final = self.get_total()
        
        print("\nüõí Shopping Cart")
        print("=" * 40)
        for item in self.items:
            print(f"{item['name']}: ${item['price']:.2f}")
        print("=" * 40)
        print(f"Subtotal: ${subtotal:.2f}")
        
        if self.discount:
            savings = subtotal - final
            print(f"Discount: -${savings:.2f}")
            print(f"Total: ${final:.2f}")
        else:
            print(f"Total: ${subtotal:.2f}")

# Test different discounts
cart = ShoppingCart()
cart.add_item("Laptop", 1000)
cart.add_item("Mouse", 50)
cart.add_item("Keyboard", 100)

# No discount
cart.checkout()

# 10% discount
cart.set_discount(PercentageDiscount(10))
cart.checkout()

# $50 off
cart.set_discount(FixedDiscount(50))
cart.checkout()

# BOGO
cart.set_discount(BuyOneGetOne())
cart.checkout()
```

### Example 4: Custom Container Class

```python
class CustomList:
    def __init__(self):
        self.items = []
    
    def append(self, item):
        self.items.append(item)
    
    # Make it work with len()
    def __len__(self):
        return len(self.items)
    
    # Make it work with []
    def __getitem__(self, index):
        return self.items[index]
    
    # Make it work with 'in'
    def __contains__(self, item):
        return item in self.items
    
    # Make it work with +
    def __add__(self, other):
        result = CustomList()
        result.items = self.items + other.items
        return result
    
    # Make it work with *
    def __mul__(self, times):
        result = CustomList()
        result.items = self.items * times
        return result
    
    # Make it iterable
    def __iter__(self):
        return iter(self.items)
    
    def __str__(self):
        return f"CustomList({self.items})"

# Use like built-in list!
list1 = CustomList()
list1.append(1)
list1.append(2)
list1.append(3)

list2 = CustomList()
list2.append(4)
list2.append(5)

print(len(list1))  # 3
print(list1[0])    # 1
print(2 in list1)  # True

# Combine lists
list3 = list1 + list2
print(list3)  # CustomList([1, 2, 3, 4, 5])

# Repeat list
list4 = list1 * 2
print(list4)  # CustomList([1, 2, 3, 1, 2, 3])

# Iterate
for item in list1:
    print(item)
```

---

## Common Mistakes

### Mistake 1: Not Implementing Required Methods

**‚ùå Wrong Way:**
```python
class Shape:
    def area(self):
        pass  # Doesn't raise error if not implemented!

class Rectangle(Shape):
    pass  # Forgot to implement area()

rect = Rectangle()
# rect.area()  # Returns None - silent failure!
```

**‚úÖ Correct Way:**
```python
class Shape:
    def area(self):
        raise NotImplementedError("Subclass must implement area()")

class Rectangle(Shape):
    def area(self):  # Must implement!
        return self.width * self.height
```

### Mistake 2: Wrong Operator Method

**‚ùå Wrong Way:**
```python
class Number:
    def __init__(self, value):
        self.value = value
    
    def __plus__(self, other):  # Wrong name!
        return Number(self.value + other.value)

# + won't work!
```

**‚úÖ Correct Way:**
```python
class Number:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):  # Correct name!
        return Number(self.value + other.value)
```

### Mistake 3: Forgetting to Return in Operator Overloading

**‚ùå Wrong Way:**
```python
class Vector:
    def __add__(self, other):
        self.x = self.x + other.x  # Modifies self
        # Forgot to return!

v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2  # v3 is None!
```

**‚úÖ Correct Way:**
```python
class Vector:
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)  # Return new object
```

---

## Best Practices

### ‚úÖ Do This:

1. **Use Common Method Names for Similar Operations**
   ```python
   class EmailSender:
       def send(self, message):
           pass
   
   class SMSSender:
       def send(self, message):  # Same name!
           pass
   ```

2. **Implement __str__ for Readable Output**
   ```python
   class Point:
       def __str__(self):
           return f"Point({self.x}, {self.y})"
   ```

3. **Return New Objects in Operator Overloading**
   ```python
   def __add__(self, other):
       return Vector(...)  # New object
   ```

4. **Use NotImplementedError for Abstract Methods**
   ```python
   def process(self):
       raise NotImplementedError("Subclass must implement")
   ```

### ‚ùå Avoid This:

1. **Don't Modify self in Arithmetic Operators**
   ```python
   # Avoid
   def __add__(self, other):
       self.x = self.x + other.x  # BAD!
       return self
   
   # Better
   def __add__(self, other):
       return Vector(self.x + other.x, self.y + other.y)
   ```

2. **Don't Use Different Method Names for Same Operation**
   ```python
   # Avoid
   class EmailSender:
       def send_email(self, msg):
           pass
   
   class SMSSender:
       def send_sms(self, msg):  # Different name!
           pass
   ```

---

## Summary

Congratulations! You've mastered the third pillar of OOP! üéâ

**üéØ Key Takeaways:**

**üìå Polymorphism**
- Same interface, different implementations
- Different objects respond to same method call
- Makes code flexible and extensible

**üìå Method Overriding**
- Child classes override parent methods
- Same method name, different behavior
- Foundation of polymorphism

**üìå Duck Typing**
- "If it walks like a duck..."
- Python doesn't care about type
- Just needs the right methods

**üìå Operator Overloading**
- `__add__`, `__sub__`, `__mul__`, `__truediv__`
- `__eq__`, `__lt__`, `__gt__`, etc.
- Makes custom objects work with operators

**üìå Special Methods**
- `__len__` - makes len() work
- `__getitem__` - makes [] work
- `__contains__` - makes 'in' work
- `__str__` - readable string representation
- `__call__` - makes object callable

**üí° Remember:**
- Same method name, different behavior
- Use NotImplementedError for abstract methods
- Operator methods return new objects
- Duck typing = flexibility
- Polymorphism = extensibility

---

## Practice Exercises

### Exercise 1: Animal Sounds

**Task:** Create Animal parent and Dog, Cat, Bird children. Write function that makes any animal speak using polymorphism.

---

### Exercise 2: Shape Calculator

**Task:** Create Shape parent with area() method. Create Rectangle, Circle, Triangle children. Calculate total area of list of shapes.

---

### Exercise 3: Money Class

**Task:** Create Money class with operator overloading for +, -, *, ==, <, >.

---

### Exercise 4: Vector Math

**Task:** Create Vector2D class with +, -, *, __str__, __len__ (magnitude).

---

### Exercise 5: Custom Range

**Task:** Create CustomRange class that works with len(), [], 'in', and iteration.

---

### Exercise 6: File Processors

**Task:** Create FileProcessor parent. Create CSVProcessor, JSONProcessor, XMLProcessor children with different process() implementations.

---

### Exercise 7: Temperature Scales

**Task:** Create Temperature parent. Create Celsius, Fahrenheit, Kelvin children. Each converts to_celsius(), to_fahrenheit(), to_kelvin() polymorphically.

---

### Exercise 8: Discount System

**Task:** Create Discount parent with apply() method. Create PercentageDiscount, FixedDiscount, BuyTwoGetOne children.

---

### Exercise 9: Playlist Class

**Task:** Create Playlist with __len__, __getitem__, __setitem__, __contains__, __iter__.

---

### Exercise 10: Point Class

**Task:** Create Point class with +, -, *, ==, __str__, and distance_from_origin() method.

---

## What's Next?

You've mastered Polymorphism! üéâ

In the next blog, **Chapter 15: Abstraction**, you'll learn:

- What is abstraction?
- Abstract Base Classes (ABC)
- Abstract methods (@abstractmethod)
- Interface concept in Python
- When and why to use abstraction
- Real-world abstraction examples

**Why this matters:** Abstraction is the fourth pillar of OOP! It lets you define contracts that classes must follow, ensuring consistency and preventing errors.

**Get ready to:** Create blueprints that enforce implementation rules!

---

**Keep practicing!** Polymorphism is everywhere in professional code. Master it and your code becomes flexible and maintainable!

Remember: One interface, many forms - the power of polymorphism! ü¶Üüêïüêà
