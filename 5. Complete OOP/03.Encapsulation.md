# Encapsulation - Data Hiding and Protection

## Table of Contents
1. [Introduction - Protecting Your Data](#introduction---protecting-your-data)
2. [What is Encapsulation?](#what-is-encapsulation)
3. [Public Attributes](#public-attributes)
4. [Private Attributes](#private-attributes)
5. [Getter Methods](#getter-methods)
6. [Setter Methods](#setter-methods)
7. [The Property Decorator](#the-property-decorator)
8. [Why Encapsulation Matters](#why-encapsulation-matters)
9. [Real-Life Practical Examples](#real-life-practical-examples)
10. [Common Mistakes](#common-mistakes)
11. [Best Practices](#best-practices)
12. [Summary](#summary)
13. [Practice Exercises](#practice-exercises)
14. [What's Next?](#whats-next)

---

## Introduction - Protecting Your Data

You can create classes with attributes, but right now anyone can modify them - even set invalid values! Encapsulation solves this by hiding data and controlling access.

**Real-World Analogy:** Think of an ATM machine:
- **Without encapsulation** = Direct access to bank vault (anyone can take money!)
- **With encapsulation** = ATM controls access (validates card, PIN, balance before dispensing)

**In this blog, you'll learn:**
- Public vs private attributes
- How to hide data
- Getter and setter methods
- Property decorator for clean syntax
- Why protecting data prevents bugs

---

## What is Encapsulation?

**Define: Encapsulation** - Bundling data and methods together, hiding internal details, and controlling access.

### The Problem

```python
class BankAccount:
    def __init__(self, balance):
        self.balance = balance

account = BankAccount(1000)

# Anyone can modify balance directly - dangerous!
account.balance = -5000  # Invalid! Negative balance!
account.balance = "hello"  # Invalid! Not a number!

print(account.balance)  # "hello" - Bank account broken!
```

### The Solution

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private attribute (__)
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance = self.__balance + amount
        else:
            print("Amount must be positive!")
    
    def get_balance(self):
        return self.__balance

account = BankAccount(1000)

# Can't access directly
# print(account.__balance)  # AttributeError!

# Must use methods (controlled access)
account.deposit(500)
print(account.get_balance())  # 1500

# Can't set invalid value
# account.__balance = -5000  # Doesn't affect private attribute!
```

### Three Parts of Encapsulation

1. **Data Hiding** - Make attributes private
2. **Controlled Access** - Provide methods to access data
3. **Validation** - Check data before modifying

---

## Public Attributes

**Define: Public attribute** - Can be accessed and modified from anywhere.

### Public by Default

```python
class Person:
    def __init__(self, name, age):
        self.name = name  # Public
        self.age = age    # Public

person = Person("Alice", 25)

# Can access directly
print(person.name)  # Alice
print(person.age)   # 25

# Can modify directly
person.name = "Bob"
person.age = 30

# Can even set invalid values!
person.age = -100  # No validation!
person.name = ""   # Empty name!
```

### When to Use Public Attributes

```python
# Simple data classes where validation isn't critical
class Point:
    def __init__(self, x, y):
        self.x = x  # Public OK - coordinates can be any number
        self.y = y

# Color class
class Color:
    def __init__(self, r, g, b):
        self.r = r  # Public OK if you trust users
        self.g = g
        self.b = b
```

---

## Private Attributes

**Define: Private attribute** - Can only be accessed within the class (name starts with `__`).

### Creating Private Attributes

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner        # Public
        self.__balance = balance  # Private (double underscore)

account = BankAccount("Alice", 1000)

# Can access public
print(account.owner)  # Alice

# Can't access private
# print(account.__balance)  # AttributeError!
```

### Name Mangling

**Define: Name mangling** - Python renames `__attribute` to `_ClassName__attribute`.

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance

account = BankAccount(1000)

# Direct access doesn't work
# print(account.__balance)  # AttributeError

# But Python actually renamed it!
print(account._BankAccount__balance)  # 1000 (name mangling)

# Don't do this! Defeats the purpose of private attributes
```

### Protected Attributes (Convention)

**Define: Protected attribute** - Single underscore `_` means "don't access directly" (convention).

```python
class Person:
    def __init__(self, name, age):
        self._age = age  # Protected (convention - not enforced!)

person = Person("Alice", 25)

# Can still access (Python doesn't prevent it)
print(person._age)  # 25

# But single underscore signals: "Don't access directly!"
```

---

## Getter Methods

**Define: Getter** - Method that returns the value of a private attribute.

### Basic Getter

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance
    
    def get_balance(self):  # Getter
        return self.__balance

account = BankAccount(1000)

# Access via getter
balance = account.get_balance()
print(balance)  # 1000
```

### Getters with Logic

```python
class Temperature:
    def __init__(self, celsius):
        self.__celsius = celsius
    
    def get_celsius(self):
        return self.__celsius
    
    def get_fahrenheit(self):
        # Convert and return
        return (self.__celsius * 9/5) + 32
    
    def get_kelvin(self):
        return self.__celsius + 273.15

temp = Temperature(25)
print(f"Celsius: {temp.get_celsius()}")      # 25
print(f"Fahrenheit: {temp.get_fahrenheit()}")  # 77.0
print(f"Kelvin: {temp.get_kelvin()}")        # 298.15
```

### Multiple Getters

```python
class Person:
    def __init__(self, first_name, last_name, birth_year):
        self.__first_name = first_name
        self.__last_name = last_name
        self.__birth_year = birth_year
    
    def get_first_name(self):
        return self.__first_name
    
    def get_last_name(self):
        return self.__last_name
    
    def get_full_name(self):
        return f"{self.__first_name} {self.__last_name}"
    
    def get_age(self):
        current_year = 2024
        return current_year - self.__birth_year

person = Person("Alice", "Johnson", 1995)
print(person.get_full_name())  # Alice Johnson
print(person.get_age())        # 29
```

---

## Setter Methods

**Define: Setter** - Method that sets the value of a private attribute (with validation).

### Basic Setter

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance
    
    def get_balance(self):
        return self.__balance
    
    def set_balance(self, balance):  # Setter
        if balance < 0:
            print("Balance cannot be negative!")
            return
        self.__balance = balance

account = BankAccount(1000)

# Set via setter
account.set_balance(2000)
print(account.get_balance())  # 2000

# Validation prevents invalid value
account.set_balance(-500)  # Balance cannot be negative!
print(account.get_balance())  # Still 2000
```

### Setters with Validation

```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age
    
    def get_name(self):
        return self.__name
    
    def set_name(self, name):
        if len(name) == 0:
            print("Name cannot be empty!")
            return
        self.__name = name
    
    def get_age(self):
        return self.__age
    
    def set_age(self, age):
        if age < 0 or age > 150:
            print("Invalid age!")
            return
        self.__age = age

person = Person("Alice", 25)

# Valid changes
person.set_name("Bob")
person.set_age(30)
print(f"{person.get_name()}, {person.get_age()}")  # Bob, 30

# Invalid changes rejected
person.set_name("")     # Name cannot be empty!
person.set_age(-5)      # Invalid age!
person.set_age(200)     # Invalid age!
print(f"{person.get_name()}, {person.get_age()}")  # Still Bob, 30
```

---

## The Property Decorator

**Define: Property** - Makes a method act like an attribute (no parentheses needed).

### Problem with Getters/Setters

```python
class Person:
    def __init__(self, age):
        self.__age = age
    
    def get_age(self):
        return self.__age
    
    def set_age(self, age):
        if age < 0:
            raise ValueError("Age cannot be negative!")
        self.__age = age

person = Person(25)

# Ugly syntax with get/set methods
age = person.get_age()    # Parentheses required
person.set_age(30)        # Not intuitive
```

### Solution: @property Decorator

```python
class Person:
    def __init__(self, age):
        self.__age = age
    
    @property
    def age(self):  # Getter
        return self.__age
    
    @age.setter
    def age(self, age):  # Setter
        if age < 0:
            raise ValueError("Age cannot be negative!")
        self.__age = age

person = Person(25)

# Clean syntax - looks like attribute access!
print(person.age)  # 25 (no parentheses!)
person.age = 30    # Assignment syntax!
print(person.age)  # 30

# Validation still works
# person.age = -5  # ValueError: Age cannot be negative!
```

### Complete Property Example

```python
class Circle:
    def __init__(self, radius):
        self.__radius = radius
    
    @property
    def radius(self):
        """Get radius"""
        return self.__radius
    
    @radius.setter
    def radius(self, radius):
        """Set radius with validation"""
        if radius <= 0:
            raise ValueError("Radius must be positive!")
        self.__radius = radius
    
    @property
    def diameter(self):
        """Calculate diameter"""
        return self.__radius * 2
    
    @property
    def area(self):
        """Calculate area"""
        return 3.14159 * (self.__radius ** 2)

circle = Circle(5)

# Access like attributes
print(circle.radius)    # 5
print(circle.diameter)  # 10
print(circle.area)      # 78.53975

# Modify radius
circle.radius = 10
print(circle.diameter)  # 20
print(circle.area)      # 314.159

# Invalid value rejected
# circle.radius = -5  # ValueError!
```

### Read-Only Properties

```python
class Person:
    def __init__(self, first_name, last_name):
        self.__first_name = first_name
        self.__last_name = last_name
    
    @property
    def full_name(self):
        """Read-only property (no setter)"""
        return f"{self.__first_name} {self.__last_name}"

person = Person("Alice", "Johnson")

print(person.full_name)  # Alice Johnson

# Can't modify (no setter defined)
# person.full_name = "Bob Smith"  # AttributeError!
```

---

## Why Encapsulation Matters

### Benefit 1: Data Validation

```python
class Email:
    def __init__(self, address):
        self.__address = None
        self.address = address  # Uses setter for validation
    
    @property
    def address(self):
        return self.__address
    
    @address.setter
    def address(self, address):
        if "@" not in address:
            raise ValueError("Invalid email: missing @")
        if "." not in address:
            raise ValueError("Invalid email: missing domain")
        self.__address = address

# Validation happens automatically
email = Email("alice@email.com")  # Valid
print(email.address)

# Invalid emails rejected
# email2 = Email("invalid")  # ValueError!
```

### Benefit 2: Preventing Bugs

```python
class Rectangle:
    def __init__(self, width, height):
        self.__width = width
        self.__height = height
    
    @property
    def width(self):
        return self.__width
    
    @width.setter
    def width(self, width):
        if width <= 0:
            raise ValueError("Width must be positive!")
        self.__width = width
    
    @property
    def area(self):
        return self.__width * self.__height

rect = Rectangle(5, 10)
print(rect.area)  # 50

# Prevents invalid state
# rect.width = -5  # ValueError: Width must be positive!
# Area calculation always correct!
```

### Benefit 3: Changing Implementation

```python
class Temperature:
    def __init__(self, celsius):
        self.__celsius = celsius
    
    @property
    def celsius(self):
        return self.__celsius
    
    @property
    def fahrenheit(self):
        # Implementation can change without breaking user code
        return (self.__celsius * 9/5) + 32

temp = Temperature(25)
print(temp.fahrenheit)  # 77.0

# Later, you could store fahrenheit internally instead
# Users wouldn't need to change their code!
```

### Benefit 4: Hiding Complexity

```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance
        self.__transactions = []
    
    @property
    def balance(self):
        return self.__balance
    
    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Amount must be positive!")
        self.__balance = self.__balance + amount
        self.__transactions.append(f"Deposit: +${amount}")
    
    def withdraw(self, amount):
        if amount > self.__balance:
            raise ValueError("Insufficient funds!")
        self.__balance = self.__balance - amount
        self.__transactions.append(f"Withdrawal: -${amount}")

# User doesn't see __transactions list
# They just deposit/withdraw
account = BankAccount(1000)
account.deposit(500)
account.withdraw(200)
print(account.balance)  # 1300
```

---

## Real-Life Practical Examples

### Example 1: User Class with Password

```python
class User:
    def __init__(self, username, password):
        self.__username = username
        self.__password_hash = self.__hash_password(password)
    
    def __hash_password(self, password):
        # Simple hash simulation
        return hash(password)
    
    @property
    def username(self):
        return self.__username
    
    def check_password(self, password):
        return self.__hash_password(password) == self.__password_hash
    
    def change_password(self, old_password, new_password):
        if not self.check_password(old_password):
            raise ValueError("Incorrect current password!")
        if len(new_password) < 8:
            raise ValueError("Password must be at least 8 characters!")
        self.__password_hash = self.__hash_password(new_password)
        print("Password changed successfully!")

# Create user
user = User("alice", "secret123")

# Can access username
print(user.username)  # alice

# Can't access password hash directly
# print(user.__password_hash)  # AttributeError!

# Check password
print(user.check_password("secret123"))  # True
print(user.check_password("wrong"))      # False

# Change password with validation
user.change_password("secret123", "newpassword123")
# Output: Password changed successfully!

# Old password doesn't work
print(user.check_password("secret123"))  # False
print(user.check_password("newpassword123"))  # True
```

### Example 2: Product with Price Control

```python
class Product:
    def __init__(self, name, price, stock):
        self.__name = name
        self.__price = price
        self.__stock = stock
    
    @property
    def name(self):
        return self.__name
    
    @property
    def price(self):
        return self.__price
    
    @price.setter
    def price(self, price):
        if price < 0:
            raise ValueError("Price cannot be negative!")
        self.__price = price
    
    @property
    def stock(self):
        return self.__stock
    
    def restock(self, quantity):
        if quantity <= 0:
            raise ValueError("Quantity must be positive!")
        self.__stock = self.__stock + quantity
        print(f"Restocked {quantity} units. New stock: {self.__stock}")
    
    def sell(self, quantity):
        if quantity > self.__stock:
            raise ValueError(f"Not enough stock! Available: {self.__stock}")
        self.__stock = self.__stock - quantity
        total = self.__price * quantity
        print(f"Sold {quantity} units for ${total:.2f}")
        return total

# Create product
product = Product("Laptop", 999.99, 10)

print(f"{product.name}: ${product.price}, Stock: {product.stock}")
# Output: Laptop: $999.99, Stock: 10

# Sell some
product.sell(3)
# Output: Sold 3 units for $2999.97

# Restock
product.restock(5)
# Output: Restocked 5 units. New stock: 12

# Try to sell too many
# product.sell(20)  # ValueError: Not enough stock!

# Invalid price rejected
# product.price = -100  # ValueError: Price cannot be negative!
```

### Example 3: EmployeeClass with Salary Privacy

```python
class Employee:
    def __init__(self, name, position, salary):
        self.__name = name
        self.__position = position
        self.__salary = salary
        self.__performance_rating = 0
    
    @property
    def name(self):
        return self.__name
    
    @property
    def position(self):
        return self.__position
    
    def get_salary_range(self):
        """Public method - doesn't reveal exact salary"""
        if self.__salary < 50000:
            return "Entry Level"
        elif self.__salary < 100000:
            return "Mid Level"
        else:
            return "Senior Level"
    
    def give_raise(self, percentage):
        """Controlled salary modification"""
        if percentage < 0 or percentage > 50:
            raise ValueError("Raise must be between 0% and 50%!")
        increase = self.__salary * (percentage / 100)
        self.__salary = self.__salary + increase
        print(f"Salary increased by {percentage}%: +${increase:.2f}")
    
    def set_performance_rating(self, rating):
        if rating < 1 or rating > 5:
            raise ValueError("Rating must be 1-5!")
        self.__performance_rating = rating
        print(f"Performance rating set: {rating}/5")
    
    def annual_review(self):
        print(f"\nüìä Annual Review: {self.__name}")
        print(f"Position: {self.__position}")
        print(f"Salary Range: {self.get_salary_range()}")
        print(f"Performance: {self.__performance_rating}/5")

# Create employee
emp = Employee("Alice Johnson", "Software Engineer", 75000)

print(f"Employee: {emp.name}")
print(f"Position: {emp.position}")
print(f"Salary Range: {emp.get_salary_range()}")

# Can't access salary directly
# print(emp.__salary)  # AttributeError!

# Give raise
emp.give_raise(10)
# Output: Salary increased by 10%: +$7500.00

# Set performance rating
emp.set_performance_rating(4)
# Output: Performance rating set: 4/5

# Annual review
emp.annual_review()
# Output:
# üìä Annual Review: Alice Johnson
# Position: Software Engineer
# Salary Range: Mid Level
# Performance: 4/5
```

### Example 4: SmartHome Thermostat

```python
class Thermostat:
    def __init__(self, current_temp):
        self.__current_temp = current_temp
        self.__target_temp = current_temp
        self.__min_temp = 60
        self.__max_temp = 80
        self.__is_on = False
    
    @property
    def current_temp(self):
        return self.__current_temp
    
    @property
    def target_temp(self):
        return self.__target_temp
    
    @target_temp.setter
    def target_temp(self, temp):
        if temp < self.__min_temp or temp > self.__max_temp:
            raise ValueError(f"Temperature must be between {self.__min_temp}¬∞F and {self.__max_temp}¬∞F!")
        self.__target_temp = temp
        print(f"Target temperature set to {temp}¬∞F")
    
    @property
    def is_on(self):
        return self.__is_on
    
    def turn_on(self):
        self.__is_on = True
        print("Thermostat turned ON")
    
    def turn_off(self):
        self.__is_on = False
        print("Thermostat turned OFF")
    
    def adjust_temp(self, change):
        """Simulate temperature change"""
        new_temp = self.__current_temp + change
        self.__current_temp = new_temp
        print(f"Current temperature: {self.__current_temp}¬∞F")
    
    def get_status(self):
        status = "ON" if self.__is_on else "OFF"
        print(f"\nüå°Ô∏è Thermostat Status")
        print(f"Power: {status}")
        print(f"Current: {self.__current_temp}¬∞F")
        print(f"Target: {self.__target_temp}¬∞F")
        
        if self.__is_on:
            if self.__current_temp < self.__target_temp:
                print("Mode: HEATING")
            elif self.__current_temp > self.__target_temp:
                print("Mode: COOLING")
            else:
                print("Mode: IDLE")

# Use thermostat
thermostat = Thermostat(70)

thermostat.turn_on()
thermostat.target_temp = 72
thermostat.get_status()

# Simulate temperature changes
thermostat.adjust_temp(1)
thermostat.adjust_temp(1)
thermostat.get_status()

# Invalid temperature rejected
# thermostat.target_temp = 100  # ValueError!

# Output:
# Thermostat turned ON
# Target temperature set to 72¬∞F
#
# üå°Ô∏è Thermostat Status
# Power: ON
# Current: 70¬∞F
# Target: 72¬∞F
# Mode: HEATING
# Current temperature: 71¬∞F
# Current temperature: 72¬∞F
#
# üå°Ô∏è Thermostat Status
# Power: ON
# Current: 72¬∞F
# Target: 72¬∞F
# Mode: IDLE
```

---

## Common Mistakes

### Mistake 1: Forgetting Double Underscore

**‚ùå Wrong Way:**
```python
class BankAccount:
    def __init__(self, balance):
        self._balance = balance  # Single underscore - not truly private!

account = BankAccount(1000)
account._balance = -5000  # Can still access! Just a convention
```

**‚úÖ Correct Way:**
```python
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Double underscore - name mangling

account = BankAccount(1000)
# account.__balance = -5000  # Doesn't work!
```

### Mistake 2: Making Everything Private

**‚ùå Wrong Way:**
```python
class Point:
    def __init__(self, x, y):
        self.__x = x  # Unnecessarily private
        self.__y = y
    
    def get_x(self):
        return self.__x
    
    def set_x(self, x):
        self.__x = x
    # Too much code for simple data!
```

**‚úÖ Correct Way:**
```python
class Point:
    def __init__(self, x, y):
        self.x = x  # Public OK - simple coordinate
        self.y = y
```

### Mistake 3: Not Validating in Setter

**‚ùå Wrong Way:**
```python
class Person:
    def __init__(self, age):
        self.__age = age
    
    @property
    def age(self):
        return self.__age
    
    @age.setter
    def age(self, age):
        self.__age = age  # No validation!

person = Person(25)
person.age = -100  # Accepted! Bad!
```

**‚úÖ Correct Way:**
```python
class Person:
    def __init__(self, age):
        self.__age = age
    
    @property
    def age(self):
        return self.__age
    
    @age.setter
    def age(self, age):
        if age < 0 or age > 150:
            raise ValueError("Invalid age!")
        self.__age = age
```

---

## Best Practices

### ‚úÖ Do This:

1. **Use Private Attributes for Data That Needs Protection**
   ```python
   class BankAccount:
       def __init__(self, balance):
           self.__balance = balance  # Needs validation
   ```

2. **Use @property for Clean Syntax**
   ```python
   class Circle:
       def __init__(self, radius):
           self.__radius = radius
       
       @property
       def radius(self):
           return self.__radius
       
       @radius.setter
       def radius(self, radius):
           if radius <= 0:
               raise ValueError("Radius must be positive!")
           self.__radius = radius
   ```

3. **Validate in Setters**
   ```python
   @age.setter
   def age(self, age):
       if age < 0:
           raise ValueError("Age cannot be negative!")
       self.__age = age
   ```

4. **Use Read-Only Properties When Appropriate**
   ```python
   @property
   def full_name(self):
       return f"{self.first_name} {self.last_name}"
   # No setter - read-only!
   ```

### ‚ùå Avoid This:

1. **Don't Make Simple Data Private Unnecessarily**
   ```python
   # Avoid
   class Point:
       def __init__(self, x, y):
           self.__x = x  # Overkill for simple coordinates
   
   # Better
   class Point:
       def __init__(self, x, y):
           self.x = x  # Public OK
   ```

2. **Don't Access Name-Mangled Attributes**
   ```python
   # Avoid
   account._BankAccount__balance = 5000  # Defeats encapsulation!
   ```

3. **Don't Use getters/setters Without @property**
   ```python
   # Avoid
   def get_age(self):
       return self.__age
   
   # Better
   @property
   def age(self):
       return self.__age
   ```

---

## Summary

Congratulations! You've mastered the first pillar of OOP! üéâ

**üéØ Key Takeaways:**

**üìå Encapsulation**
- Bundle data and methods
- Hide internal details
- Control access to data

**üìå Public vs Private**
- **Public** (`self.attr`) - accessible anywhere
- **Private** (`self.__attr`) - only within class
- **Protected** (`self._attr`) - convention, not enforced

**üìå Getters and Setters**
- **Getter** - return private attribute
- **Setter** - modify with validation
- Control how data is accessed/modified

**üìå Property Decorator**
- `@property` - makes method look like attribute
- `@attr.setter` - setter with clean syntax
- No parentheses needed!

**üìå Why Encapsulation?**
- Data validation
- Prevent bugs
- Hide complexity
- Change implementation safely

**üí° Remember:**
- Use `__` for private attributes
- Validate in setters
- Use `@property` for clean code
- Don't make everything private
- Encapsulation = controlled access

---

## Practice Exercises

### Exercise 1: Rectangle with Validation

**Task:** Create a `Rectangle` class with private width/height. Use @property with validation (must be positive).

---

### Exercise 2: BankAccount Security

**Task:** Create a `BankAccount` with private balance, deposit/withdraw methods with validation.

---

### Exercise 3: Student with GPA

**Task:** Create a `Student` class where GPA is calculated from private grades list. GPA should be read-only property.

---

### Exercise 4: Temperature Conversion

**Task:** Create a `Temperature` class storing private Celsius. Use properties for fahrenheit and kelvin (read-only).

---

### Exercise 5: Email Validator

**Task:** Create an `Email` class with property that validates email format (must have @ and .).

---

### Exercise 6: Age with Validation

**Task:** Create a `Person` class where age property only accepts 0-150, raises ValueError otherwise.

---

### Exercise 7: Product Inventory

**Task:** Create a `Product` class with private stock. Methods: restock(), sell() with validation.

---

### Exercise 8: Password Security

**Task:** Create a `User` class that stores hashed password (private), provides check_password() method.

---

### Exercise 9: Circle Properties

**Task:** Create a `Circle` with private radius property. Area and circumference as read-only calculated properties.

---

### Exercise 10: Game Character

**Task:** Create a `Character` class with private health (0-100). Properties for health with validation, methods for damage/heal.

---

## What's Next?

You've mastered Encapsulation! üéâ

In the next blog, **Chapter 13: Inheritance**, you'll learn:

- Creating child classes from parent classes
- Inheriting attributes and methods
- Extending and overriding behavior
- The super() function
- Multi-level inheritance
- Real-world inheritance examples

**Why this matters:** Inheritance is the second pillar of OOP! It lets you build on existing classes, promoting code reuse and creating hierarchical relationships.

**Get ready to:** Create class families and build specialized versions of existing classes!

---

**Keep practicing!** Try adding encapsulation to your previous class exercises. Protect your data!

Remember: Good encapsulation = robust, maintainable code! üõ°Ô∏è
