# Classes and Objects - Creating Your Own Data Types

## Table of Contents
1. [Introduction - Building Custom Data Types](#introduction---building-custom-data-types)
2. [Defining Your First Class](#defining-your-first-class)
3. [Creating Objects (Instances)](#creating-objects-instances)
4. [The __init__ Method](#the-__init__-method)
5. [Understanding self](#understanding-self)
6. [Instance Attributes](#instance-attributes)
7. [Methods](#methods)
8. [Instance Methods vs Functions](#instance-methods-vs-functions)
9. [Class Attributes](#class-attributes)
10. [Special Methods](#special-methods)
11. [Inner Classes](#inner-classes)
12. [Real-Life Practical Examples](#real-life-practical-examples)
13. [Common Mistakes](#common-mistakes)
14. [Best Practices](#best-practices)
15. [Summary](#summary)
16. [Practice Exercises](#practice-exercises)
17. [What's Next?](#whats-next)

---

## Introduction - Building Custom Data Types

Python has built-in types (int, str, list, dict), but YOU can create your own types using **classes**! This is incredibly powerful.

**Real-World Analogy:** Think of a class as a cookie cutter:
- **Class** = The cookie cutter shape (blueprint)
- **Object** = Each cookie made with that cutter (instance)
- You have one cutter but can make many cookies!

**In this blog, you'll learn:**
- Creating classes (blueprints)
- Creating objects (instances)
- Understanding `__init__` and `self`
- Adding attributes (data)
- Adding methods (behavior)
- Building real-world classes

---

## Defining Your First Class

**Define: Class** - A blueprint for creating objects.

### Basic Syntax

```python
class ClassName:
    # Class body
    pass

# Create an object
object_name = ClassName()
```

### Example: Empty Class

```python
class Dog:
    pass

# Create a dog object
my_dog = Dog()

print(my_dog)  # <__main__.Dog object at 0x...>
print(type(my_dog))  # <class '__main__.Dog'>
```

### Class Naming Convention

```python
# Use PascalCase (capitalize each word, no underscores)
class Student:
    pass

class BankAccount:
    pass

class ShoppingCart:
    pass

# NOT snake_case
# class bank_account:  ‚Üê Wrong!
```

---

## Creating Objects (Instances)

**Define: Object** - A specific instance created from a class.

**Define: Instance** - Same as object; one occurrence of a class.

### Creating Multiple Objects

```python
class Dog:
    pass

# Create three dog objects
dog1 = Dog()
dog2 = Dog()
dog3 = Dog()

# Each is a separate object!
print(dog1)  # <__main__.Dog object at 0x7f8a1c2b3d90>
print(dog2)  # <__main__.Dog object at 0x7f8a1c2b3e10>
print(dog3)  # <__main__.Dog object at 0x7f8a1c2b3e50>

# Different memory addresses = different objects
print(dog1 == dog2)  # False
```

### Objects are Independent

```python
class Counter:
    def __init__(self):
        self.count = 0
    
    def increment(self):
        self.count = self.count + 1

# Create two counters
counter1 = Counter()
counter2 = Counter()

# Modify counter1
counter1.increment()
counter1.increment()

# counter2 is unaffected
print(counter1.count)  # 2
print(counter2.count)  # 0
```

---

## The __init__ Method

**Define: __init__** - Special method called automatically when creating an object (constructor).

**Define: Constructor** - Method that initializes a new object.

### Basic __init__

```python
class Dog:
    def __init__(self):
        print("A new dog was created!")

# Creating object automatically calls __init__
my_dog = Dog()
# Output: A new dog was created!
```

### __init__ with Parameters

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(f"Created dog: {name}, age {age}")

# Pass arguments when creating object
dog1 = Dog("Buddy", 3)
# Output: Created dog: Buddy, age 3

dog2 = Dog("Max", 5)
# Output: Created dog: Max, age 5

print(dog1.name)  # Buddy
print(dog2.name)  # Max
```

### Default Parameter Values

```python
class Dog:
    def __init__(self, name, age=1):
        self.name = name
        self.age = age

# With age
dog1 = Dog("Buddy", 3)
print(f"{dog1.name} is {dog1.age} years old")  # Buddy is 3 years old

# Without age (uses default)
dog2 = Dog("Max")
print(f"{dog2.name} is {dog2.age} years old")  # Max is 1 years old
```

---

## Understanding self

**Define: self** - A reference to the current object instance.

### Why self?

```python
class Dog:
    def __init__(self, name):
        self.name = name  # self.name = instance attribute
                          # name = parameter

# When you create:
dog1 = Dog("Buddy")
# Python automatically does:
# Dog.__init__(dog1, "Buddy")
# So self = dog1

dog2 = Dog("Max")
# Python automatically does:
# Dog.__init__(dog2, "Max")
# So self = dog2
```

### self is Automatic

```python
class Dog:
    def __init__(self, name):
        self.name = name
    
    def bark(self):
        print(f"{self.name} says Woof!")

dog1 = Dog("Buddy")
dog2 = Dog("Max")

# Call method on dog1
dog1.bark()  # Buddy says Woof!
# Python actually does: Dog.bark(dog1)
# So self = dog1

# Call method on dog2
dog2.bark()  # Max says Woof!
# Python does: Dog.bark(dog2)
# So self = dog2
```

### Forgetting self (Common Mistake!)

```python
class Dog:
    def __init__(self, name):
        # Missing self!
        name = name  # This creates local variable, not attribute!

dog = Dog("Buddy")
# print(dog.name)  # AttributeError: 'Dog' object has no attribute 'name'
```

---

## Instance Attributes

**Define: Instance attribute** - Data that belongs to a specific object.

### Creating Attributes in __init__

```python
class Person:
    def __init__(self, name, age, city):
        # Instance attributes
        self.name = name
        self.age = age
        self.city = city

# Create person
person = Person("Alice", 25, "New York")

# Access attributes
print(person.name)  # Alice
print(person.age)   # 25
print(person.city)  # New York
```

### Modifying Attributes

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Alice", 25)

# Direct modification
print(person.age)  # 25
person.age = 26
print(person.age)  # 26

# Add new attribute (not recommended, but possible)
person.email = "alice@email.com"
print(person.email)  # alice@email.com
```

### Multiple Objects, Different Attributes

```python
class Car:
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year

car1 = Car("Toyota", "Camry", 2020)
car2 = Car("Honda", "Civic", 2019)
car3 = Car("Tesla", "Model 3", 2021)

print(f"{car1.brand} {car1.model}")  # Toyota Camry
print(f"{car2.brand} {car2.model}")  # Honda Civic
print(f"{car3.brand} {car3.model}")  # Tesla Model 3
```

---

## Methods

**Define: Method** - A function defined inside a class that operates on objects.

### Defining Methods

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # Method
    def bark(self):
        print(f"{self.name} says Woof!")
    
    # Method with parameter
    def celebrate_birthday(self):
        self.age = self.age + 1
        print(f"Happy birthday {self.name}! Now {self.age} years old!")
    
    # Method that returns value
    def get_description(self):
        return f"{self.name} is a {self.age}-year-old dog"

# Create dog
dog = Dog("Buddy", 3)

# Call methods
dog.bark()  # Buddy says Woof!
dog.celebrate_birthday()  # Happy birthday Buddy! Now 4 years old!
description = dog.get_description()
print(description)  # Buddy is a 4-year-old dog
```

### Methods with Parameters

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.balance = balance
    
    def deposit(self, amount):
        self.balance = self.balance + amount
        print(f"Deposited ${amount}. New balance: ${self.balance}")
    
    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds!")
            return
        self.balance = self.balance - amount
        print(f"Withdrew ${amount}. New balance: ${self.balance}")

# Create account
account = BankAccount("Alice", 1000)

# Call methods with arguments
account.deposit(500)   # Deposited $500. New balance: $1500
account.withdraw(200)  # Withdrew $200. New balance: $1300
account.withdraw(2000) # Insufficient funds!
```

### Methods Calling Other Methods

```python
class Calculator:
    def __init__(self):
        self.result = 0
    
    def add(self, value):
        self.result = self.result + value
        return self
    
    def subtract(self, value):
        self.result = self.result - value
        return self
    
    def multiply(self, value):
        self.result = self.result * value
        return self
    
    def get_result(self):
        return self.result
    
    def reset(self):
        self.result = 0

calc = Calculator()
calc.add(10)
calc.multiply(5)
calc.subtract(3)
print(calc.get_result())  # 47

# Method chaining (because methods return self)
calc.reset()
result = calc.add(10).multiply(5).subtract(3).get_result()
print(result)  # 47
```

---

## Instance Methods vs Functions

### Regular Function

```python
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")  # Hello, Alice!
```

### Instance Method

```python
class Person:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        print(f"Hello, I'm {self.name}!")

person = Person("Alice")
person.greet()  # Hello, I'm Alice!
# Method has access to object's data via self!
```

### Key Differences

```python
# Function - separate from data
name = "Alice"
def greet(name):
    print(f"Hello, {name}!")
greet(name)

# Method - bundled with data
class Person:
    def __init__(self, name):
        self.name = name
    
    def greet(self):
        # Has access to self.name!
        print(f"Hello, I'm {self.name}!")

person = Person("Alice")
person.greet()  # No need to pass name!
```

---

## Class Attributes

**Define: Class attribute** - Data shared by ALL instances of a class.

### Class vs Instance Attributes

```python
class Dog:
    # Class attribute (shared by all dogs)
    species = "Canis familiaris"
    
    def __init__(self, name, age):
        # Instance attributes (unique to each dog)
        self.name = name
        self.age = age

dog1 = Dog("Buddy", 3)
dog2 = Dog("Max", 5)

# Instance attributes differ
print(dog1.name)  # Buddy
print(dog2.name)  # Max

# Class attribute is same for all
print(dog1.species)  # Canis familiaris
print(dog2.species)  # Canis familiaris
print(Dog.species)   # Canis familiaris (can access via class too!)
```

### Modifying Class Attributes

```python
class Counter:
    # Class attribute - tracks total objects created
    total_count = 0
    
    def __init__(self, name):
        self.name = name
        # Increment class attribute
        Counter.total_count = Counter.total_count + 1

counter1 = Counter("First")
counter2 = Counter("Second")
counter3 = Counter("Third")

print(f"Total counters created: {Counter.total_count}")  # 3
print(f"Via instance: {counter1.total_count}")  # 3
```

### Class Attribute Example

```python
class BankAccount:
    # Class attribute - same interest rate for all accounts
    interest_rate = 0.02
    
    def __init__(self, owner, balance):
        self.owner = owner
        self.balance = balance
    
    def add_interest(self):
        interest = self.balance * BankAccount.interest_rate
        self.balance = self.balance + interest
        print(f"Added ${interest:.2f} interest")

account1 = BankAccount("Alice", 1000)
account2 = BankAccount("Bob", 5000)

# Change interest rate for ALL accounts
BankAccount.interest_rate = 0.03

account1.add_interest()  # Uses 0.03
account2.add_interest()  # Uses 0.03

# Output:
# Added $30.00 interest
# Added $150.00 interest
```

---

## Special Methods

**Define: Special methods** - Methods with double underscores that Python calls automatically.

### __str__ Method

```python
class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    # Called when object is printed
    def __str__(self):
        return f"Dog(name={self.name}, age={self.age})"

dog = Dog("Buddy", 3)

# Without __str__:
# print(dog)  # <__main__.Dog object at 0x...>

# With __str__:
print(dog)  # Dog(name=Buddy, age=3)

# Also used by str()
text = str(dog)
print(text)  # Dog(name=Buddy, age=3)
```

### __repr__ Method

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

point = Point(3, 4)
print(point)  # Point(3, 4)

# Useful in lists
points = [Point(1, 2), Point(3, 4), Point(5, 6)]
print(points)  # [Point(1, 2), Point(3, 4), Point(5, 6)]
```

### __len__ Method

```python
class Playlist:
    def __init__(self, name):
        self.name = name
        self.songs = []
    
    def add_song(self, song):
        self.songs.append(song)
    
    def __len__(self):
        return len(self.songs)

playlist = Playlist("My Favorites")
playlist.add_song("Song 1")
playlist.add_song("Song 2")
playlist.add_song("Song 3")

print(len(playlist))  # 3 (calls __len__)
```

### __eq__ Method (Equality)

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

point1 = Point(3, 4)
point2 = Point(3, 4)
point3 = Point(5, 6)

print(point1 == point2)  # True
print(point1 == point3)  # False
```

---

## Inner Classes

**Define: Inner Class** - A class defined inside another class. Also called **Nested Classes**.

### What is an Inner Class?

An inner class is a class that's defined within another class. It's used when a class is only relevant to its outer class and won't be used elsewhere.

**Real-World Analogy:**
- A **Car** has an **Engine** - the Engine class only makes sense within the context of a Car
- A **University** has **Departments** - Department class is closely tied to University
- A **Computer** has **CPU** - CPU is a component that belongs to Computer

### Why Use Inner Classes?

1. **Logical Grouping:** Group classes that are only used in one place
2. **Encapsulation:** Hide implementation details
3. **Readable Code:** Keep helper classes close to where they're used
4. **Namespace Management:** Avoid naming conflicts

### Creating an Inner Class

**Basic Syntax:**
```python
class OuterClass:
    # Outer class code
    
    class InnerClass:
        # Inner class code
        pass
```

### Simple Example

```python
class Computer:
    def __init__(self, brand):
        self.brand = brand
        self.cpu = self.CPU("Intel i7")  # Create inner class instance
    
    def show_specs(self):
        print(f"Computer: {self.brand}")
        self.cpu.show_info()
    
    # Inner Class
    class CPU:
        def __init__(self, model):
            self.model = model
        
        def show_info(self):
            print(f"CPU: {self.model}")

# Create computer
computer = Computer("Dell")
computer.show_specs()

# Output:
# Computer: Dell
# CPU: Intel i7
```

### Accessing Inner Class from Outside

You can create an inner class instance from outside the outer class:

```python
class University:
    def __init__(self, name):
        self.name = name
    
    class Department:
        def __init__(self, dept_name):
            self.dept_name = dept_name
        
        def show(self):
            print(f"Department: {self.dept_name}")

# Create inner class instance from outside
# Syntax: OuterClass.InnerClass()
cs_dept = University.Department("Computer Science")
cs_dept.show()  # Department: Computer Science

# Or through outer class instance
uni = University("MIT")
engineering = uni.Department("Engineering")
engineering.show()  # Department: Engineering
```

### Practical Example: Car with Engine

```python
class Car:
    def __init__(self, brand, model, engine_type):
        self.brand = brand
        self.model = model
        self.engine = self.Engine(engine_type)  # Inner class
    
    def start(self):
        print(f"{self.brand} {self.model} starting...")
        self.engine.start()
    
    def show_info(self):
        print(f"Car: {self.brand} {self.model}")
        self.engine.show_specs()
    
    # Inner Class: Engine
    class Engine:
        def __init__(self, engine_type):
            self.engine_type = engine_type
            self.running = False
        
        def start(self):
            self.running = True
            print(f"{self.engine_type} engine started!")
        
        def stop(self):
            self.running = False
            print(f"Engine stopped.")
        
        def show_specs(self):
            status = "Running" if self.running else "Stopped"
            print(f"Engine: {self.engine_type} - Status: {status}")

# Create car
my_car = Car("Toyota", "Camry", "V6")
my_car.start()
my_car.show_info()

# Output:
# Toyota Camry starting...
# V6 engine started!
# Car: Toyota Camry
# Engine: V6 - Status: Running
```

### Real-World Example: Bank with Account

```python
class Bank:
    def __init__(self, bank_name):
        self.bank_name = bank_name
        self.accounts = []  # List of accounts
    
    def create_account(self, owner, initial_deposit):
        # Create new account using inner class
        account = self.Account(owner, initial_deposit)
        self.accounts.append(account)
        print(f"Account created for {owner}")
        return account
    
    def show_all_accounts(self):
        print(f"\n{self.bank_name} - All Accounts:")
        for account in self.accounts:
            account.show_info()
    
    # Inner Class: Account
    class Account:
        account_number = 1000  # Class attribute for account numbering
        
        def __init__(self, owner, balance):
            self.owner = owner
            self.balance = balance
            self.account_number = Bank.Account.account_number
            Bank.Account.account_number = Bank.Account.account_number + 1
        
        def deposit(self, amount):
            if amount > 0:
                self.balance = self.balance + amount
                print(f"Deposited ${amount}. New balance: ${self.balance}")
        
        def withdraw(self, amount):
            if amount > 0 and amount <= self.balance:
                self.balance = self.balance - amount
                print(f"Withdrew ${amount}. New balance: ${self.balance}")
            else:
                print("Insufficient funds or invalid amount!")
        
        def show_info(self):
            print(f"Account #{self.account_number}: {self.owner} - Balance: ${self.balance}")

# Use the bank system
my_bank = Bank("Python Bank")

# Create accounts
acc1 = my_bank.create_account("Alice", 1000)
acc2 = my_bank.create_account("Bob", 500)

# Use accounts
acc1.deposit(200)
acc1.withdraw(100)

acc2.deposit(300)

# Show all accounts
my_bank.show_all_accounts()

# Output:
# Account created for Alice
# Account created for Bob
# Deposited $200. New balance: $1200
# Withdrew $100. New balance: $1100
# Deposited $300. New balance: $800
#
# Python Bank - All Accounts:
# Account #1000: Alice - Balance: $1100
# Account #1001: Bob - Balance: $800
```

### Multiple Inner Classes

You can have multiple inner classes:

```python
class Smartphone:
    def __init__(self, brand):
        self.brand = brand
        self.battery = self.Battery(100)
        self.camera = self.Camera("12MP")
    
    def show_specs(self):
        print(f"Phone: {self.brand}")
        self.battery.show()
        self.camera.show()
    
    class Battery:
        def __init__(self, capacity):
            self.capacity = capacity
        
        def show(self):
            print(f"Battery: {self.capacity}%")
    
    class Camera:
        def __init__(self, resolution):
            self.resolution = resolution
        
        def show(self):
            print(f"Camera: {self.resolution}")

phone = Smartphone("iPhone")
phone.show_specs()

# Output:
# Phone: iPhone
# Battery: 100%
# Camera: 12MP
```

### When to Use Inner Classes?

**‚úÖ Use Inner Classes When:**
- The inner class is only used by the outer class
- It logically belongs to the outer class (like Engine belongs to Car)
- You want to hide implementation details
- The inner class represents a component or part of the outer class

**‚ùå Avoid Inner Classes When:**
- The class will be used in multiple places
- It has no logical connection to the outer class
- It makes code harder to understand
- You need to inherit from it (complex with inner classes)

### Inner Classes vs Regular Classes

```python
# Regular separate classes (when both are independent)
class Engine:
    def __init__(self, type):
        self.type = type

class Car:
    def __init__(self, engine):
        self.engine = engine

# Create separately
engine = Engine("V6")
car = Car(engine)

# Inner class (when Engine is only for Car)
class Car:
    def __init__(self, engine_type):
        self.engine = self.Engine(engine_type)
    
    class Engine:
        def __init__(self, type):
            self.type = type

# Engine is hidden inside Car
car = Car("V6")
```

### Key Points About Inner Classes

1. **Namespace:** Inner classes are accessed via `OuterClass.InnerClass`
2. **Encapsulation:** Inner classes can access outer class name but not outer class instance automatically
3. **Logical Grouping:** Keeps related classes together
4. **Not Common:** Inner classes are less common in Python than in Java/C++
5. **Alternative:** Often, separate module files are preferred in Python

**Note:** Inner classes are an advanced feature. For beginners, start with regular classes and use inner classes only when there's a clear logical reason!

---

## Real-Life Practical Examples

### Example 1: Person Class

```python
class Person:
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
    
    def get_full_name(self):
        return f"{self.first_name} {self.last_name}"
    
    def introduce(self):
        print(f"Hi, I'm {self.get_full_name()} and I'm {self.age} years old.")
    
    def celebrate_birthday(self):
        self.age = self.age + 1
        print(f"Happy birthday! Now {self.age} years old!")
    
    def __str__(self):
        return f"Person({self.get_full_name()}, {self.age})"

# Create people
person1 = Person("Alice", "Johnson", 25)
person2 = Person("Bob", "Smith", 30)

person1.introduce()
# Output: Hi, I'm Alice Johnson and I'm 25 years old.

person1.celebrate_birthday()
# Output: Happy birthday! Now 26 years old!

print(person1)
# Output: Person(Alice Johnson, 26)
```

### Example 2: Rectangle Class

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
    def is_square(self):
        return self.width == self.height
    
    def resize(self, new_width, new_height):
        self.width = new_width
        self.height = new_height
        print(f"Resized to {new_width}x{new_height}")
    
    def __str__(self):
        return f"Rectangle({self.width}x{self.height})"

# Create rectangles
rect1 = Rectangle(5, 10)
rect2 = Rectangle(7, 7)

print(rect1)  # Rectangle(5x10)
print(f"Area: {rect1.area()}")  # Area: 50
print(f"Perimeter: {rect1.perimeter()}")  # Perimeter: 30
print(f"Is square: {rect1.is_square()}")  # Is square: False

print(f"\n{rect2}")  # Rectangle(7x7)
print(f"Is square: {rect2.is_square()}")  # Is square: True

rect1.resize(8, 8)
print(f"Is square now: {rect1.is_square()}")  # Is square now: True
```

### Example 3: Book Class

```python
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages
        self.current_page = 0
        self.is_finished = False
    
    def read_pages(self, num_pages):
        self.current_page = self.current_page + num_pages
        if self.current_page >= self.pages:
            self.current_page = self.pages
            self.is_finished = True
            print(f"Finished reading '{self.title}'!")
        else:
            pages_left = self.pages - self.current_page
            print(f"Read {num_pages} pages. {pages_left} pages left.")
    
    def get_progress(self):
        percentage = (self.current_page / self.pages) * 100
        return f"{percentage:.1f}%"
    
    def reset(self):
        self.current_page = 0
        self.is_finished = False
        print("Book reset to beginning")
    
    def __str__(self):
        status = "Finished" if self.is_finished else f"Page {self.current_page}/{self.pages}"
        return f"'{self.title}' by {self.author} - {status}"

# Create and read book
book = Book("Python Programming", "John Doe", 300)

print(book)
# Output: 'Python Programming' by John Doe - Page 0/300

book.read_pages(50)
# Output: Read 50 pages. 250 pages left.
print(f"Progress: {book.get_progress()}")
# Output: Progress: 16.7%

book.read_pages(250)
# Output: Finished reading 'Python Programming'!

print(book)
# Output: 'Python Programming' by John Doe - Finished
```

### Example 4: TodoList Class

```python
class TodoList:
    def __init__(self, name):
        self.name = name
        self.tasks = []
    
    def add_task(self, task):
        self.tasks.append({"task": task, "done": False})
        print(f"Added: {task}")
    
    def mark_done(self, index):
        if 0 <= index < len(self.tasks):
            self.tasks[index]["done"] = True
            print(f"Completed: {self.tasks[index]['task']}")
        else:
            print("Invalid task number!")
    
    def show_tasks(self):
        if not self.tasks:
            print("No tasks!")
            return
        
        print(f"\nüìù {self.name}:")
        for i, task in enumerate(self.tasks):
            status = "‚úì" if task["done"] else " "
            print(f"{i+1}. [{status}] {task['task']}")
    
    def get_pending_count(self):
        count = 0
        for task in self.tasks:
            if not task["done"]:
                count = count + 1
        return count
    
    def clear_completed(self):
        self.tasks = [task for task in self.tasks if not task["done"]]
        print("Cleared completed tasks")

# Use the todo list
todo = TodoList("My Tasks")

todo.add_task("Learn Python OOP")
todo.add_task("Build a project")
todo.add_task("Practice coding")

todo.show_tasks()
# Output:
# üìù My Tasks:
# 1. [ ] Learn Python OOP
# 2. [ ] Build a project
# 3. [ ] Practice coding

todo.mark_done(0)
# Output: Completed: Learn Python OOP

todo.show_tasks()
# Output:
# üìù My Tasks:
# 1. [‚úì] Learn Python OOP
# 2. [ ] Build a project
# 3. [ ] Practice coding

print(f"Pending: {todo.get_pending_count()}")
# Output: Pending: 2
```

### Example 5: Student Class with Grades

```python
class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.grades = []
    
    def add_grade(self, subject, grade):
        if grade < 0 or grade > 100:
            print("Invalid grade! Must be 0-100")
            return
        self.grades.append({"subject": subject, "grade": grade})
        print(f"Added {subject}: {grade}")
    
    def get_average(self):
        if not self.grades:
            return 0
        total = sum(g["grade"] for g in self.grades)
        return total / len(self.grades)
    
    def get_letter_grade(self):
        avg = self.get_average()
        if avg >= 90:
            return "A"
        elif avg >= 80:
            return "B"
        elif avg >= 70:
            return "C"
        elif avg >= 60:
            return "D"
        else:
            return "F"
    
    def print_report(self):
        print(f"\nüìä Report for {self.name} (ID: {self.student_id})")
        print("-" * 40)
        for grade in self.grades:
            print(f"{grade['subject']}: {grade['grade']}")
        print("-" * 40)
        print(f"Average: {self.get_average():.1f}")
        print(f"Letter Grade: {self.get_letter_grade()}")
    
    def __str__(self):
        return f"Student({self.name}, ID: {self.student_id})"

# Create student
student = Student("Alice Johnson", "S12345")

student.add_grade("Math", 95)
student.add_grade("English", 88)
student.add_grade("Science", 92)
student.add_grade("History", 85)

student.print_report()

# Output:
# Added Math: 95
# Added English: 88
# Added Science: 92
# Added History: 85
#
# üìä Report for Alice Johnson (ID: S12345)
# ----------------------------------------
# Math: 95
# English: 88
# Science: 92
# History: 85
# ----------------------------------------
# Average: 90.0
# Letter Grade: A
```

---

## Common Mistakes

### Mistake 1: Forgetting self

**‚ùå Wrong Way:**
```python
class Dog:
    def __init__(name, age):  # Missing self!
        self.name = name
        self.age = age

# dog = Dog("Buddy", 3)  # TypeError!
```

**‚úÖ Correct Way:**
```python
class Dog:
    def __init__(self, name, age):  # Include self!
        self.name = name
        self.age = age

dog = Dog("Buddy", 3)  # Works!
```

### Mistake 2: Not Using self for Attributes

**‚ùå Wrong Way:**
```python
class Dog:
    def __init__(self, name):
        name = name  # Creates local variable!
    
    def bark(self):
        # print(name)  # NameError: name not defined
        pass

dog = Dog("Buddy")
# print(dog.name)  # AttributeError!
```

**‚úÖ Correct Way:**
```python
class Dog:
    def __init__(self, name):
        self.name = name  # Creates instance attribute
    
    def bark(self):
        print(f"{self.name} barks!")  # Can access via self

dog = Dog("Buddy")
print(dog.name)  # Buddy
```

### Mistake 3: Calling Methods Without self

**‚ùå Wrong Way:**
```python
class Dog:
    def __init__(self, name):
        self.name = name
    
    def bark():  # Missing self!
        print("Woof!")

dog = Dog("Buddy")
# dog.bark()  # TypeError: takes 0 arguments but 1 was given
```

**‚úÖ Correct Way:**
```python
class Dog:
    def __init__(self, name):
        self.name = name
    
    def bark(self):  # Include self!
        print("Woof!")

dog = Dog("Buddy")
dog.bark()  # Works!
```

### Mistake 4: Confusing Class and Instance Attributes

**‚ùå Wrong Way:**
```python
class Dog:
    name = "Unknown"  # Class attribute!
    
    def __init__(self, name):
        name = name  # Not setting instance attribute!

dog1 = Dog("Buddy")
dog2 = Dog("Max")

print(dog1.name)  # Unknown (uses class attribute)
print(dog2.name)  # Unknown
```

**‚úÖ Correct Way:**
```python
class Dog:
    def __init__(self, name):
        self.name = name  # Instance attribute

dog1 = Dog("Buddy")
dog2 = Dog("Max")

print(dog1.name)  # Buddy
print(dog2.name)  # Max
```

---

## Best Practices

### ‚úÖ Do This:

1. **Use Descriptive Class Names (PascalCase)**
   ```python
   # Good
   class BankAccount:
       pass
   
   class ShoppingCart:
       pass
   ```

2. **Initialize All Attributes in __init__**
   ```python
   class Person:
       def __init__(self, name, age):
           self.name = name
           self.age = age
           self.email = None  # Initialize even if None
   ```

3. **Use __str__ for Readable Output**
   ```python
   class Dog:
       def __init__(self, name, age):
           self.name = name
           self.age = age
       
       def __str__(self):
           return f"Dog(name={self.name}, age={self.age})"
   
   dog = Dog("Buddy", 3)
   print(dog)  # Dog(name=Buddy, age=3)
   ```

4. **Group Related Data and Methods**
   ```python
   class BankAccount:
       def __init__(self, balance):
           self.balance = balance
       
       # Related methods together
       def deposit(self, amount):
           pass
       
       def withdraw(self, amount):
           pass
       
       def get_balance(self):
           pass
   ```

5. **Use Methods to Access/Modify Data**
   ```python
   class BankAccount:
       def __init__(self, balance):
           self.balance = balance
       
       def deposit(self, amount):
           if amount > 0:
               self.balance = self.balance + amount
       
       def get_balance(self):
           return self.balance
   ```

### ‚ùå Avoid This:

1. **Don't Forget self**
   ```python
   # Avoid
   class Dog:
       def bark():  # Missing self!
           pass
   ```

2. **Don't Use Mutable Default Arguments**
   ```python
   # Avoid
   class TodoList:
       def __init__(self, tasks=[]):  # BAD! Shared between instances
           self.tasks = tasks
   
   # Better
   class TodoList:
       def __init__(self, tasks=None):
           self.tasks = tasks if tasks is not None else []
   ```

3. **Don't Put Too Much Logic in __init__**
   ```python
   # Avoid
   class FileProcessor:
       def __init__(self, filename):
           self.filename = filename
           # Too much in __init__!
           self.file = open(filename)
           self.data = self.file.read()
           self.process_data()
   
   # Better
   class FileProcessor:
       def __init__(self, filename):
           self.filename = filename
       
       def load(self):
           # Separate method
           pass
   ```

---

## Summary

Congratulations! You can now create your own data types! üéâ

**üéØ Key Takeaways:**

**üìå Classes and Objects**
- **Class** = Blueprint (cookie cutter)
- **Object** = Instance (cookie)
- `ClassName()` creates object

**üìå The __init__ Method**
- Constructor method
- Called automatically when creating object
- Initializes object attributes
- Takes `self` as first parameter

**üìå Understanding self**
- Reference to current object
- First parameter of all instance methods
- Use `self.attribute` for instance data
- Use `self.method()` to call other methods

**üìå Attributes**
- **Instance attributes** - unique to each object (`self.name`)
- **Class attributes** - shared by all objects (`ClassName.attr`)
- Initialize in `__init__`

**üìå Methods**
- Functions inside a class
- Always include `self` as first parameter
- Can access object data via `self`
- Can call other methods via `self`

**üìå Special Methods**
- `__init__` - initialization
- `__str__` - string representation
- `__repr__` - developer representation
- `__len__` - length
- `__eq__` - equality

**üí° Remember:**
- Class names use PascalCase
- Always include `self` in methods
- Initialize attributes in `__init__`
- Use `__str__` for readable output
- Objects are independent
- Methods operate on object data

---

## Practice Exercises

### Exercise 1: Circle Class

**Task:** Create a `Circle` class with radius attribute and methods: `area()`, `circumference()`, `diameter()`.

---

### Exercise 2: Car Class

**Task:** Create a `Car` class with brand, model, year attributes and methods: `start()`, `stop()`, `honk()`, `get_age()`.

---

### Exercise 3: Temperature Class

**Task:** Create a `Temperature` class that stores Celsius and has methods: `to_fahrenheit()`, `to_kelvin()`, `is_freezing()`.

---

### Exercise 4: Counter Class

**Task:** Create a `Counter` class that starts at 0 with methods: `increment()`, `decrement()`, `reset()`, `get_value()`.

---

### Exercise 5: Product Class

**Task:** Create a `Product` class with name, price, quantity attributes and methods: `restock(amount)`, `sell(amount)`, `get_total_value()`.

---

### Exercise 6: Library Book

**Task:** Create a `LibraryBook` class with title, author, ISBN, is_checked_out attributes and methods: `checkout()`, `return_book()`, `get_info()`.

---

### Exercise 7: Timer Class

**Task:** Create a `Timer` class with seconds attribute and methods: `start()`, `stop()`, `reset()`, `add_time(seconds)`, `get_formatted_time()` (MM:SS format).

---

### Exercise 8: Multiple Objects

**Task:** Create a `Student` class and create 3 different student objects with different names, ages, and grades. Print each student's info.

---

### Exercise 9: Password Validator

**Task:** Create a `Password` class that validates password strength (length, has number, has uppercase) with methods: `is_strong()`, `get_strength_score()`.

---

### Exercise 10: Shopping Item

**Task:** Create a `ShoppingItem` class with name, price, quantity. Add methods: `get_total()`, `apply_discount(percentage)`, `__str__()` for formatted output.

---

## What's Next?

You've mastered classes and objects! üéâ

In the next blog, **Chapter 12: Encapsulation**, you'll learn:

- What is encapsulation?
- Public vs private attributes
- Getter and setter methods
- Property decorator
- Protecting data from invalid changes
- Real-world encapsulation examples

**Why this matters:** Encapsulation is the first pillar of OOP! It lets you control how data is accessed and modified, preventing bugs and maintaining data integrity.

**Get ready to:** Build classes that protect their own data and provide controlled interfaces!

---

**Keep practicing!** Try creating classes for real-world objects around you. The more you practice, the more natural it becomes!

Remember: Classes let you create your own data types - you're no longer limited to int, str, list! üöÄ
