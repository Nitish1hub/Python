# Python Automation - Stop Doing Repetitive Tasks Manually!

## Table of Contents
1. [Introduction - Let Python Do the Boring Work](#introduction---let-python-do-the-boring-work)
2. [Why Automate with Python?](#why-automate-with-python)
3. [Working with Files and Folders - os Module](#working-with-files-and-folders---os-module)
4. [Copying and Moving Files - shutil Module](#copying-and-moving-files---shutil-module)
5. [Modern Path Handling - pathlib Module](#modern-path-handling---pathlib-module)
6. [Finding Files with Patterns - glob Module](#finding-files-with-patterns---glob-module)
7. [Real-Life Automated Projects](#real-life-automation-projects)
8. [Common Mistakes](#common-mistakes)
9. [Best Practices](#best-practices)
10. [Summary](#summary)
11. [Practice Exercises](#practice-exercises)
12. [What's Next?](#whats-next)

---

## Introduction - Let Python Do the Boring Work

Automation means writing code once to do tasks automatically - saving hours of manual work!

**Real-World Analogy:** Think of a dishwasher:
- **Manual:** Wash each dish by hand (boring, repetitive, time-consuming)
- **Automated:** Load dishwasher, press button, done! (fast, consistent, effortless)

**Common Tasks to Automate:**
- Rename 1000 files instantly
- Organize messy folders by file type
- Delete old files automatically
- Backup important documents
- Generate reports from data
- Process images in bulk

**In this blog, you'll learn:**
- File and folder operations (os module)
- Copying and moving files (shutil module)
- Modern path handling (pathlib)
- Pattern matching (glob)
- Building real automation projects

---

## Why Automate with Python?

### Manual vs Automated

**üìã Manual File Organization:**
1. Open folder
2. Look at each file
3. Decide where it goes
4. Create new folder
5. Move file
6. Repeat 1000 times... üò©

**ü§ñ Automated with Python:**
```python
import os
import shutil

for file in os.listdir():
    if file.endswith('.jpg'):
        shutil.move(file, 'Photos/')
# Done in seconds! ‚ú®
```

### Benefits of Automation

**‚úÖ Time Savings**
- 10 hours of work ‚Üí 10 seconds

**‚úÖ Consistency**
- No human errors or missed files

**‚úÖ Repeatability**
- Run same script anytime

**‚úÖ Scalability**
- Works with 10 or 10,000 files

---

## Working with Files and Folders - os Module

The `os` module provides functions to interact with the operating system.

### Listing Files and Folders

```python
import os

# List everything in current folder
files = os.listdir()
print("All files:", files)

# List files in specific folder
files = os.listdir('C:\\Users\\YourName\\Documents')
print("Documents:", files)

# Get current working directory
current_dir = os.getcwd()
print("Current directory:", current_dir)
```

### Checking if File/Folder Exists

```python
import os

# Check if file exists
if os.path.exists('myfile.txt'):
    print("File exists!")
else:
    print("File not found")

# Check if it's a file
if os.path.isfile('myfile.txt'):
    print("It's a file")

# Check if it's a folder
if os.path.isdir('MyFolder'):
    print("It's a folder")
```

### Creating and Deleting Folders

```python
import os

# Create single folder
os.mkdir('NewFolder')

# Create nested folders
os.makedirs('Parent/Child/GrandChild')

# Delete empty folder
os.rmdir('NewFolder')

# Delete folder with contents (careful!)
import shutil
shutil.rmtree('Parent')
```

### Renaming Files and Folders

```python
import os

# Rename file
os.rename('oldname.txt', 'newname.txt')

# Rename folder
os.rename('OldFolder', 'NewFolder')

# Move file to different location
os.rename('file.txt', 'Folder/file.txt')
```

### Deleting Files

```python
import os

# Delete single file
os.remove('unwanted.txt')

# Delete multiple files
files_to_delete = ['temp1.txt', 'temp2.txt', 'temp3.txt']
for file in files_to_delete:
    if os.path.exists(file):
        os.remove(file)
        print(f"Deleted {file}")
```

### Walking Through Directory Tree

```python
import os

# Walk through all subdirectories
for root, dirs, files in os.walk('.'):
    print(f"\nIn folder: {root}")
    print(f"Subdirectories: {dirs}")
    print(f"Files: {files}")

# Example: Find all .py files
for root, dirs, files in os.walk('.'):
    for file in files:
        if file.endswith('.py'):
            full_path = os.path.join(root, file)
            print(full_path)
```

### Getting File Information

```python
import os
import time

file = 'myfile.txt'

# File size in bytes
size = os.path.getsize(file)
print(f"Size: {size} bytes")

# Last modified time
mod_time = os.path.getmtime(file)
readable_time = time.ctime(mod_time)
print(f"Last modified: {readable_time}")

# Split path into parts
path = 'C:\\Users\\Name\\Documents\\file.txt'
directory = os.path.dirname(path)  # C:\Users\Name\Documents
filename = os.path.basename(path)  # file.txt
print(f"Directory: {directory}")
print(f"Filename: {filename}")

# Split filename and extension
name, ext = os.path.splitext(filename)
print(f"Name: {name}")  # file
print(f"Extension: {ext}")  # .txt
```

---

## Copying and Moving Files - shutil Module

The `shutil` module provides high-level file operations.

### Copying Files

```python
import shutil

# Copy file (destination can be file or folder)
shutil.copy('source.txt', 'destination.txt')

# Copy file (preserves metadata like timestamps)
shutil.copy2('source.txt', 'destination.txt')

# Copy to folder (keeps same name)
shutil.copy('file.txt', 'BackupFolder/')
```

### Copying Folders

```python
import shutil

# Copy entire folder and contents
shutil.copytree('SourceFolder', 'DestinationFolder')

# Copy with ignore patterns
shutil.copytree('Source', 'Destination', 
                ignore=shutil.ignore_patterns('*.tmp', '.git'))
```

### Moving Files and Folders

```python
import shutil

# Move file
shutil.move('source.txt', 'destination.txt')

# Move to folder
shutil.move('file.txt', 'TargetFolder/')

# Move folder
shutil.move('OldLocation', 'NewLocation')
```

### Deleting Folders

```python
import shutil

# Delete folder and all contents (careful!)
shutil.rmtree('FolderToDelete')
```

### Disk Usage

```python
import shutil

# Get disk usage
usage = shutil.disk_usage('.')
print(f"Total: {usage.total / (1024**3):.2f} GB")
print(f"Used: {usage.used / (1024**3):.2f} GB")
print(f"Free: {usage.free / (1024**3):.2f} GB")
```

---

## Modern Path Handling - pathlib Module

The `pathlib` module provides object-oriented path handling (recommended for new code).

### Creating Paths

```python
from pathlib import Path

# Current directory
current = Path('.')
print(current.absolute())

# Create path
path = Path('Folder/Subfolder/file.txt')

# Home directory
home = Path.home()
print(home)  # C:\Users\YourName

# Join paths
docs = Path.home() / 'Documents' / 'file.txt'
print(docs)
```

### Path Properties

```python
from pathlib import Path

path = Path('C:/Users/Name/Documents/report.pdf')

print(path.name)        # report.pdf
print(path.stem)        # report
print(path.suffix)      # .pdf
print(path.parent)      # C:\Users\Name\Documents
print(path.exists())    # True/False
print(path.is_file())   # True/False
print(path.is_dir())    # True/False
```

### Listing Files

```python
from pathlib import Path

# List all files in directory
path = Path('.')

# All items
for item in path.iterdir():
    print(item)

# Only files
for file in path.iterdir():
    if file.is_file():
        print(file.name)

# Pattern matching
for py_file in path.glob('*.py'):
    print(py_file)

# Recursive search
for py_file in path.rglob('*.py'):  # r = recursive
    print(py_file)
```

### Creating and Deleting

```python
from pathlib import Path

path = Path('NewFolder')

# Create directory
path.mkdir()

# Create nested directories
path = Path('Parent/Child/GrandChild')
path.mkdir(parents=True, exist_ok=True)

# Delete file
file = Path('temp.txt')
file.unlink()

# Delete empty directory
folder = Path('EmptyFolder')
folder.rmdir()
```

### Reading and Writing

```python
from pathlib import Path

path = Path('myfile.txt')

# Write to file
path.write_text('Hello, World!')

# Read from file
content = path.read_text()
print(content)

# Append to file (need to use open)
with path.open('a') as f:
    f.write('\nNew line')
```

---

## Finding Files with Patterns - glob Module

The `glob` module finds files matching patterns.

### Basic Pattern Matching

```python
import glob

# Find all .txt files
txt_files = glob.glob('*.txt')
print("Text files:", txt_files)

# Find all .py files
py_files = glob.glob('*.py')
print("Python files:", py_files)

# Find files starting with 'test'
test_files = glob.glob('test*')
print("Test files:", test_files)
```

### Recursive Search

```python
import glob

# Find all .jpg files in current and subdirectories
jpg_files = glob.glob('**/*.jpg', recursive=True)

for img in jpg_files:
    print(img)
```

### Multiple Patterns

```python
import glob

# Find images (jpg, png, gif)
images = glob.glob('*.jpg') + glob.glob('*.png') + glob.glob('*.gif')

# Or using pathlib
from pathlib import Path

path = Path('.')
images = list(path.glob('*.jpg')) + list(path.glob('*.png'))
```

---

## Real-Life Automation Projects

### Project 1: File Organizer by Type

```python
import os
import shutil
from pathlib import Path

def organize_files(directory='.'):
    """Organize files by type into folders"""
    
    # Define file types
    file_types = {
        'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp'],
        'Documents': ['.pdf', '.doc', '.docx', '.txt', '.xlsx'],
        'Videos': ['.mp4', '.avi', '.mov', '.mkv'],
        'Audio': ['.mp3', '.wav', '.flac'],
        'Archives': ['.zip', '.rar', '.7z', '.tar'],
        'Code': ['.py', '.java', '.cpp', '.js', '.html', '.css']
    }
    
    path = Path(directory)
    
    # Create folders if they don't exist
    for folder in file_types.keys():
        folder_path = path / folder
        folder_path.mkdir(exist_ok=True)
    
    # Organize files
    moved_count = 0
    for file in path.iterdir():
        if file.is_file():
            # Get file extension
            ext = file.suffix.lower()
            
            # Find matching category
            for folder, extensions in file_types.items():
                if ext in extensions:
                    # Move file
                    dest = path / folder / file.name
                    try:
                        shutil.move(str(file), str(dest))
                        print(f"‚úÖ Moved {file.name} ‚Üí {folder}/")
                        moved_count += 1
                    except Exception as e:
                        print(f"‚ùå Error moving {file.name}: {e}")
                    break
    
    print(f"\nüéâ Organized {moved_count} files!")

# Run it!
# organize_files('C:\\Users\\YourName\\Downloads')
```

### Project 2: Bulk File Renamer

```python
import os
from pathlib import Path

def bulk_rename(directory, old_pattern, new_pattern):
    """Rename multiple files at once"""
    
    path = Path(directory)
    renamed_count = 0
    
    for file in path.iterdir():
        if file.is_file() and old_pattern in file.name:
            # Create new name
            new_name = file.name.replace(old_pattern, new_pattern)
            new_path = file.parent / new_name
            
            try:
                file.rename(new_path)
                print(f"‚úÖ Renamed: {file.name} ‚Üí {new_name}")
                renamed_count += 1
            except Exception as e:
                print(f"‚ùå Error: {e}")
    
    print(f"\nüéâ Renamed {renamed_count} files!")

def add_prefix(directory, prefix):
    """Add prefix to all files"""
    
    path = Path(directory)
    
    for file in path.iterdir():
        if file.is_file():
            new_name = prefix + file.name
            new_path = file.parent / new_name
            try:
                file.rename(new_path)
                print(f"‚úÖ {file.name} ‚Üí {new_name}")
            except Exception as e:
                print(f"‚ùå Error: {e}")

def sequential_numbering(directory, base_name):
    """Rename files with sequential numbers"""
    
    path = Path(directory)
    files = sorted([f for f in path.iterdir() if f.is_file()])
    
    for i, file in enumerate(files, start=1):
        ext = file.suffix
        new_name = f"{base_name}_{i:03d}{ext}"
        new_path = file.parent / new_name
        
        try:
            file.rename(new_path)
            print(f"‚úÖ {file.name} ‚Üí {new_name}")
        except Exception as e:
            print(f"‚ùå Error: {e}")

# Examples:
# bulk_rename('.', 'IMG', 'Photo')  # IMG_001.jpg ‚Üí Photo_001.jpg
# add_prefix('.', '2024_')  # file.txt ‚Üí 2024_file.txt
# sequential_numbering('.', 'vacation')  # vacation_001.jpg, vacation_002.jpg...
```

### Project 3: Duplicate File Finder

```python
import os
import hashlib
from pathlib import Path
from collections import defaultdict

def get_file_hash(filepath):
    """Calculate MD5 hash of file"""
    hash_md5 = hashlib.md5()
    
    try:
        with open(filepath, 'rb') as f:
            # Read in chunks for large files
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    except:
        return None

def find_duplicates(directory):
    """Find duplicate files based on content"""
    
    path = Path(directory)
    hashes = defaultdict(list)
    
    print("üîç Scanning files...")
    
    # Calculate hash for each file
    for file in path.rglob('*'):
        if file.is_file():
            file_hash = get_file_hash(file)
            if file_hash:
                hashes[file_hash].append(file)
    
    # Find duplicates
    duplicates = {hash: files for hash, files in hashes.items() if len(files) > 1}
    
    if not duplicates:
        print("‚úÖ No duplicates found!")
        return
    
    print(f"\n‚ùó Found {len(duplicates)} groups of duplicates:\n")
    
    total_wasted = 0
    for hash, files in duplicates.items():
        size = files[0].stat().st_size
        size_mb = size / (1024 * 1024)
        wasted = size * (len(files) - 1)
        total_wasted += wasted
        
        print(f"üìÅ Duplicate group (Size: {size_mb:.2f} MB):")
        for file in files:
            print(f"   {file}")
        print()
    
    wasted_mb = total_wasted / (1024 * 1024)
    print(f"üíæ Total wasted space: {wasted_mb:.2f} MB")

def delete_duplicates(directory, keep_first=True):
    """Delete duplicate files, keeping one copy"""
    
    path = Path(directory)
    hashes = defaultdict(list)
    
    # Find duplicates
    for file in path.rglob('*'):
        if file.is_file():
            file_hash = get_file_hash(file)
            if file_hash:
                hashes[file_hash].append(file)
    
    duplicates = {hash: files for hash, files in hashes.items() if len(files) > 1}
    
    deleted_count = 0
    freed_space = 0
    
    for hash, files in duplicates.items():
        # Keep first, delete rest
        files_to_delete = files[1:] if keep_first else files[:-1]
        
        for file in files_to_delete:
            size = file.stat().st_size
            try:
                file.unlink()
                print(f"üóëÔ∏è  Deleted: {file}")
                deleted_count += 1
                freed_space += size
            except Exception as e:
                print(f"‚ùå Error deleting {file}: {e}")
    
    freed_mb = freed_space / (1024 * 1024)
    print(f"\nüéâ Deleted {deleted_count} duplicates, freed {freed_mb:.2f} MB!")

# Example:
# find_duplicates('C:\\Users\\YourName\\Documents')
# delete_duplicates('C:\\Users\\YourName\\Documents')  # Be careful!
```

### Project 4: Old File Cleaner

```python
import os
import time
from pathlib import Path
from datetime import datetime, timedelta

def clean_old_files(directory, days_old=30, file_types=None, dry_run=True):
    """Delete files older than specified days"""
    
    path = Path(directory)
    cutoff_date = time.time() - (days_old * 24 * 60 * 60)
    
    deleted_count = 0
    freed_space = 0
    
    print(f"üîç Searching for files older than {days_old} days...")
    print(f"{'[DRY RUN] ' if dry_run else ''}In: {directory}\n")
    
    for file in path.rglob('*'):
        if file.is_file():
            # Check file type if specified
            if file_types and file.suffix.lower() not in file_types:
                continue
            
            # Check age
            mod_time = file.stat().st_mtime
            
            if mod_time < cutoff_date:
                size = file.stat().st_size
                age_days = (time.time() - mod_time) / (24 * 60 * 60)
                
                if dry_run:
                    print(f"[WOULD DELETE] {file.name} (Age: {age_days:.0f} days, Size: {size} bytes)")
                else:
                    try:
                        file.unlink()
                        print(f"üóëÔ∏è  Deleted: {file.name}")
                        deleted_count += 1
                        freed_space += size
                    except Exception as e:
                        print(f"‚ùå Error deleting {file}: {e}")
    
    if not dry_run:
        freed_mb = freed_space / (1024 * 1024)
        print(f"\nüéâ Deleted {deleted_count} files, freed {freed_mb:.2f} MB!")
    else:
        print("\n[DRY RUN] No files actually deleted. Set dry_run=False to delete.")

# Examples:
# clean_old_files('C:\\Users\\YourName\\Downloads', days_old=30, dry_run=True)
# clean_old_files('C:\\Temp', days_old=7, file_types=['.tmp', '.log'], dry_run=False)
```

### Project 5: Automated Backup

```python
import shutil
import time
from pathlib import Path
from datetime import datetime

def backup_folder(source, backup_location):
    """Create timestamped backup of folder"""
    
    source_path = Path(source)
    
    if not source_path.exists():
        print(f"‚ùå Source folder not found: {source}")
        return
    
    # Create backup name with timestamp
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_name = f"{source_path.name}_backup_{timestamp}"
    backup_path = Path(backup_location) / backup_name
    
    print(f"üì¶ Creating backup...")
    print(f"   Source: {source}")
    print(f"   Destination: {backup_path}")
    
    try:
        # Copy entire folder
        shutil.copytree(source, backup_path)
        
        # Calculate size
        total_size = sum(f.stat().st_size for f in backup_path.rglob('*') if f.is_file())
        size_mb = total_size / (1024 * 1024)
        
        print(f"‚úÖ Backup complete!")
        print(f"   Size: {size_mb:.2f} MB")
        print(f"   Location: {backup_path}")
        
    except Exception as e:
        print(f"‚ùå Backup failed: {e}")

def manage_backups(backup_location, keep_count=5):
    """Keep only the most recent N backups"""
    
    path = Path(backup_location)
    
    # Get all backup folders
    backups = sorted([d for d in path.iterdir() if d.is_dir() and 'backup' in d.name])
    
    if len(backups) <= keep_count:
        print(f"‚úÖ Only {len(backups)} backups exist (keeping {keep_count})")
        return
    
    # Delete oldest backups
    to_delete = backups[:-keep_count]
    
    for backup in to_delete:
        try:
            shutil.rmtree(backup)
            print(f"üóëÔ∏è  Deleted old backup: {backup.name}")
        except Exception as e:
            print(f"‚ùå Error deleting {backup}: {e}")
    
    print(f"‚úÖ Kept most recent {keep_count} backups")

# Example:
# backup_folder('C:\\Users\\YourName\\Documents', 'D:\\Backups')
# manage_backups('D:\\Backups', keep_count=5)
```

### Project 6: Filename-Based File Organizer

```python
from pathlib import Path
import shutil
import re

def organize_by_date_in_filename(directory):
    """Organize files by date found in filename (YYYY-MM-DD or YYYYMMDD)"""
    
    path = Path(directory)
    organized_count = 0
    
    # Pattern to find dates
    date_pattern = r'(\d{4})[_-]?(\d{2})[_-]?(\d{2})'
    
    for file in path.iterdir():
        if file.is_file():
            # Search for date in filename
            match = re.search(date_pattern, file.name)
            
            if match:
                year, month, day = match.groups()
                
                # Create folder structure: YYYY/MM/
                year_folder = path / year
                month_folder = year_folder / month
                month_folder.mkdir(parents=True, exist_ok=True)
                
                # Move file
                dest = month_folder / file.name
                try:
                    shutil.move(str(file), str(dest))
                    print(f"‚úÖ Moved {file.name} ‚Üí {year}/{month}/")
                    organized_count += 1
                except Exception as e:
                    print(f"‚ùå Error: {e}")
    
    print(f"\nüéâ Organized {organized_count} files by date!")

def organize_downloads_intelligently(directory):
    """Smart organization for Downloads folder"""
    
    path = Path(directory)
    
    categories = {
        'Setup_Files': ['.exe', '.msi', '.dmg'],
        'Compressed': ['.zip', '.rar', '.7z', '.tar', '.gz'],
        'Documents': ['.pdf', '.doc', '.docx', '.txt', '.xlsx', '.pptx'],
        'Images': ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg'],
        'Videos': ['.mp4', '.avi', '.mov', '.mkv', '.flv'],
        'Audio': ['.mp3', '.wav', '.flac', '.m4a'],
        'Data': ['.csv', '.json', '.xml', '.sql'],
        'Code': ['.py', '.js', '.java', '.cpp', '.html', '.css']
    }
    
    # Create category folders
    for folder in categories.keys():
        (path / folder).mkdir(exist_ok=True)
    
    # Organize
    for file in path.iterdir():
        if file.is_file():
            ext = file.suffix.lower()
            
            for folder, extensions in categories.items():
                if ext in extensions:
                    dest = path / folder / file.name
                    try:
                        shutil.move(str(file), str(dest))
                        print(f"‚úÖ {file.name} ‚Üí {folder}/")
                    except Exception as e:
                        print(f"‚ùå Error: {e}")
                    break

# Example:
# organize_by_date_in_filename('C:\\Users\\YourName\\Photos')
# organize_downloads_intelligently('C:\\Users\\YourName\\Downloads')
```

---

## Common Mistakes

### Mistake 1: Not Checking if File Exists

**‚ùå Wrong Way:**
```python
os.remove('file.txt')  # Error if file doesn't exist!
```

**‚úÖ Correct Way:**
```python
if os.path.exists('file.txt'):
    os.remove('file.txt')
    print("File deleted")
else:
    print("File doesn't exist")
```

### Mistake 2: Not Using Try-Except for File Operations

**‚ùå Wrong Way:**
```python
for file in files:
    os.remove(file)  # One error stops everything
```

**‚úÖ Correct Way:**
```python
for file in files:
    try:
        os.remove(file)
        print(f"Deleted {file}")
    except Exception as e:
        print(f"Error deleting {file}: {e}")
```

### Mistake 3: Hardcoding Paths

**‚ùå Wrong Way:**
```python
path = 'C:\\Users\\John\\Documents'  # Won't work on other computers
```

**‚úÖ Correct Way:**
```python
from pathlib import Path
path = Path.home() / 'Documents'  # Works for any user
```

### Mistake 4: Deleting Without Confirmation

**‚ùå Dangerous:**
```python
shutil.rmtree('Important Folder')  # Gone forever!
```

**‚úÖ Safer:**
```python
folder = 'Important_Folder'
confirm = input(f"Delete {folder}? This cannot be undone! (yes/no): ")
if confirm.lower() == 'yes':
    shutil.rmtree(folder)
    print("Deleted")
else:
    print("Cancelled")
```

---

## Best Practices

### ‚úÖ Do This:

1. **Always Use Try-Except**
   ```python
   try:
       shutil.move(source, dest)
   except Exception as e:
       print(f"Error: {e}")
   ```

2. **Check Before Deleting**
   ```python
   if path.exists():
       path.unlink()
   ```

3. **Use pathlib for Modern Code**
   ```python
   from pathlib import Path
   path = Path('folder') / 'file.txt'
   ```

4. **Test on Sample Data First**
   ```python
   # Test with copies, not originals!
   ```

5. **Add Dry Run Mode**
   ```python
   def process(files, dry_run=True):
       if dry_run:
           print("Would process:", file)
       else:
           # Actually process
   ```

### ‚ùå Avoid This:

1. **Don't Hardcode Paths**
2. **Don't Delete Without Checking**
3. **Don't Ignore Errors**
4. **Don't Test on Important Data**

---

## Summary

Congratulations! You can now automate boring tasks! üéâ

**üéØ Key Takeaways:**

**üìå os Module**
- `listdir()` - list files
- `mkdir()`, `makedirs()` - create folders
- `remove()` - delete files
- `rename()` - rename/move files
- `walk()` - traverse directories

**üìå shutil Module**
- `copy()`, `copy2()` - copy files
- `copytree()` - copy folders
- `move()` - move files/folders
- `rmtree()` - delete folders

**üìå pathlib Module**
- Modern, object-oriented
- `Path()` - create paths
- `.iterdir()` - list items
- `.glob()`, `.rglob()` - pattern matching
- `.exists()`, `.is_file()` - check types

**üìå glob Module**
- Pattern matching with `*`, `**`
- `glob.glob()` for finding files

**üí° Remember:**
- Always use try-except
- Check before deleting
- Test on sample data first
- Use pathlib for new code
- Automation saves hours!

---

## Practice Exercises

### Exercise 1: Photo Organizer

**Task:** Organize photos by year/month based on creation date. Use `os.path.getmtime()` or file EXIF data if available.

---

### Exercise 2: Log File Cleaner

**Task:** Delete `.log` files older than 7 days from specified folder.

---

### Exercise 3: Music Library Organizer

**Task:** Organize music files into `Artist/Album/` folder structure (read ID3 tags if possible, or by name).

---

### Exercise 4: Screenshot Renamer

**Task:** Find all screenshots (Screenshot*, IMG_*) and rename to format: `Screenshot_YYYYMMDD_HHMMSS.png`

---

### Exercise 5: Workspace Backup

**Task:** Create automated backup script that backs up project folder weekly, keeps last 3 backups.

---

### Exercise 6: Duplicate Image Finder

**Task:** Find duplicate images based on file hash, show groups, optionally delete.

---

### Exercise 7: Empty Folder Remover

**Task:** Recursively find and delete all empty folders in directory tree.
---

### Exercise 8: File Extension Fixer

**Task:** Fix wrong file extensions by examining file header (magic bytes) and renaming accordingly.

---

### Exercise 9: Download Organizer

**Task:** Monitor Downloads folder, automatically organize new files by type every 5 minutes.

---

### Exercise 10: Project Template Creator

**Task:** Create script that generates project structure (folders, files) for Python projects automatically.

---

## What's Next?

You've learned automation! üéâ

In the final blog, **Chapter 17: Final Project - Student Management System**, you'll:

- Build complete application from scratch
- Combine ALL concepts learned
- File handling for data persistence
- Exception handling for robustness
- OOP with all 4 pillars
- Menu-driven interface
- Professional code organization

**Why this matters:** This capstone project demonstrates real-world application development, combining everything you've learned into one complete system!

**Get ready to:** Build a professional application that showcases your Python skills!

---

**Congratulations!** You can now automate repetitive tasks and save hours of work. Python does the boring stuff while you focus on important things! ü§ñ‚ú®

Remember: Automate once, benefit forever! üöÄ
