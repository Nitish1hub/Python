# Variables and Data Types in Python

## Table of Contents
1. [What are Variables?](#what-are-variables)
2. [How Memory Allocation Works](#how-memory-allocation-works)
3. [Basic Data Types](#basic-data-types)
   - [Integers (int)](#integers-int)
   - [Floating-Point Numbers (float)](#floating-point-numbers-float)
   - [Strings (str)](#strings-str)
   - [Booleans (bool)](#booleans-bool)
   - [None Type (NoneType)](#none-type-nonetype)
   - [Binary Types](#binary-types)
4. [Type Checking](#type-checking)
5. [Type Conversion and Type Casting](#type-conversion-and-type-casting)
6. [Variable Naming Rules](#variable-naming-rules)
7. [Multiple Assignment](#multiple-assignment)
8. [Constants](#constants)
9. [Best Practices](#best-practices)

---

## What are Variables?

Variables are containers that store data values. Think of them as labeled boxes where you can put different types of information. Unlike some other programming languages, Python doesn't require you to declare the type of a variable before using it.

### Creating Variables

In Python, you create a variable by simply assigning a value to it using the `=` operator:

```python
# Creating variables
name = "Alice"
age = 25
height = 5.6
is_student = True
```

Python automatically determines the type of the variable based on the value you assign to it. This is called **dynamic typing**.

---

## How Memory Allocation Works

Understanding how Python stores variables in memory helps you write more efficient code.

### What is an Object in Memory?

Before we dive deeper, let's understand what "object in memory" means:

**Memory** is like your computer's workspace - a place where it temporarily stores information while your program is running. Think of it like a huge warehouse with millions of storage bins.

**An object** is a container that holds a value along with information about that value (like its type). When you create a variable with a value like `x = 10`, Python:
- Allocates (reserves) a space in memory
- Creates an **object** in that space containing:
  - The value itself (10)
  - The type of the value (int)
  - Other internal information

Think of an object like a labeled box in the warehouse:
- The box contains the actual value (10)
- The label tells what type it is (integer)
- The variable name (x) is like a tag that points to this box's location

```python
# When you write this:
x = 10

# Python does this behind the scenes:
# 1. Creates an object containing the value 10 and type information
# 2. Stores it at a memory location (like address 140712345678)
# 3. Makes 'x' point to that memory location
```

### How Memory Allocation Works

When you create a variable in Python:
1. Python creates an **object** in memory to store the value
2. The variable name becomes a **reference** (pointer) to that object
3. Multiple variables can reference the same object

### Example: Memory References

```python
# Creating a variable
x = 10

# The number 10 is stored in memory
# x points to that memory location

# Let's see the memory address
print(id(x))  # Output: (a unique memory address like 140712345678)

# Creating another variable with the same value
y = 10
print(id(y))  # Same memory address as x!

# Python reuses the same object for small integers
```

### Understanding Mutable vs Immutable

Before we dive deeper into memory, let's understand two important concepts:

**Immutable** means "cannot be changed or modified." Once you create an immutable object, you cannot alter its value. Think of it like a sealed envelope - you can't change what's inside; you can only create a new envelope.

**Mutable** means "can be changed or modified." You can alter mutable objects after creating them. Think of it like a shopping list - you can add items, remove items, or change items on the same list.

```python
# Example to understand the difference
# Immutable example (string)
name = "Alice"
print(id(name))  # Memory address: e.g., 140712345678

name = "Bob"  # This creates a NEW object in memory
print(id(name))  # Different memory address: e.g., 140712345900

# You didn't change "Alice" to "Bob"
# You created a new object "Bob" and made 'name' point to it

# Mutable example (list - we'll learn this later)
shopping_list = ["apples", "bread"]
print(id(shopping_list))  # Memory address: e.g., 140712346000

shopping_list.append("milk")  # This MODIFIES the same object
print(id(shopping_list))  # Same memory address: e.g., 140712346000

# The list object itself was modified, not replaced
```

### Important Points About Memory:

1. **Immutable objects** (int, float, str, bool, tuple) cannot be changed after creation
2. **Mutable objects** (list, dict, set) can be modified
3. When you "change" an immutable object, Python creates a new object

```python
# Demonstrating immutability
a = 5
print(id(a))  # Memory address 1

a = a + 1  # This creates a NEW object
print(id(a))  # Different memory address!

# a now points to a different object (6), not the same object
```

---

## Basic Data Types

Python has several built-in data types. Let's explore the four fundamental ones:

### Integers (int)

Integers are whole numbers without decimal points. They can be positive, negative, or zero.

```python
# Integer examples
age = 25
temperature = -5
score = 0
large_number = 1000000000000

# Python 3 has no limit on integer size!
very_large = 123456789012345678901234567890
print(very_large)

# You can use underscores for readability
population = 7_900_000_000  # Same as 7900000000
```

#### Operations with Integers

```python
a = 10
b = 3

# Arithmetic operations
print(a + b)   # Addition: 13
print(a - b)   # Subtraction: 7
print(a * b)   # Multiplication: 30
print(a / b)   # Division: 3.333... (returns float)
print(a // b)  # Floor division: 3 (returns int)
print(a % b)   # Modulus (remainder): 1
print(a ** b)  # Exponentiation: 1000
```

### Floating-Point Numbers (float)

Floats are numbers with decimal points. They're used for more precise calculations.

```python
# Float examples
pi = 3.14159
temperature = 98.6
price = 19.99
negative_float = -45.7

# Scientific notation
speed_of_light = 3e8  # 3 * 10^8 = 300000000.0
small_number = 1.5e-4  # 0.00015
```

#### Operations with Floats

```python
x = 10.5
y = 2.5

print(x + y)   # 13.0
print(x - y)   # 8.0
print(x * y)   # 26.25
print(x / y)   # 4.2
print(x // y)  # 4.0 (floor division)
print(x ** y)  # 138.28...
```

#### Important: Floating-Point Precision

```python
# Floats can have precision issues
result = 0.1 + 0.2
print(result)  # 0.30000000000000004 (not exactly 0.3!)

# For precise decimal calculations, use the decimal module
from decimal import Decimal

precise_result = Decimal('0.1') + Decimal('0.2')
print(precise_result)  # 0.3 (exact!)
```

### Strings (str)

Strings are sequences of characters enclosed in quotes. You can use single quotes (`'`), double quotes (`"`), or triple quotes (`'''` or `"""`).

```python
# String examples
name = "Alice"
message = 'Hello, World!'
multiline = """This is a
multiline
string"""

# Strings with quotes inside
quote1 = "He said, 'Hello!'"
quote2 = 'She said, "Hi!"'
quote3 = "He said, \"Hello!\""  # Using escape character
```

#### String Operations

```python
first_name = "John"
last_name = "Doe"

# Concatenation
full_name = first_name + " " + last_name
print(full_name)  # John Doe

# Repetition
print("Ha" * 3)  # HaHaHa

# Length
print(len(full_name))  # 8

# Accessing characters (indexing starts at 0)
print(full_name[0])   # J
print(full_name[-1])  # e (last character)

# Slicing
print(full_name[0:4])   # John
print(full_name[5:])    # Doe
print(full_name[:4])    # John
```

#### String Methods

```python
text = "  Hello, Python!  "

# Common string methods
print(text.upper())        # "  HELLO, PYTHON!  "
print(text.lower())        # "  hello, python!  "
print(text.strip())        # "Hello, Python!" (removes whitespace)
print(text.replace("Python", "World"))  # "  Hello, World!  "
print(text.split(","))     # ['  Hello', ' Python!  ']

# Checking string content
email = "user@example.com"
print(email.startswith("user"))  # True
print(email.endswith(".com"))    # True
print("@" in email)              # True

# String formatting
name = "Alice"
age = 25

# Method 1: f-strings (Python 3.6+) - RECOMMENDED
message = f"My name is {name} and I'm {age} years old"

# Method 2: format() method
message = "My name is {} and I'm {} years old".format(name, age)

# Method 3: Old style (%)
message = "My name is %s and I'm %d years old" % (name, age)

print(message)
```

### Booleans (bool)

Booleans represent truth values: `True` or `False`. They're essential for decision-making in programs.

```python
# Boolean examples
is_raining = True
is_sunny = False
has_permission = True

# Booleans from comparisons
print(5 > 3)      # True
print(10 == 5)    # False
print(7 != 7)     # False
print(4 <= 4)     # True
```

#### Boolean Operations

```python
a = True
b = False

# Logical operators
print(a and b)    # False (both must be True)
print(a or b)     # True (at least one must be True)
print(not a)      # False (inverts the value)

# Complex conditions
age = 20
has_license = True

can_drive = age >= 18 and has_license
print(can_drive)  # True
```

#### Truthy and Falsy Values

In Python, many values can be evaluated as True or False in a boolean context:

```python
# Falsy values (evaluate to False)
print(bool(0))          # False
print(bool(0.0))        # False
print(bool(""))         # False (empty string)
print(bool([]))         # False (empty list)
print(bool(None))       # False

# Truthy values (evaluate to True)
print(bool(1))          # True
print(bool(-5))         # True
print(bool("Hello"))    # True
print(bool([1, 2]))     # True
```

---

### None Type (NoneType)

**None** represents the absence of a value. It's Python's way of saying "nothing" or "no value here."

**Real-World Analogy:**
- Empty box labeled "to be filled later"
- A question with no answer yet
- An optional field left blank

#### Understanding None

```python
# None is a special constant
result = None

print(result)        # None
print(type(result))  # <class 'NoneType'>

# None is not the same as 0, False, or empty string
print(None == 0)     # False
print(None == False) # False
print(None == "")    # False

# But None is equal to itself
print(None == None)  # True
```

#### Common Uses of None

**1. Default Function Return Value**
```python
def greet(name):
    print(f"Hello, {name}!")
    # No return statement = returns None

result = greet("Alice")  # Prints: Hello, Alice!
print(result)            # None
```

**2. Optional Parameters**
```python
def create_user(name, email=None, phone=None):
    """Create user with optional contact info"""
    user = {"name": name}
    
    if email is not None:
        user["email"] = email
    
    if phone is not None:
        user["phone"] = phone
    
    return user

# Use with or without optional parameters
user1 = create_user("Alice")
print(user1)  # {'name': 'Alice'}

user2 = create_user("Bob", email="bob@example.com")
print(user2)  # {'name': 'Bob', 'email': 'bob@example.com'}
```

**3. Placeholder for Future Values**
```python
# Variable to be assigned later
data = None

# Simulate loading data
if condition:
    data = load_from_database()
else:
    data = load_from_file()

if data is not None:
    process(data)
```

**4. Indicating Missing or Invalid Results**
```python
def find_user(user_id):
    """Find user by ID, return None if not found"""
    users = {1: "Alice", 2: "Bob", 3: "Charlie"}
    return users.get(user_id)  # Returns None if not found

user = find_user(5)
if user is None:
    print("User not found")
else:
    print(f"Found user: {user}")
```

#### Checking for None

```python
value = None

# ‚úÖ Correct way - use 'is'
if value is None:
    print("Value is None")

if value is not None:
    print("Value exists")

# ‚ùå Avoid using == for None
# (works but 'is' is the convention)
if value == None:  # Not recommended
    print("Value is None")
```

#### None in Boolean Context

```python
# None is falsy
if None:
    print("Won't print")  # None evaluates to False

value = None
if not value:
    print("Value is None or falsy")  # Prints

# Be careful with comparisons
result = None

# Check specifically for None
if result is None:
    print("No result yet")

# Or check for any falsy value
if not result:
    print("Result is falsy (None, empty, False, or 0)")
```

#### Real-World Example: Search Function

```python
def search_product(product_id, inventory):
    """
    Search for product in inventory.
    Returns product dict if found, None otherwise.
    """
    for product in inventory:
        if product['id'] == product_id:
            return product
    return None  # Explicitly return None when not found

# Example usage
inventory = [
    {'id': 101, 'name': 'Laptop', 'price': 999},
    {'id': 102, 'name': 'Mouse', 'price': 25},
    {'id': 103, 'name': 'Keyboard', 'price': 75}
]

# Search for existing product
product = search_product(102, inventory)
if product is not None:
    print(f"Found: {product['name']} - ${product['price']}")
else:
    print("Product not found")

# Search for non-existent product
product = search_product(999, inventory)
if product is None:
    print("Product not found")  # This prints
```

#### None Best Practices

**‚úÖ Do:**
```python
# Use 'is' and 'is not' for None checks
if value is None:
    pass

# Return None explicitly when appropriate
def get_value():
    if condition:
        return result
    return None  # Explicit is better than implicit

# Use None for optional parameters
def process(data, config=None):
    if config is None:
        config = default_config()
```

**‚ùå Don't:**
```python
# Don't use == for None
if value == None:  # Use 'is' instead
    pass

# Don't confuse None with empty collections
data = []
if data is None:  # Won't work! data is an empty list, not None
    pass

# Better:
if not data:  # Checks if list is empty
    pass
```

---

### Binary Types

**Binary types** handle raw binary data (sequences of bytes). Essential for file I/O, network operations, and working with binary formats.

#### bytes - Immutable Binary Sequence

**bytes** is an immutable sequence of bytes (values 0-255).

```python
# Creating bytes
bytes1 = b'Hello'           # Byte string literal
bytes2 = b'\x48\x65\x6c\x6c\x6f'  # Using hex values
bytes3 = bytes([72, 101, 108, 108, 111])  # From list of integers
bytes4 = 'Hello'.encode('utf-8')  # From string

print(bytes1)       # b'Hello'
print(type(bytes1)) # <class 'bytes'>
print(len(bytes1))  # 5

# Accessing individual bytes
print(bytes1[0])    # 72 (ASCII code for 'H')
print(bytes1[1])    # 101 (ASCII code for 'e')
```

**Common Operations:**
```python
# Bytes are immutable
bytes_data = b'Python'
# bytes_data[0] = 74  # ERROR! Cannot modify

# Concatenation
bytes1 = b'Hello'
bytes2 = b' World'
result = bytes1 + bytes2
print(result)  # b'Hello World'

# Repetition
repeated = b'AB' * 3
print(repeated)  # b'ABABAB'

# Slicing
data = b'Python'
print(data[0:3])   # b'Pyt'
print(data[::2])   # b'Pto'

# Checking membership
if b'th' in b'Python':
    print("Found!")
```

**Converting Between bytes and str:**
```python
# String to bytes
text = "Hello, ‰∏ñÁïå"  # String with Unicode
bytes_data = text.encode('utf-8')  # Encode to bytes
print(bytes_data)  # b'Hello, \xe4\xb8\x96\xe7\x95\x8c'

# Bytes to string
bytes_data = b'Hello, World'
text = bytes_data.decode('utf-8')  # Decode from bytes
print(text)  # Hello, World

# Handle encoding errors
try:
    invalid = b'\xff\xfe'.decode('utf-8')
except UnicodeDecodeError:
    print("Cannot decode - invalid UTF-8")
```

#### bytearray - Mutable Binary Sequence

**bytearray** is like bytes but mutable (can be modified).

```python
# Creating bytearray
ba1 = bytearray(b'Hello')              # From bytes
ba2 = bytearray([72, 101, 108, 108, 111])  # From list
ba3 = bytearray(5)                     # Create with 5 zero bytes

print(ba1)        # bytearray(b'Hello')
print(type(ba1))  # <class 'bytearray'>

# Modifying bytearray (unlike bytes!)
ba = bytearray(b'Hello')
ba[0] = 74  # Change 'H' (72) to 'J' (74)
print(ba)   # bytearray(b'Jello')

# Appending
ba = bytearray(b'Hello')
ba.append(33)  # Add '!' (ASCII 33)
print(ba)      # bytearray(b'Hello!')

# Extending
ba = bytearray(b'Hello')
ba.extend(b' World')
print(ba)  # bytearray(b'Hello World')

# Inserting
ba = bytearray(b'Hello')
ba.insert(5, 33)  # Insert '!' at index 5
print(ba)         # bytearray(b'Hello!')

# Removing
ba = bytearray(b'Hello')
ba.remove(108)  # Remove 'l' (ASCII 108) - first occurrence
print(ba)       # bytearray(b'Helo')
```

**When to Use bytearray:**
```python
# Building binary data dynamically
data = bytearray()

# Add header
data.extend(b'HEADER')

# Add content length (as 4 bytes)
content = b'Some content here'
data.extend(len(content).to_bytes(4, 'big'))

# Add content
data.extend(content)

print(data)
# bytearray(b'HEADER\x00\x00\x00\x11Some content here')
```

#### memoryview - Memory-Efficient View

**memoryview** provides a view into binary data without copying it. Useful for performance with large data.

```python
# Create memoryview from bytes or bytearray
data = bytearray(b'Hello World')
mv = memoryview(data)

print(mv)           # <memory at 0x...>
print(len(mv))      # 11
print(mv[0])        # 72 ('H')

# Slicing creates a view (no copy!)
slice_view = mv[0:5]
print(bytes(slice_view))  # b'Hello'

# Modifying through memoryview
data = bytearray(b'Hello')
mv = memoryview(data)
mv[0] = 74  # Change 'H' to 'J'
print(data)  # bytearray(b'Jello')

# Original data is modified!
```

**Memory Efficiency Example:**
```python
import sys

# Large binary data
large_data = bytearray(1000000)  # 1 MB

# Without memoryview - creates copy
slice1 = large_data[0:500000]
print(f"Slice size: {sys.getsizeof(slice1)} bytes")

# With memoryview - no copy
mv = memoryview(large_data)
slice2 = mv[0:500000]
print(f"View size: {sys.getsizeof(slice2)} bytes")  # Much smaller!
```

#### Real-World Binary Example: File Operations

```python
# Reading binary file
def read_binary_file(filename):
    """Read file as binary data"""
    with open(filename, 'rb') as f:  # 'rb' = read binary
        data = f.read()
    return data

# Writing binary file
def write_binary_file(filename, data):
    """Write binary data to file"""
    with open(filename, 'wb') as f:  # 'wb' = write binary
        f.write(data)

# Example: Copy image file
image_data = read_binary_file('photo.jpg')
write_binary_file('photo_copy.jpg', image_data)

# Process binary data
data = bytearray(image_data)
# Modify data as needed
data[0:10] = b'\x00' * 10  # Overwrite first 10 bytes
write_binary_file('modified.jpg', data)
```

#### Binary Types Comparison

```python
# bytes - Immutable, like str for binary data
bytes_data = b'Hello'
# bytes_data[0] = 74  # ERROR!

# bytearray - Mutable, like list for binary data
bytearray_data = bytearray(b'Hello')
bytearray_data[0] = 74  # OK! Now b'Jello'

# memoryview - View without copying
data = bytearray(b'Hello World')
mv = memoryview(data)
slice_mv = mv[0:5]  # No copy, just a view
```

#### When to Use Each Type

**Use bytes when:**
- Reading binary files
- Working with network protocols
- Data won't change
- Need hashable type (for dict keys, sets)

**Use bytearray when:**
- Building binary data dynamically
- Need to modify binary data
- Parsing binary formats
- Protocol implementations

**Use memoryview when:**
- Working with large binary data
- Need to avoid copying
- Performance is critical
- Slicing/indexing large data

#### Binary Types Best Practices

```python
# ‚úÖ Good practices

# Use context managers for binary files
with open('data.bin', 'rb') as f:
    data = f.read()

# Specify encoding explicitly
text = bytes_data.decode('utf-8')

# Use bytearray for building data
packet = bytearray()
packet.extend(b'HEADER')
packet.append(42)

# Use memoryview for large data slicing
large = bytearray(1000000)
mv = memoryview(large)
chunk = mv[0:1000]  # No copy!

# ‚ùå Avoid

# Don't forget encoding
# text = bytes_data.decode()  # May fail!

# Don't modify bytes (impossible)
# b'Hello'[0] = 74  # TypeError

# Don't use + for building large binary data
# data = b''
# for i in range(1000):
#     data = data + bytes([i])  # Inefficient! Use bytearray
```

---

## Type Checking

Python provides several ways to check the type of a variable.

### Using type()

The `type()` function returns the type of an object:

```python
name = "Alice"
age = 25
height = 5.6
is_student = True

print(type(name))       # <class 'str'>
print(type(age))        # <class 'int'>
print(type(height))     # <class 'float'>
print(type(is_student)) # <class 'bool'>
```

### Using isinstance()

The `isinstance()` function checks if an object is an instance of a specific type:

```python
age = 25

# isinstance() returns a boolean
print(isinstance(age, int))     # True
print(isinstance(age, str))     # False
print(isinstance(age, (int, float)))  # True (checks multiple types)

# Checking different types
name = "Alice"
height = 5.6
is_student = True

print(isinstance(name, str))        # True
print(isinstance(height, float))    # True
print(isinstance(is_student, bool)) # True
print(isinstance(is_student, int))  # True (bool is a subclass of int)
```

### Comparison: type() vs isinstance()

```python
# type() checks exact type
print(type(True) == bool)    # True
print(type(True) == int)     # False (even though bool is a subclass of int)

# isinstance() checks if it's an instance (includes inheritance)
print(isinstance(True, bool))  # True
print(isinstance(True, int))   # True (bool inherits from int)
```

---

## Type Conversion and Type Casting

Type conversion is the process of converting one data type to another. Python provides built-in functions for this.

### Implicit Type Conversion (Automatic)

Python automatically converts one data type to another when needed:

```python
# Integer + Float = Float
num_int = 5
num_float = 2.5

result = num_int + num_float
print(result)        # 7.5
print(type(result))  # <class 'float'>

# Python automatically converted int to float
```

### Explicit Type Conversion (Type Casting)

You manually convert types using built-in functions:

#### Converting to Integer: int()

```python
# Float to int (truncates decimal part)
x = 3.9
print(int(x))  # 3 (not 4! It doesn't round)

# String to int
age = int("25")
print(age)     # 25
print(type(age))  # <class 'int'>

# Boolean to int
print(int(True))   # 1
print(int(False))  # 0

# Be careful with invalid conversions
# int("3.14")  # ValueError: invalid literal (can't convert decimal string to int)
# int("hello") # ValueError: invalid literal (can't convert text to int)

# To convert decimal string to int, convert to float first
num_str = "3.14"
num_float = float(num_str)  # "3.14" -> 3.14
num_int = int(num_float)    # 3.14 -> 3
print(num_int)  # 3
```

#### Converting to Float: float()

```python
# Int to float
x = 5
print(float(x))  # 5.0

# String to float
price = float("19.99")
print(price)  # 19.99

# Boolean to float
print(float(True))   # 1.0
print(float(False))  # 0.0
```

#### Converting to String: str()

```python
# Int to string
age = 25
age_str = str(age)
print(age_str)      # "25"
print(type(age_str))  # <class 'str'>

# Float to string
price = 19.99
print(str(price))  # "19.99"

# Boolean to string
print(str(True))   # "True"

# This is useful for concatenation
print("I am " + str(age) + " years old")
# Better way: use f-strings
print(f"I am {age} years old")
```

#### Converting to Boolean: bool()

```python
# Any non-zero number = True
print(bool(5))      # True
print(bool(-1))     # True
print(bool(0))      # False

# Any non-empty string = True
print(bool("Hello"))  # True
print(bool(""))       # False

# Checking if a string is empty or has content
name = "Alice"
empty_string = ""

print(bool(name))          # True (has content)
print(bool(empty_string))  # False (empty)
```

### Practical Examples

```python
# Example 1: Calculations with different types
score1 = "85"
score2 = "92"
average = (int(score1) + int(score2)) / 2
print(f"Average score: {average}")  # 88.5

# Example 2: Combining strings and numbers
name = "Alice"
age = 25
height = 5.6

# Must convert numbers to strings for concatenation
message = name +" is " + str(age) + " years old and " + str(height) + " feet tall."
print(message)

# Or use f-strings (easier!)
message = f"{name} is {age} years old and {height} feet tall."
print(message)

# Example 3: Formatting output
pi = 3.14159
print(f"Pi rounded to 2 decimals: {pi:.2f}")  # 3.14
price = 19.99
print(f"Price: ${price:.2f}")  # Price: $19.99
```

---

## Variable Naming Rules

Following proper naming conventions makes your code readable and maintainable.

### Rules You MUST Follow

1. **Must start with a letter or underscore** (`_`)
   ```python
   # Valid
   name = "Alice"
   _private = "secret"
   
   # Invalid
   # 2name = "Bob"  # SyntaxError
   ```

2. **Can contain letters, numbers, and underscores**
   ```python
   # Valid
   user_1 = "Alice"
   total_score = 100
   _temp_var = 42
   
   # Invalid
   # user-name = "Bob"  # SyntaxError (hyphen not allowed)
   # total$score = 50   # SyntaxError ($ not allowed)
   ```

3. **Case-sensitive**
   ```python
   name = "Alice"
   Name = "Bob"
   NAME = "Charlie"
   # These are three different variables!
   ```

4. **Cannot be a Python keyword**
   ```python
   # Invalid - these are reserved keywords
   # if = 5
   # for = 10
   # class = "Math"
   
   # To see all keywords:
   import keyword
   print(keyword.kwlist)
   ```

### Naming Conventions (Best Practices)

1. **Use snake_case for variables** (lowercase with underscores)
   ```python
   # Good
   user_name = "Alice"
   total_score = 100
   is_valid = True
   
   # Not recommended (but valid)
   userName = "Bob"  # camelCase (used in other languages)
   UserName = "Charlie"  # PascalCase (reserved for classes)
   ```

2. **Use descriptive names**
   ```python
   # Good
   student_age = 20
   total_price = 99.99
   is_logged_in = True
   
   # Bad (unclear)
   x = 20
   p = 99.99
   flag = True
   ```

3. **Use UPPERCASE for constants**
   ```python
   # Constants (values that shouldn't change)
   PI = 3.14159
   MAX_USERS = 100
   DATABASE_URL = "localhost:5432"
   ```

4. **Use single underscore prefix for "internal" variables**
   ```python
   _internal_counter = 0
   _temp_value = 42
   ```

---

## Multiple Assignment

Python allows you to assign values to multiple variables in one line.

### Assigning Same Value to Multiple Variables

```python
# All three variables get the same value
x = y = z = 0
print(x, y, z)  # 0 0 0
```

### Assigning Different Values to Multiple Variables

```python
# Unpacking
name, age, city = "Alice", 25, "New York"
print(name)  # Alice
print(age)   # 25
print(city)  # New York

# Useful for functions that return multiple values
def get_user_info():
    return "Bob", 30, "London"

name, age, city = get_user_info()
```

### Swapping Variables

```python
# Traditional way (in other languages)
a = 5
b = 10
temp = a
a = b
b = temp
print(a, b)  # 10 5

# Python way (much cleaner!)
a = 5
b = 10
a, b = b, a  # Swap in one line!
print(a, b)  # 10 5
```

---

## Constants

Constants are variables whose values shouldn't change during program execution. Python doesn't have built-in constant support, but we use naming conventions.

### Defining Constants

```python
# Use UPPERCASE names for constants
PI = 3.14159
GRAVITY = 9.81
MAX_SPEED = 120
DEFAULT_LANGUAGE = "English"

# Use them in your code
radius = 5
area = PI * radius ** 2
print(f"Area: {area}")

# Note: Python won't stop you from changing them
PI = 3  # Not recommended, but possible
```

### Where to Put Constants

```python
# At the top of your file or in a separate config.py file
# config.py
DATABASE_HOST = "localhost"
DATABASE_PORT = 5432
MAX_CONNECTIONS = 100
TIMEOUT_SECONDS = 30

# main.py
from config import DATABASE_HOST, MAX_CONNECTIONS
# Use the constants
```

---

## Best Practices

### 1. Choose Meaningful Variable Names

```python
# Bad
x = 25
y = x * 2

# Good
age = 25
age_in_months = age * 12
```

### 2. Use Type Hints (Python 3.5+)

Type hints improve code readability and help with debugging:

```python
# Variable type hints (optional but helpful)
age: int = 25
price: float = 19.99
name: str = "Alice"
is_active: bool = True

# Type hints don't enforce types, but they help:
# - Make your code more readable
# - Help code editors give better suggestions
# - Catch potential errors before running the code

# Even with type hints, Python allows this (but it's not recommended):
age: int = "twenty-five"  # No error, but confusing!
```

### 3. Initialize Variables Properly

```python
# Always give your variables an initial value
total = 0
count = 0
message = ""
is_ready = False

# Then you can modify them later
total = total + 10
count = count + 1
message = "Hello, World!"
is_ready = True
```

### 4. Don't Reuse Variable Names for Different Types

```python
# Bad (confusing)
user = "Alice"  # string
user = 25       # now it's an int?
user = True     # now it's a boolean?

# Good
user_name = "Alice"
user_age = 25
is_active = True
```

### 5. Use Constants for Important Values

```python
# Instead of using numbers directly in calculations
area = 3.14159 * radius * radius  # What is 3.14159?

# Use named constants (makes code clearer)
PI = 3.14159
area = PI * radius * radius  # Much clearer!

# More examples
MAX_SPEED = 120
MAX_ATTEMPTS = 3
DEFAULT_TIMEOUT = 30
```

### 6. Be Careful with Floating-Point Comparisons

```python
# Floating-point arithmetic can be imprecise
result = 0.1 + 0.2
print(result)  # 0.30000000000000004
print(result == 0.3)  # False (surprising!)

# For exact comparisons, be aware of this limitation
# You can round the result for display
print(round(result, 2))  # 0.3

# Or use the Decimal module for precise calculations
from decimal import Decimal
precise = Decimal('0.1') + Decimal('0.2')
print(precise)  # 0.3 (exact!)
```

---

## Practice Examples

### Example 1: Basic Calculations with Type Conversion

```python
# Working with different types
num1_str = "42"
num2_str = "8"

# Convert strings to integers
num1 = int(num1_str)
num2 = int(num2_str)

# Perform calculations
total = num1 + num2
difference = num1 - num2
product = num1 * num2
quotient = num1 / num2  # Returns float
remainder = num1 % num2

print(f"Sum: {total}")
print(f"Difference: {difference}")
print(f"Product: {product}")
print(f"Quotient: {quotient}")
print(f"Remainder: {remainder}")
```

### Example 2: Creating a User Profile

```python
# Create a user profile with different data types
name = "Alice Johnson"
age = 25
height = 5.6  # feet
is_student = True
city = "New York"

# Calculate birth year (approximately)
current_year = 2026
birth_year = current_year - age

# Create a formatted profile message
print("=" * 40)
print("USER PROFILE")
print("=" * 40)
print(f"Name: {name}")
print(f"Age: {age} years old")
print(f"Birth Year: {birth_year}")
print(f"Height: {height} feet")
print(f"Student Status: {is_student}")
print(f"City: {city}")
print("=" * 40)

# Display variable types
print(f"\nVariable Types:")
print(f"name is {type(name).__name__}")
print(f"age is {type(age).__name__}")
print(f"height is {type(height).__name__}")
print(f"is_student is {type(is_student).__name__}")
```

### Example 3: Working with Product Information

```python
# Product information
product_name = "Wireless Headphones"
price = 79.99
quantity = 15
in_stock = True

# Calculate total value
total_value = price * quantity

# Calculate discount price
discount_rate = 0.15  # 15% off
discount_amount = price * discount_rate
discounted_price = price - discount_amount
savings = price - discounted_price

# Display product information
print(f"Product: {product_name}")
print(f"Original Price: ${price:.2f}")
print(f"Quantity in Stock: {quantity}")
print(f"Total Inventory Value: ${total_value:.2f}")
print()
print("SPECIAL OFFER - 15% OFF!")
print(f"Discounted Price: ${discounted_price:.2f}")
print(f"You Save: ${savings:.2f}")

# Boolean value
print(f"\nAvailable for purchase: {in_stock}")
```

---

## Summary

In this chapter, you learned:

- ‚úÖ **Variables** are containers for storing data values
- ‚úÖ **Memory allocation** - Python stores objects in memory and variables reference them
- ‚úÖ **Data types**: `int`, `float`, `str`, `bool`
- ‚úÖ **Type checking** using `type()` and `isinstance()`
- ‚úÖ **Type conversion** - converting between data types using `int()`, `float()`, `str()`, `bool()`
- ‚úÖ **Naming rules** and conventions for variables
- ‚úÖ **Multiple assignment** and variable swapping
- ‚úÖ **Constants** using UPPERCASE naming convention
- ‚úÖ **Best practices** for writing clean, maintainable code

### Key Takeaways

1. Python is **dynamically typed** - you don't need to declare variable types
2. Variables are **references** to objects in memory
3. **Immutable types** (int, float, str, bool) can't be changed after creation
4. Use **descriptive names** and follow **naming conventions**
5. Always **convert types** appropriately when working with user input
6. Use **type hints** to improve code readability

---

## Next Steps

Now that you understand variables and basic data types, you're ready to:
- Learn about **operators** and **expressions**
- Explore **control flow** (if-elif-else statements, loops)
- Learn about **collections** (lists, tuples, dictionaries, sets)
- Create **functions** to organize your code

Keep practicing with the examples above and experiment with your own variables! üêç