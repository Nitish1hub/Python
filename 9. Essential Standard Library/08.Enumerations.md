# Enumerations (Enum) - Creating Named Constants in Python

## Table of Contents
1. [Introduction - The Magic Number Problem](#introduction---the-magic-number-problem)
2. [Creating Basic Enums](#creating-basic-enums)
3. [Accessing Enum Members](#accessing-enum-members)
4. [Enum Properties](#enum-properties)
5. [Iterating Over Enums](#iterating-over-enums)
6. [Comparing Enums](#comparing-enums)
7. [IntEnum - Integer Enumerations](#intenum---integer-enumerations)
8. [StrEnum - String Enumerations](#strenum---string-enumerations)
9. [Flag and IntFlag](#flag-and-intflag)
10. [auto() - Automatic Values](#auto---automatic-values)
11. [Unique Decorator](#unique-decorator)
12. [Real-Life Practical Examples](#real-life-practical-examples)
13. [Best Practices](#best-practices)
14. [Summary](#summary)
15. [Practice Exercises](#practice-exercises)
16. [What's Next?](#whats-next)

---

## Introduction - The Magic Number Problem

### The Problem with Magic Numbers

```python
# ‚ùå BAD - What does 0, 1, 2 mean?
def get_status(order):
    if order.status == 0:
        return "Pending"
    elif order.status == 1:
        return "Processing"
    elif order.status == 2:
        return "Shipped"
    elif order.status == 3:
        return "Delivered"
```

**Problems:**
- What does `0` mean?
- Easy to use wrong number
- Hard to read and maintain
- No type safety

### Using Constants (Better, but not great)

```python
# Better, but still issues
PENDING = 0
PROCESSING = 1
SHIPPED = 2
DELIVERED = 3

def get_status(order):
    if order.status == PENDING:
        return "Pending"
    # ...
```

**Still has problems:**
- Can assign any int: `status = 999` ‚ùå
- No grouping
- Can't iterate over all statuses

### Using Enum (Best!)

```python
from enum import Enum

class OrderStatus(Enum):
    PENDING = 0
    PROCESSING = 1
    SHIPPED = 2
    DELIVERED = 3

def get_status(order):
    if order.status == OrderStatus.PENDING:
        return "Pending"
    # ...
```

**Benefits:**
- ‚úÖ Type-safe
- ‚úÖ Can't use wrong values
- ‚úÖ Can iterate
- ‚úÖ Clear and maintainable

---

## Creating Basic Enums

**Define: Enum** - A set of symbolic names bound to unique constant values.

### Basic Syntax

```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# Usage
favorite = Color.RED
print(favorite)       # Color.RED
print(favorite.value) # 1
print(favorite.name)  # 'RED'
```

### Various Value Types

```python
from enum import Enum

# Integer values
class Status(Enum):
    ACTIVE = 1
    INACTIVE = 2

# String values
class Environment(Enum):
    DEV = 'development'
    STAGING = 'staging'
    PROD = 'production'

# Tuple values
class Planet(Enum):
    EARTH = (1, 5.97, 6371)  # (number, mass, radius)
    MARS = (2, 0.64, 3390)

print(Planet.EARTH.value)  # (1, 5.97, 6371)
```

### Functional API

```python
from enum import Enum

# Alternative: Functional API
Color = Enum('Color', ['RED', 'GREEN', 'BLUE'])

print(Color.RED)        # Color.RED
print(Color.RED.value)  # 1 (auto-assigned)

# With explicit values
Color = Enum('Color', {'RED': 1, 'GREEN': 2, 'BLUE': 3})
```

---

## Accessing Enum Members

### By Name

```python
from enum import Enum

class Direction(Enum):
    NORTH = 'N'
    SOUTH = 'S'
    EAST = 'E'
    WEST = 'W'

# Access by attribute
direction = Direction.NORTH
print(direction)  # Direction.NORTH

# Access by name (string lookup)
direction = Direction['NORTH']
print(direction)  # Direction.NORTH
```

### By Value

```python
from enum import Enum

class HttpStatus(Enum):
    OK = 200
    NOT_FOUND = 404
    SERVER_ERROR = 500

# Access by value
status = HttpStatus(200)
print(status)  # HttpStatus.OK

status = HttpStatus(404)
print(status)  # HttpStatus.NOT_FOUND

# Invalid value raises ValueError
try:
    status = HttpStatus(999)
except ValueError as e:
    print(f"Error: {e}")  # Error: 999 is not a valid HttpStatus
```

---

## Enum Properties

### Name and Value

```python
from enum import Enum

class Priority(Enum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

task_priority = Priority.HIGH

print(task_priority.name)   # 'HIGH'
print(task_priority.value)  # 3

# Name is string, value is what you assigned
print(type(task_priority.name))   # <class 'str'>
print(type(task_priority.value))  # <class 'int'>
```

### Enum Member Properties

```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

red = Color.RED

print(red.name)   # 'RED'
print(red.value)  # 1
print(type(red))  # <enum 'Color'>

# Enums are immutable
try:
    red.value = 999
except AttributeError as e:
    print("Cannot modify enum!")  # Cannot modify enum!
```

---

## Iterating Over Enums

### Basic Iteration

```python
from enum import Enum

class Weekday(Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7

# Iterate over all members
for day in Weekday:
    print(f"{day.name}: {day.value}")

# Output:
# MONDAY: 1
# TUESDAY: 2
# ... etc
```

### Getting All Members

```python
from enum import Enum

class Status(Enum):
    PENDING = 'pending'
    APPROVED = 'approved'
    REJECTED = 'rejected'

# Get list of members
all_statuses = list(Status)
print(all_statuses)  # [<Status.PENDING: 'pending'>, ...]

# Get names
names = [s.name for s in Status]
print(names)  # ['PENDING', 'APPROVED', 'REJECTED']

# Get values
values = [s.value for s in Status]
print(values)  # ['pending', 'approved', 'rejected']

# Count members
print(len(Status))  # 3
```

---

## Comparing Enums

### Identity and Equality

```python
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

red1 = Color.RED
red2 = Color.RED
green = Color.GREEN

# Identity comparison (is)
print(red1 is red2)  # True (same object)
print(red1 is green) # False

# Equality comparison (==)
print(red1 == red2)  # True
print(red1 == green) # False

# Can't compare with value directly
print(red1 == 1)     # False! (enum != int)
print(red1.value == 1)  # True (int == int)
```

### Ordering

```python
from enum import Enum

class Priority(Enum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3

# ‚ùå Can't compare directly
try:
    print(Priority.LOW < Priority.HIGH)
except TypeError as e:
    print("Can't compare enums with < >")

# ‚úÖ Compare values
print(Priority.LOW.value < Priority.HIGH.value)  # True

# Or use IntEnum (see below)
```

---

## IntEnum - Integer Enumerations

**Define: IntEnum** - Enum subclass where members are also integers.

### Creating IntEnum

```python
from enum import IntEnum

class Priority(IntEnum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4

# Behaves like int
priority = Priority.HIGH

print(priority)        # Priority.HIGH
print(priority + 1)    # 4 (treated as int!)
print(priority < Priority.CRITICAL)  # True (can compare!)

# Can use in comparisons
if priority >= Priority.MEDIUM:
    print("High priority task")
```

### IntEnum Use Cases

```python
from enum import IntEnum

class HttpStatus(IntEnum):
    OK = 200
    CREATED = 201
    BAD_REQUEST = 400
    NOT_FOUND = 404
    SERVER_ERROR = 500

# Can use in arithmetic
status = HttpStatus.OK
print(status // 100)  # 2 (status category)

# Can compare with ints
print(HttpStatus.OK == 200)  # True
print(HttpStatus.NOT_FOUND < 500)  # True

# Useful for sorting
statuses = [HttpStatus.SERVER_ERROR, HttpStatus.OK, HttpStatus.NOT_FOUND]
statuses.sort()
print(statuses)  # [200, 404, 500]
```

---

## StrEnum - String Enumerations

**Define: StrEnum** - Enum where members are also strings (Python 3.11+).

### Creating StrEnum

```python
from enum import StrEnum  # Python 3.11+

class Environment(StrEnum):
    DEV = 'development'
    STAGING = 'staging'
    PROD = 'production'

env = Environment.PROD

print(env)              # Environment.PROD
print(env.upper())      # 'PRODUCTION' (string methods work!)
print(f"Running in {env}")  # "Running in production"

# Can compare with strings
print(env == 'production')  # True
```

### Before Python 3.11

```python
from enum import Enum

class Environment(str, Enum):
    DEV = 'development'
    STAGING = 'staging'
    PROD = 'production'

# Same behavior as StrEnum
```

---

## Flag and IntFlag

**Define: Flag** - Enum for bit flags (can combine members).

### Creating Flags

```python
from enum import Flag

class Permission(Flag):
    READ = 1      # 0b0001
    WRITE = 2     # 0b0010
    EXECUTE = 4   # 0b0100
    DELETE = 8    # 0b1000

# Combine flags with | (OR)
user_perms = Permission.READ | Permission.WRITE
print(user_perms)  # Permission.READ|WRITE

# Check if flag is set with & (AND)
if user_perms & Permission.READ:
    print("Has read permission")

if user_perms & Permission.EXECUTE:
    print("Has execute permission")  # Won't print

# Check with 'in'
if Permission.READ in user_perms:
    print("Has read permission")
```

### Flag Operations

```python
from enum import Flag

class Color(Flag):
    RED = 1
    GREEN = 2
    BLUE = 4

# Combine flags
purple = Color.RED | Color.BLUE
yellow = Color.RED | Color.GREEN

print(purple)  # Color.RED|BLUE
print(yellow)  # Color.RED|GREEN

# Remove flag with ^ (XOR) or  & ~
purple_no_red = purple ^ Color.RED
print(purple_no_red)  # Color.BLUE

# Check multiple flags
colors = Color.RED | Color.GREEN | Color.BLUE
if colors & (Color.RED | Color.GREEN):
    print("Contains red or green")
```

### IntFlag

```python
from enum import IntFlag

class Mode(IntFlag):
    NONE = 0
    READ = 1
    WRITE = 2
    EXECUTE = 4

# Behaves like int and Flag
mode = Mode.READ | Mode.WRITE

print(mode)           # Mode.READ|WRITE
print(int(mode))      # 3 (1 + 2)
print(mode & Mode.READ)  # Mode.READ (if set, else Mode.NONE)
```

---

## auto() - Automatic Values

**Define: auto()** - Automatically generate enum member values.

### Using auto()

```python
from enum import Enum, auto

class Color(Enum):
    RED = auto()     # 1
    GREEN = auto()   # 2
    BLUE = auto()    # 3

print(Color.RED.value)    # 1
print(Color.GREEN.value)  # 2
print(Color.BLUE.value)   # 3
```

### Custom auto() Behavior

```python
from enum import Enum, auto

class PowerOfTwo(Enum):
    def _generate_next_value_(name, start, count, last_values):
        """Generate power of 2 values"""
        if not last_values:
            return 1
        return last_values[-1] * 2
    
    FIRST = auto()   # 1
    SECOND = auto()  # 2
    THIRD = auto()   # 4
    FOURTH = auto()  # 8

print(PowerOfTwo.FIRST.value)   # 1
print(PowerOfTwo.SECOND.value)  # 2
print(PowerOfTwo.THIRD.value)   # 4
```

---

## Unique Decorator

**Define: @unique** - Ensures all enum values are unique.

### Without @unique

```python
from enum import Enum

class Status(Enum):
    PENDING = 1
    WAITING = 1  # Alias! Same value
    ACTIVE = 2

print(Status.PENDING is Status.WAITING)  # True (alias!)
```

### With @unique

```python
from enum import Enum, unique

try:
    @unique
    class Status(Enum):
        PENDING = 1
        WAITING = 1  # ValueError!
        ACTIVE = 2
except ValueError as e:
    print(f"Error: {e}")  # duplicate values found: WAITING -> PENDING
```

---

## Real-Life Practical Examples

### Example 1: HTTP API Status

```python
from enum import IntEnum

class HttpStatus(IntEnum):
    # Success
    OK = 200
    CREATED = 201
    NO_CONTENT = 204
    
    # Client errors
    BAD_REQUEST = 400
    UNAUTHORIZED = 401
    FORBIDDEN = 403
    NOT_FOUND = 404
    
    # Server errors
    SERVER_ERROR = 500
    BAD_GATEWAY = 502
    SERVICE_UNAVAILABLE = 503
    
    @property
    def is_success(self):
        return 200 <= self.value < 300
    
    @property
    def is_client_error(self):
        return 400 <= self.value < 500
    
    @property
    def is_server_error(self):
        return 500 <= self.value < 600

# Usage
status = HttpStatus.NOT_FOUND

if status.is_client_error:
    print(f"Client error: {status.name}")

print(f"Status code: {status.value}")
```

### Example 2: Game Character States

```python
from enum import Enum, auto

class CharacterState(Enum):
    IDLE = auto()
    WALKING = auto()
    RUNNING = auto()
    JUMPING = auto()
    ATTACKING = auto()
    DEFENDING = auto()
    DEAD = auto()
    
    def can_transition_to(self, new_state):
        """Check if transition is valid"""
        transitions = {
            CharacterState.IDLE: [CharacterState.WALKING, CharacterState.JUMPING, CharacterState.ATTACKING],
            CharacterState.WALKING: [CharacterState.IDLE, CharacterState.RUNNING, CharacterState.JUMPING],
            CharacterState.RUNNING: [CharacterState.WALKING, CharacterState.IDLE, CharacterState.JUMPING],
            CharacterState.JUMPING: [CharacterState.IDLE, CharacterState.WALKING],
            CharacterState.ATTACKING: [CharacterState.IDLE],
            CharacterState.DEFENDING: [CharacterState.IDLE],
            CharacterState.DEAD: []  # Can't transition from dead
        }
        return new_state in transitions.get(self, [])

# Usage
state = CharacterState.IDLE

if state.can_transition_to(CharacterState.JUMPING):
    state = CharacterState.JUMPING
    print(f"Character is now {state.name}")
```

### Example 3: File Permissions

```python
from enum import IntFlag

class FilePermission(IntFlag):
    READ = 4      # 0b100
    WRITE = 2     # 0b010
    EXECUTE = 1   # 0b001
    
    # Common combinations
    READ_WRITE = READ | WRITE
    READ_EXECUTE = READ | EXECUTE
    ALL = READ | WRITE | EXECUTE
    NONE = 0

class File:
    def __init__(self, name, permissions):
        self.name = name
        self.permissions = permissions
    
    def can_read(self):
        return bool(self.permissions & FilePermission.READ)
    
    def can_write(self):
        return bool(self.permissions & FilePermission.WRITE)
    
    def can_execute(self):
        return bool(self.permissions & FilePermission.EXECUTE)
    
    def chmod(self, permissions):
        """Change file permissions"""
        self.permissions = permissions

# Usage
script = File('script.py', FilePermission.READ_EXECUTE)

if script.can_execute():
    print(f"Executing {script.name}")

# Add write permission
script.chmod(script.permissions | FilePermission.WRITE)

if script.can_write():
    print("Now can write to file")
```

### Example 4: Order Processing

```python
from enum import Enum, auto

class OrderStatus(Enum):
    CART = auto()
    PENDING_PAYMENT = auto()
    PAYMENT_CONFIRMED = auto()
    PROCESSING = auto()
    SHIPPED = auto()
    DELIVERED = auto()
    CANCELLED = auto()
    REFUNDED = auto()
    
    @classmethod
    def active_statuses(cls):
        """Get list of active order statuses"""
        return [cls.CART, cls.PENDING_PAYMENT, cls.PROCESSING, cls.SHIPPED]
    
    @classmethod
    def completed_statuses(cls):
        """Get list of completed order statuses"""
        return [cls.DELIVERED, cls.CANCELLED, cls.REFUNDED]

class Order:
    def __init__(self, order_id):
        self.order_id = order_id
        self.status = OrderStatus.CART
    
    def transition_to(self, new_status):
        """Safely transition to new status"""
        valid_transitions = {
            OrderStatus.CART: [OrderStatus.PENDING_PAYMENT, OrderStatus.CANCELLED],
            OrderStatus.PENDING_PAYMENT: [OrderStatus.PAYMENT_CONFIRMED, OrderStatus.CANCELLED],
            OrderStatus.PAYMENT_CONFIRMED: [OrderStatus.PROCESSING, OrderStatus.REFUNDED],
            OrderStatus.PROCESSING: [OrderStatus.SHIPPED, OrderStatus.CANCELLED],
            OrderStatus.SHIPPED: [OrderStatus.DELIVERED],
        }
        
        if new_status in valid_transitions.get(self.status, []):
            self.status = new_status
            print(f"Order {self.order_id} -> {self.status.name}")
        else:
            raise ValueError(f"Can't transition from {self.status.name} to {new_status.name}")
    
    def is_active(self):
        return self.status in OrderStatus.active_statuses()

# Usage
order = Order(12345)
order.transition_to(OrderStatus.PENDING_PAYMENT)
order.transition_to(OrderStatus.PAYMENT_CONFIRMED)
order.transition_to(OrderStatus.PROCESSING)
```

---

## Best Practices

### 1. Use UPPER_CASE for Enum Members

```python
# ‚úÖ GOOD
class Status(Enum):
    ACTIVE = 1
    INACTIVE = 2

# ‚ùå BAD
class Status(Enum):
    active = 1
    inactive = 2
```

### 2. Use IntEnum for Comparable Values

```python
# ‚úÖ GOOD - Need ordering
class Priority(IntEnum):
    LOW = 1
    MEDIUM = 2
    HIGH = 3

# Can compare
if task.priority >= Priority.MEDIUM:
    print("Important task")
```

### 3. Use Flag for Bit Flags

```python
# ‚úÖ GOOD - Combine permissions
class Permission(Flag):
    READ = 1
    WRITE = 2
    EXECUTE = 4

perms = Permission.READ | Permission.WRITE
```

### 4. Add Helper Methods

```python
class Status(Enum):
    PENDING = 'pending'
    ACTIVE = 'active'
    COMPLETED = 'completed'
    
    @classmethod
    def from_string(cls, value):
        """Create enum from string"""
        try:
            return cls(value.lower())
        except ValueError:
            raise ValueError(f"Invalid status: {value}")
    
    def is_final(self):
        """Check if status is final"""
        return self == Status.COMPLETED
```

### 5. Document Your Enums

```python
class HttpMethod(Enum):
    """HTTP request methods"""
    GET = 'GET'      # Retrieve resource
    POST = 'POST'    # Create resource
    PUT = 'PUT'      # Update resource
    DELETE = 'DELETE'  # Delete resource
    PATCH = 'PATCH'  # Partial update
```

---

## Summary

**üìå Basic Enum**
- Named constants with values
- Type-safe
- Can iterate
- Immutable

**üìå IntEnum**
- Enum members are also integers
- Can compare with <, >, etc.
- Can use in arithmetic

**üìå StrEnum**
- Enum members are also strings
- Python 3.11+
- String methods work

**üìå Flag / IntFlag**
- For bit flags
- Can combine with | (OR)
- Check with & (AND)

**üìå auto()**
- Automatically generates values
- Can customize generation

**üìå @unique**
- Ensures no duplicate values
- Prevents aliasing

---

## Practice Exercises

### Exercise 1: Traffic Light
**Task:** Create enum for traffic light with timing methods.

### Exercise 2: Card Deck
**Task:** Enum for suits and ranks, compare cards.

### Exercise 3: User Roles
**Task:** Role enum with permission checking.

### Exercise 4: Log Levels
**Task:** IntEnum for log levels with comparison.

### Exercise 5: File Types
**Task:** Enum for file extensions with validators.

### Exercise 6: Planet Properties
**Task:** Enum storing planet data (mass, radius, etc).

### Exercise 7: Chess Pieces
**Task:** Enum for chess pieces with movement rules.

### Exercise 8: HTTP Methods
**Task:** Enum for HTTP methods with safe/idempotent checks.

### Exercise 9: Notification Types
**Task:** Flag enum for notification preferences.

### Exercise 10: State Machine
**Task:** Enum-based state machine with valid transitions.

---

## What's Next?

**Congratulations!** You now understand Python enumerations!

**In the next blog, you'll learn:**
- Built-in functions deep dive
- zip(), map(), filter()
- all(), any(), enumerate()
- sorted() with key parameter

**Keep writing clean code!** üêç‚ú®

