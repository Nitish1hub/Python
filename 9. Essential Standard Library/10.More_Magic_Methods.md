# More Magic Methods - Advanced Python Object Behavior

## Table of Contents
1. [Introduction - Beyond `__init__`](#introduction---beyond-__init__)
2. [`__call__` - Making Objects Callable](#__call__---making-objects-callable)
3. [`__enter__` and `__exit__` - Context Managers](#__enter__-and-__exit__---context-managers)
4. [`__str__` and `__repr__` - String Representations](#__str__-and-__repr__---string-representations)
5. [Comparison Operators](#comparison-operators)
6. [Arithmetic Operators](#arithmetic-operators)
7. [`__getitem__` and `__setitem__` - Container Behavior](#__getitem__-and-__setitem__---container-behavior)
8. [`__len__`, `__contains__` - Collection Protocol](#__len__-__contains__---collection-protocol)
9. [Real-Life Practical Examples](#real-life-practical-examples)
10. [Summary](#summary)
11. [Practice Exercises](#practice-exercises)
12. [What's Next?](#whats-next)

---

## Introduction - Beyond `__init__`

**Magic methods** (dunder methods) let you customize how objects behave!

```python
class Counter:
    def __init__(self, value):
        self.value = value
    
    # Make it callable
    def __call__(self):
        self.value += 1
        return self.value
    
    # Support addition
    def __add__(self, other):
        return Counter(self.value + other)
    
    # Support comparison
    def __lt__(self, other):
        return self.value < other.value

counter = Counter(10)
print(counter())  # 11 (callable!)
print(counter + 5)  # Counter(16)
```

---

## `__call__` - Making Objects Callable

**Define: `__call__`** - Makes an object callable like a function.

### Basic Example

```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor
    
    def __call__(self, x):
        return x * self.factor

# Create callable object
double = Multiplier(2)
triple = Multiplier(3)

print(double(10))  # 20
print(triple(10))  # 30
```

### With State

```python
class Counter:
    def __init__(self):
        self.count = 0
    
    def __call__(self):
        self.count += 1
        return self.count

counter = Counter()
print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

### Decorator Class

```python
class Timer:
    def __init__(self, func):
        self.func = func
    
    def __call__(self, *args, **kwargs):
        import time
        start = time.time()
        result = self.func(*args, **kwargs)
        end = time.time()
        print(f"{self.func.__name__} took {end - start:.4f}s")
        return result

@Timer
def slow_function():
    import time
    time.sleep(1)
    return "Done"

slow_function()  # Prints timing
```

---

## `__enter__` and `__exit__` - Context Managers

**Define: Context Manager** - Object that manages resources with `with` statement.

### Basic Context Manager

```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """Called when entering 'with' block"""
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Called when exiting 'with' block"""
        if self.file:
            self.file.close()
        # Return False to propagate exceptions
        return False

# Usage
with FileManager('test.txt', 'w') as f:
    f.write('Hello, World!')
# File automatically closed
```

### Database Connection

```python
class DatabaseConnection:
    def __init__(self, db_name):
        self.db_name = db_name
        self.connection = None
    
    def __enter__(self):
        print(f"Connecting to {self.db_name}")
        # Simulate connection
        self.connection = f"Connection to {self.db_name}"
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"Closing connection to {self.db_name}")
        self.connection = None
        return False

with DatabaseConnection('mydb') as conn:
    print(f"Using {conn}")
# Output:
# Connecting to mydb
# Using Connection to mydb
# Closing connection to mydb
```

---

## `__str__` and `__repr__` - String Representations

**Define: `__str__`** - Human-readable string (for users).
**Define: `__repr__`** - Unambiguous representation (for developers).

### Difference Between `__str__` and `__repr__`

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        """Human-readable for print()"""
        return f"{self.name} ({self.age} years old)"
    
    def __repr__(self):
        """Unambiguous for debugging"""
        return f"Person(name='{self.name}', age={self.age})"

person = Person('Alice', 25)

print(str(person))   # Alice (25 years old)
print(repr(person))  # Person(name='Alice', age=25)

print(person)        # Uses __str__
print([person])      # Uses __repr__
```

---

## Comparison Operators

### All Comparison Magic Methods

```python
class Version:
    def __init__(self, major, minor, patch):
        self.major = major
        self.minor = minor
        self.patch = patch
    
    def __eq__(self, other):
        """Equal =="""
        return (self.major, self.minor, self.patch) == (other.major, other.minor, other.patch)
    
    def __ne__(self, other):
        """Not equal !="""
        return not self.__eq__(other)
    
    def __lt__(self, other):
        """Less than <"""
        return (self.major, self.minor, self.patch) < (other.major, other.minor, other.patch)
    
    def __le__(self, other):
        """Less than or equal <="""
        return self.__lt__(other) or self.__eq__(other)
    
    def __gt__(self, other):
        """Greater than >"""
        return not self.__le__(other)
    
    def __ge__(self, other):
        """Greater than or equal >="""
        return not self.__lt__(other)
    
    def __repr__(self):
        return f"Version({self.major}.{self.minor}.{self.patch})"

v1 = Version(1, 0, 0)
v2 = Version(1, 5, 2)
v3 = Version(2, 0, 0)

print(v1 < v2)   # True
print(v2 < v3)   # True
print(v3 > v1)   # True
print(v1 == v1)  # True
```

---

## Arithmetic Operators

### Basic Arithmetic

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        """Addition: v1 + v2"""
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):
        """Subtraction: v1 - v2"""
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar):
        """Multiplication: v * scalar"""
        return Vector(self.x * scalar, self.y * scalar)
    
    def __truediv__(self, scalar):
        """Division: v / scalar"""
        return Vector(self.x / scalar, self.y / scalar)
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(2, 3)
v2 = Vector(1, 1)

print(v1 + v2)   # Vector(3, 4)
print(v1 - v2)   # Vector(1, 2)
print(v1 * 3)    # Vector(6, 9)
print(v1 / 2)    # Vector(1.0, 1.5)
```

### In-place Operators

```python
class Counter:
    def __init__(self, value):
        self.value = value
    
    def __iadd__(self, other):
        """In-place addition: counter += 5"""
        self.value += other
        return self
    
    def __isub__(self, other):
        """In-place subtraction: counter -= 3"""
        self.value -= other
        return self
    
    def __repr__(self):
        return f"Counter({self.value})"

counter = Counter(10)
counter += 5
print(counter)  # Counter(15)

counter -= 3
print(counter)  # Counter(12)
```

---

## `__getitem__` and `__setitem__` - Container Behavior

### Making Objects Subscriptable

```python
class CustomList:
    def __init__(self):
        self.items = []
    
    def __getitem__(self, index):
        """Get item: obj[index]"""
        return self.items[index]
    
    def __setitem__(self, index, value):
        """Set item: obj[index] = value"""
        self.items[index] = value
    
    def __delitem__(self, index):
        """Delete item: del obj[index]"""
        del self.items[index]
    
    def append(self, item):
        self.items.append(item)

lst = CustomList()
lst.append(10)
lst.append(20)
lst.append(30)

print(lst[0])  # 10
lst[1] = 99
print(lst[1])  # 99
del lst[2]
```

### Dictionary-Like Object

```python
class Config:
    def __init__(self):
        self.settings = {}
    
    def __getitem__(self, key):
        return self.settings[key]
    
    def __setitem__(self, key, value):
        self.settings[key] = value
    
    def __delitem__(self, key):
        del self.settings[key]
    
    def __contains__(self, key):
        """Support 'in' operator"""
        return key in self.settings

config = Config()
config['debug'] = True
config['port'] = 8080

print(config['debug'])  # True
print('port' in config)  # True
```

---

## `__len__`, `__contains__` - Collection Protocol

```python
class PlayList:
    def __init__(self):
        self.songs = []
    
    def add(self, song):
        self.songs.append(song)
    
    def __len__(self):
        """len(playlist)"""
        return len(self.songs)
    
    def __contains__(self, song):
        """song in playlist"""
        return song in self.songs
    
    def __iter__(self):
        """for song in playlist"""
        return iter(self.songs)
    
    def __reversed__(self):
        """reversed(playlist)"""
        return reversed(self.songs)

playlist = PlayList()
playlist.add('Song A')
playlist.add('Song B')
playlist.add('Song C')

print(len(playlist))  # 3
print('Song A' in playlist)  # True

for song in playlist:
    print(song)

for song in reversed(playlist):
    print(song)
```

---

## Real-Life Practical Examples

### Example 1: Smart Dictionary

```python
class SmartDict:
    """Dictionary with dot notation access"""
    def __init__(self, data=None):
        self.data = data or {}
    
    def __getitem__(self, key):
        return self.data[key]
    
    def __setitem__(self, key, value):
        self.data[key] = value
    
    def __getattr__(self, key):
        """Access via dot notation: obj.key"""
        try:
            return self.data[key]
        except KeyError:
            raise AttributeError(f"No attribute '{key}'")
    
    def __setattr__(self, key, value):
        if key == 'data':
            super().__setattr__(key, value)
        else:
            self.data[key] = value

config = SmartDict()
config.host = 'localhost'
config.port = 8080

print(config.host)  # localhost
print(config['port'])  # 8080
```

### Example 2: Retry Context Manager

```python
class Retry:
    def __init__(self, max_attempts=3):
        self.max_attempts = max_attempts
        self.attempt = 0
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            self.attempt += 1
            if self.attempt < self.max_attempts:
                print(f"Attempt {self.attempt} failed, retrying...")
                return True  # Suppress exception and retry
        return False  # Propagate exception

# Usage
with Retry(max_attempts=3) as retry:
    # Simulated operation that might fail
    pass
```

---

## Summary

**`__call__`** - Make objects callable  
**`__enter__/__exit__`** - Context managers  
**`__str__/__repr__`** - String representations  
**Comparison operators** - `__eq__`, `__lt__`, etc.  
**Arithmetic operators** - `__add__`, `__sub__`, etc.  
**Container protocol** - `__getitem__`, `__len__`, `__contains__`

---

## Practice Exercises

1. Create callable class that caches results
2. Build context manager for timing code execution
3. Implement comparable `Person` class
4. Create `Money` class with arithmetic operations
5. Build dictionary-like object with validation

---

## What's Next?

**Congratulations!** You've completed Module 9 - Essential Standard Library!

**You've learned:**
- Regular expressions
- DateTime handling
- Logging
- Collections module
- Command-line arguments
- Environment variables
- Copy vs deepcopy
- Enumerations
- Built-in functions
- Magic methods

**Continue your Python journey!** ðŸâœ¨
