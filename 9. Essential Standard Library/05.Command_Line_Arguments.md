# Command-Line Arguments - Building CLI Tools in Python

## Table of Contents
1. [Introduction - Making Scripts Interactive](#introduction---making-scripts-interactive)
2. [sys.argv - Basic Command-Line Arguments](#sysargv---basic-command-line-arguments)
3. [The argparse Module](#the-argparse-module)
4. [Adding Arguments](#adding-arguments)
5. [Argument Types](#argument-types)
6. [Optional Arguments](#optional-arguments)
7. [Positional Arguments](#positional-arguments)
8. [Flags and Booleans](#flags-and-booleans)
9. [Choices and Validation](#choices-and-validation)
10. [Subcommands](#subcommands)
11. [Real-Life Practical Examples](#real-life-practical-examples)
12. [Best Practices](#best-practices)
13. [Summary](#summary)
14. [Practice Exercises](#practice-exercises)
15. [What's Next?](#whats-next)

---

## Introduction - Making Scripts Interactive

**Hard-coded script:**
```python
# greeting.py
name = "World"
print(f"Hello, {name}!")
```

To change the name, you have to edit the code!

**With command-line arguments:**
```bash
python greeting.py Alice
# Hello, Alice!

python greeting.py Bob
# Hello, Bob!
```

**Professional CLI tools:**
- ‚úÖ Flexible without code changes
- ‚úÖ Can be automated in scripts
- ‚úÖ User-friendly help messages
- ‚úÖ Input validation

**In this blog, you'll learn:**
- Basic sys.argv
- argparse for professional CLIs
- Building user-friendly tools
- Validation and error handling

---

## sys.argv - Basic Command-Line Arguments

**Define: sys.argv** - List of command-line arguments passed to script.

### Basic Usage

```python
# script.py
import sys

print(f"Script name: {sys.argv[0]}")
print(f"Arguments: {sys.argv[1:]}")
print(f"All: {sys.argv}")
```

```bash
python script.py arg1 arg2 arg3
# Script name: script.py
# Arguments: ['arg1', 'arg2', 'arg3']
# All: ['script.py', 'arg1', 'arg2', 'arg3']
```

### Simple Greeting Example

```python
# greeting.py
import sys

if len(sys.argv) > 1:
    name = sys.argv[1]
else:
    name = "World"

print(f"Hello, {name}!")
```

```bash
python greeting.py Alice
# Hello, Alice!

python greeting.py
# Hello, World!
```

### Calculator Example

```python
# calc.py
import sys

if len(sys.argv) != 4:
    print("Usage: python calc.py <num1> <operator> <num2>")
    sys.exit(1)

num1 = float(sys.argv[1])
operator = sys.argv[2]
num2 = float(sys.argv[3])

if operator == '+':
    result = num1 + num2
elif operator == '-':
    result = num1 - num2
elif operator == '*':
    result = num1 * num2
elif operator == '/':
    result = num1 / num2
else:
    print(f"Unknown operator: {operator}")
    sys.exit(1)

print(f"{num1} {operator} {num2} = {result}")
```

```bash
python calc.py 10 + 5
# 10.0 + 5.0 = 15.0
```

### Limitations of sys.argv

- ‚ùå Manual parsing
- ‚ùå No automatic help messages
- ‚ùå No type validation
- ‚ùå Hard to handle optional arguments

**Solution: Use argparse!**

---

## The argparse Module

**Define: argparse** - Python's standard library for creating command-line interfaces.

### Basic ArgumentParser

```python
# hello.py
import argparse

# Create parser
parser = argparse.ArgumentParser(description='Greet someone')

# Add argument
parser.add_argument('name', help='Name of person to greet')

# Parse arguments
args = parser.parse_args()

# Use argument
print(f"Hello, {args.name}!")
```

```bash
python hello.py Alice
# Hello, Alice!

python hello.py -h
# usage: hello.py [-h] name
# 
# Greet someone
# 
# positional arguments:
#   name        Name of person to greet
# 
# optional arguments:
#   -h, --help  show this help message and exit
```

---

## Adding Arguments

### Positional Arguments

```python
import argparse

parser = argparse.ArgumentParser()

# Required positional arguments
parser.add_argument('filename', help='File to process')
parser.add_argument('count', type=int, help='Number of times')

args = parser.parse_args()

print(f"Processing {args.filename} {args.count} times")
```

```bash
python script.py data.txt 5
# Processing data.txt 5 times
```

### Optional Arguments

```python
import argparse

parser = argparse.ArgumentParser()

# Optional with short and long form
parser.add_argument('-v', '--verbose', 
                    help='Verbose output',
                    action='store_true')  # Boolean flag

parser.add_argument('-o', '--output',
                    help='Output file',
                    default='output.txt')  # Has default

args = parser.parse_args()

if args.verbose:
    print("Verbose mode ON")
    
print(f"Output will be in: {args.output}")
```

```bash
python script.py
# Output will be in: output.txt

python script.py -v
# Verbose mode ON
# Output will be in: output.txt

python script.py --verbose --output result.txt
# Verbose mode ON
# Output will be in: result.txt
```

---

## Argument Types

### Type Conversion

```python
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--age', type=int, help='Your age')
parser.add_argument('--price', type=float, help='Price')
parser.add_argument('--name', type=str, help='Your name')

args = parser.parse_args()

print(f"Name: {args.name} (type: {type(args.name).__name__})")
print(f"Age: {args.age} (type: {type(args.age).__name__})")
print(f"Price: {args.price} (type: {type(args.price).__name__})")
```

```bash
python script.py --name Alice --age 25 --price 19.99
# Name: Alice (type: str)
# Age: 25 (type: int)
# Price: 19.99 (type: float)
```

### Custom Type Functions

```python
import argparse

def positive_int(value):
    """Custom type for positive integers"""
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError(f"{value} must be positive")
    return ivalue

parser = argparse.ArgumentParser()
parser.add_argument('--count', type=positive_int, help='Positive count')

args = parser.parse_args()
print(f"Count: {args.count}")
```

```bash
python script.py --count 5
# Count: 5

python script.py --count -5
# error: argument --count: -5 must be positive
```

---

## Optional Arguments

### With Defaults

```python
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--port', 
                    type=int,
                    default=8080,
                    help='Port number (default: 8080)')

parser.add_argument('--host',
                    default='localhost',
                    help='Host address (default: localhost)')

args = parser.parse_args()

print(f"Server will run on {args.host}:{args.port}")
```

```bash
python server.py
# Server will run on localhost:8080

python server.py --port 3000 --host 0.0.0.0
# Server will run on 0.0.0.0:3000
```

### Required Optional Arguments

```python
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--config',
                    required=True,  # Optional by syntax, but required!
                    help='Configuration file (required)')

args = parser.parse_args()
```

---

## Flags and Booleans

### Boolean Flags

```python
import argparse

parser = argparse.ArgumentParser()

# True if present
parser.add_argument('--verbose', '-v',
                    action='store_true',
                    help='Enable verbose output')

# False if present
parser.add_argument('--quiet', '-q',
                    action='store_false',
                    dest='verbose',  # Same variable
                    help='Disable verbose output')

# Count occurrences
parser.add_argument('--debug', '-d',
                    action='count',
                    default=0,
                    help='Debug level (use multiple times: -ddd)')

args = parser.parse_args()

print(f"Verbose: {args.verbose}")
print(f"Debug level: {args.debug}")
```

```bash
python script.py -v
# Verbose: True
# Debug level: 0

python script.py -ddd
# Verbose: False
# Debug level: 3
```

---

## Positional Arguments

### Required Positional

```python
import argparse

parser = argparse.ArgumentParser(description='Copy files')

parser.add_argument('source', help='Source file')
parser.add_argument('destination', help='Destination file')

args = parser.parse_args()

print(f"Copying {args.source} to {args.destination}")
```

### Variable Number of Arguments

```python
import argparse

parser = argparse.ArgumentParser()

# One or more
parser.add_argument('files', 
                    nargs='+',  # + means 1 or more
                    help='Files to process')

# Zero or more
parser.add_argument('--tags',
                    nargs='*',  # * means 0 or more
                    help='Optional tags')

# Exactly N
parser.add_argument('--coordinates',
                    nargs=2,  # Exactly 2
                    type=float,
                    help='X and Y coordinates')

args = parser.parse_args()

print(f"Files: {args.files}")
print(f"Tags: {args.tags}")
print(f"Coordinates: {args.coordinates}")
```

```bash
python script.py file1.txt file2.txt --coordinates 10.5 20.3
# Files: ['file1.txt', 'file2.txt']
# Tags: None
# Coordinates: [10.5, 20.3]
```

---

## Choices and Validation

### Limited Choices

```python
import argparse

parser = argparse.ArgumentParser()

parser.add_argument('--format',
                    choices=['json', 'xml', 'csv'],
                    default='json',
                    help='Output format')

parser.add_argument('--log-level',
                    choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
                    default='INFO',
                    help='Logging level')

args = parser.parse_args()

print(f"Format: {args.format}")
print(f"Log level: {args.log_level}")
```

```bash
python script.py --format xml --log-level DEBUG
# Format: xml
# Log level: DEBUG

python script.py --format pdf
# error: argument --format: invalid choice: 'pdf' (choose from 'json', 'xml', 'csv')
```

---

## Subcommands

**Define: Subcommands** - Like git (git add, git commit, git push).

### Creating Subcommands

```python
# git_like.py
import argparse

parser = argparse.ArgumentParser(description='Git-like CLI')

# Create subcommands
subparsers = parser.add_subparsers(dest='command', help='Available commands')

# 'add' subcommand
add_parser = subparsers.add_parser('add', help='Add files')
add_parser.add_argument('files', nargs='+', help='Files to add')

# 'commit' subcommand
commit_parser = subparsers.add_parser('commit', help='Commit changes')
commit_parser.add_argument('-m', '--message', required=True, help='Commit message')

# 'push' subcommand
push_parser = subparsers.add_parser('push', help='Push changes')
push_parser.add_argument('--force', action='store_true', help='Force push')

args = parser.parse_args()

# Handle commands
if args.command == 'add':
    print(f"Adding files: {args.files}")
elif args.command == 'commit':
    print(f"Committing with message: {args.message}")
elif args.command == 'push':
    if args.force:
        print("Force pushing...")
    else:
        print("Pushing...")
```

```bash
python git_like.py add file1.txt file2.txt
# Adding files: ['file1.txt', 'file2.txt']

python git_like.py commit -m "Fixed bug"
# Committing with message: Fixed bug

python git_like.py push --force
# Force pushing...
```

---

## Real-Life Practical Examples

### Example 1: File Converter

```python
# converter.py
import argparse
import os

def main():
    parser = argparse.ArgumentParser(description='Convert file formats')
    
    parser.add_argument('input', help='Input file')
    parser.add_argument('output', help='Output file')
    parser.add_argument('--from-format', required=True, choices=['txt', 'csv', 'json'])
    parser.add_argument('--to-format', required=True, choices=['txt', 'csv', 'json'])
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if args.verbose:
        print(f"Converting {args.input} from {args.from_format} to {args.to_format}")
        print(f"Output will be saved to {args.output}")
    
    # Conversion logic here
    print(f"‚úÖ Conversion complete!")

if __name__ == '__main__':
    main()
```

### Example 2: Backup Tool

```python
# backup.py
import argparse
from datetime import datetime

def main():
    parser = argparse.ArgumentParser(description='Backup files and directories')
    
    parser.add_argument('source', help='Source path')
    parser.add_argument('destination', help='Backup destination')
    parser.add_argument('-c', '--compress', action='store_true', help='Compress backup')
    parser.add_argument('--exclude', nargs='*', help='Patterns to exclude')
    parser.add_argument('-v', '--verbose', action='count', default=0, help='Verbosity level')
    
    args = parser.parse_args()
    
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    backup_name = f"backup_{timestamp}.zip" if args.compress else f"backup_{timestamp}"
    
    if args.verbose >= 1:
        print(f"Backing up {args.source} to {args.destination}/{backup_name}")
        if args.compress:
            print("Compression enabled")
        if args.exclude:
            print(f"Excluding: {args.exclude}")
    
    # Backup logic here
    print("‚úÖ Backup complete!")

if __name__ == '__main__':
    main()
```

### Example 3: Data Processing Pipeline

```python
# process.py
import argparse

def main():
    parser = arg parse.ArgumentParser(description='Data processing pipeline')
   
    subparsers = parser.add_subparsers(dest='command', required=True)
    
    # Clean command
    clean_parser = subparsers.add_parser('clean', help='Clean data')
    clean_parser.add_argument('input', help='Input file')
    clean_parser.add_argument('--remove-duplicates', action='store_true')
    clean_parser.add_argument('--fill-missing', choices=['mean', 'median', 'zero'])
    
    # Transform command
    transform_parser = subparsers.add_parser('transform', help='Transform data')
    transform_parser.add_argument('input', help='Input file')
    transform_parser.add_argument('--normalize', action='store_true')
    transform_parser.add_argument('--scale', type=float)
    
    # Export command
    export_parser = subparsers.add_parser('export', help='Export data')
    export_parser.add_argument('input', help='Input file')
    export_parser.add_argument('--format', choices=['csv', 'json', 'xml'], required=True)
    export_parser.add_argument('-o', '--output', required=True)
    
    args = parser.parse_args()
    
    if args.command == 'clean':
        print(f"Cleaning {args.input}")
        if args.remove_duplicates:
            print("  - Removing duplicates")
        if args.fill_missing:
            print(f"  - Filling missing values with {args.fill_missing}")
    
    elif args.command == 'transform':
        print(f"Transforming {args.input}")
        if args.normalize:
            print("  - Normalizing data")
        if args.scale:
            print(f"  - Scaling by {args.scale}")
    
    elif args.command == 'export':
        print(f"Exporting {args.input} to {args.output} as {args.format}")

if __name__ == '__main__':
    main()
```

---

## Best Practices

### 1. Provide Good Help Messages

```python
parser = argparse.ArgumentParser(
    description='Detailed description of what the tool does',
    epilog='Additional information at the end'
)

parser.add_argument('input',
                    help='Path to input file (supports .txt and .csv)')

parser.add_argument('--timeout',
                    type=int,
                    default=30,
                    help='Connection timeout in seconds (default: 30)')
```

### 2. Use Argument Groups

```python
parser = argparse.ArgumentParser()

# Group related arguments
input_group = parser.add_argument_group('input options')
input_group.add_argument('--input', help='Input file')
input_group.add_argument('--format', help='Input format')

output_group = parser.add_argument_group('output options')
output_group.add_argument('--output', help='Output file')
output_group.add_argument('--compress', action='store_true')
```

### 3. Use Mutually Exclusive Groups

```python
parser = argparse.ArgumentParser()

group = parser.add_mutually_exclusive_group()
group.add_argument('--verbose', action='store_true')
group.add_argument('--quiet', action='store_true')

# User can't use both --verbose and --quiet
```

### 4. Validate Arguments

```python
def validate_args(args):
    """Validate parsed arguments"""
    if args.start_date > args.end_date:
        parser.error("start_date must be before end_date")
    
    if args.threads < 1 or args.threads > 16:
        parser.error("threads must be between 1 and 16")
    
    return args

args = parser.parse_args()
args = validate_args(args)
```

### 5. Use Configuration Files

```python
import argparse
import json

parser = argparse.ArgumentParser()
parser.add_argument('--config', help='Configuration file')
parser.add_argument('--option1', default='default1')
parser.add_argument('--option2', type=int, default=10)

args = parser.parse_args()

# Load config if provided
if args.config:
    with open(args.config) as f:
        config = json.load(f)
        # Override defaults with config
        for key, value in config.items():
            if not hasattr(args, key) or getattr(args, key) == parser.get_default(key):
                setattr(args, key, value)
```

---

## Summary

**üìå sys.argv**
- Simple list of arguments
- Good for basic scripts
- Manual parsing required

**üìå argparse**
- Professional CLI tool
- Automatic help messages
- Type validation
- Better error handling

**üìå Argument Types**
- Positional - required by order
- Optional - prefix with -- or -
- Flags - boolean switches
- Choices - limited options

**üìå Advanced Features**
- Subcommands for complex CLIs
- Custom types and validation
- Argument groups
- Configuration file support

---

## Practice Exercises

### Exercise 1: Calculator CLI
**Task:** Build calculator with add, subtract, multiply, divide commands.

### Exercise 2: File Manager
**Task:** Create tool to list, copy, move, delete files via CLI.

### Exercise 3: JSON/CSV Converter
**Task:** Convert between JSON and CSV formats.

### Exercise 4: Log Analyzer
**Task:** Parse log files with filters for date, level, pattern.

### Exercise 5: Download Manager
**Task:** CLI tool to download files with progress, resume, parallel downloads.

### Exercise 6: Task Manager
**Task:** Add, list, complete, delete tasks from command line.

### Exercise 7: Weather Tool
**Task:** Fetch weather for city with options for units, forecast days.

### Exercise 8: Git-like Tool
**Task:** Create simple version control with init, add, commit, status.

### Exercise 9: Database CLI
**Task:** Query database from command line with filters and output formats.

### Exercise 10: System Monitor
**Task:** Display CPU, memory, disk usage with refresh and alerts.

---

## What's Next?

**Congratulations!** You can now build professional CLI tools!

**In the next blog, you'll learn:**
- Environment variables
- Configuration management
- os.environ and dotenv
- Secure credential handling

**Keep building useful CLI tools!** üíªüõ†Ô∏è

