# Copy vs Deepcopy - Understanding Object Copying in Python

## Table of Contents
1. [Introduction - The Mutation Problem](#introduction---the-mutation-problem)
2. [Assignment vs Copy](#assignment-vs-copy)
3. [Shallow Copy](#shallow-copy)
4. [Deep Copy](#deep-copy)
5. [The copy Module](#the-copy-module)
6. [When to Use Each](#when-to-use-each)
7. [Copying Different Data Types](#copying-different-data-types)
8. [Custom Copy Behavior](#custom-copy-behavior)
9. [Performance Considerations](#performance-considerations)
10. [Real-Life Practical Examples](#real-life-practical-examples)
11. [Common Mistakes to Avoid](#common-mistakes-to-avoid)
12. [Summary](#summary)
13. [Practice Exercises](#practice-exercises)
14. [What's Next?](#whats-next)

---

## Introduction - The Mutation Problem

### The Surprising Bug

```python
# Original list
original = [1, 2, 3]

# Try to make a copy
backup = original

# Modify backup
backup.append(4)

print(original)  # [1, 2, 3, 4] ðŸ˜± ORIGINAL CHANGED!
print(backup)    # [1, 2, 3, 4]
```

**What happened?** Both variables point to the **same object**!

```python
print(id(original))  # 140234567890
print(id(backup))    # 140234567890  (same memory address!)
```

**This blog teaches you:**
- âœ… Assignment vs copying
- âœ… Shallow copy vs deep copy
- âœ… How to copy safely
- âœ… Avoiding mutation bugs

---

## Assignment vs Copy

**Define: Assignment** - Creates new reference to **same object**.

**Define: Copy** - Creates new object with **same content**.

### Assignment (Aliasing)

```python
# Assignment creates alias (same object)
list1 = [1, 2, 3]
list2 = list1  # Just another name for list1

list2.append(4)

print(list1)  # [1, 2, 3, 4]
print(list2)  # [1, 2, 3, 4]

print(list1 is list2)  # True (same object!)
```

**Visual:**
```
list1 â”€â”€â”
        â”œâ”€â”€> [1, 2, 3]
list2 â”€â”€â”˜
```

### True Copy

```python
# Copy creates new object
list1 = [1, 2, 3]
list2 = list1.copy()  # New object with same content

list2.append(4)

print(list1)  # [1, 2, 3] âœ… Original unchanged!
print(list2)  # [1, 2, 3, 4]

print(list1 is list2)  # False (different objects!)
```

**Visual:**
```
list1 â”€â”€> [1, 2, 3]

list2 â”€â”€> [1, 2, 3]  (separate object)
```

---

## Shallow Copy

**Define: Shallow Copy** - Creates new container, but elements are **references** to originals.

### How Shallow Copy Works

```python
import copy

# Nested list
original = [[1, 2], [3, 4]]

# Shallow copy
shallow = copy.copy(original)
# Or: shallow = original.copy()
# Or: shallow = list(original)

# Modify outer list - OK
shallow.append([5, 6])
print(original)  # [[1, 2], [3, 4]] âœ… Unchanged
print(shallow)   # [[1, 2], [3, 4], [5, 6]]

# Modify nested list - PROBLEM!
shallow[0].append(999)
print(original)  # [[1, 2, 999], [3, 4]] ðŸ˜± Changed!
print(shallow)   # [[1, 2, 999], [3, 4], [5, 6]]
```

**Visual:**
```
original â”€â”€> [  â€¢  ,  â€¢  ]
             [1,2]  [3,4]
               â†‘      â†‘
shallow  â”€â”€> [ â€¢  ,  â€¢  , [5,6] ]
```

Inner lists are **shared** between original and shallow!

### Methods That Create Shallow Copies

```python
original = [1, 2, 3]

# Method 1: .copy()
copy1 = original.copy()

# Method 2: list()
copy2 = list(original)

# Method 3: Slicing [:]
copy3 = original[:]

# Method 4: copy.copy()
import copy
copy4 = copy.copy(original)

# All create shallow copies
```

### With Dictionaries

```python
original = {
    'name': 'Alice',
    'scores': [90, 85, 88]
}

# Shallow copy
shallow = original.copy()

# Modify top-level - OK
shallow['age'] = 25
print(original)  # {'name': 'Alice', 'scores': [90, 85, 88]}

# Modify nested list - PROBLEM!
shallow['scores'].append(95)
print(original)  # {'name': 'Alice', 'scores': [90, 85, 88, 95]} ðŸ˜±
```

---

## Deep Copy

**Define: Deep Copy** - Creates new container AND **recursively copies** all nested objects.

### How Deep Copy Works

```python
import copy

# Nested list
original = [[1, 2], [3, 4]]

# Deep copy
deep = copy.deepcopy(original)

# Modify nested list - Safe!
deep[0].append(999)

print(original)  # [[1, 2], [3, 4]] âœ… Unchanged!
print(deep)      # [[1, 2, 999], [3, 4]]
```

**Visual:**
```
original â”€â”€> [  â€¢  ,  â€¢  ]
             [1,2]  [3,4]

deep     â”€â”€> [  â€¢  ,  â€¢  ]
             [1,2]  [3,4]  (completely separate!)
```

### Complex Nested Structures

```python
import copy

person = {
    'name': 'Alice',
    'address': {
        'street': '123 Main St',
        'city': 'NYC',
        'coordinates': [40.7, -74.0]
    },
    'friends': ['Bob', 'Charlie']
}

# Deep copy
person_copy = copy.deepcopy(person)

# Modify nested data
person_copy['address']['city'] = 'LA'
person_copy['address']['coordinates'][0] = 34.0
person_copy['friends'].append('David')

print(person['address']['city'])      # 'NYC' âœ…
print(person['address']['coordinates'])  # [40.7, -74.0] âœ…
print(person['friends'])               # ['Bob', 'Charlie'] âœ…
```

---

## The copy Module

### copy.copy() - Shallow Copy

```python
import copy

original = [1, [2, 3], 4]
shallow = copy.copy(original)

shallow[1].append(999)
print(original)  # [1, [2, 3, 999], 4] ðŸ˜±
```

### copy.deepcopy() - Deep Copy

```python
import copy

original = [1, [2, 3], 4]
deep = copy.deepcopy(original)

deep[1].append(999)
print(original)  # [1, [2, 3], 4] âœ…
```

### Quick Reference

| Method | Creates | Nested Objects |
|--------|---------|----------------|
| `=` | Alias | Same |
| `.copy()` | Shallow copy | Shared |
| `list()` / `dict()` | Shallow copy | Shared |
| `[:]` slicing | Shallow copy | Shared |
| `copy.copy()` | Shallow copy | Shared |
| `copy.deepcopy()` | Deep copy | Independent |

---

## When to Use Each

### Use Assignment (=) When:
```python
# Creating alias for readability
long_variable_name = [1, 2, 3]
lvn = long_variable_name  # Just an alias

# Passing to function (usually safe)
def process(data):
    for item in data:
        print(item)

process(long_variable_name)  # Assignment happens
```

### Use Shallow Copy When:

**1. Flat structures (no nesting):**
```python
numbers = [1, 2, 3, 4, 5]
backup = numbers.copy()  # Shallow is enough
```

**2. Immutable nested objects:**
```python
data = [1, 2, (3, 4), 'hello']  # Tuples and strings are immutable
backup = data.copy()  # Shallow is safe
```

**3. Performance matters and nesting is not modified:**
```python
large_list = list(range(1000000))
copy_for_reading = large_list.copy()  # Fast shallow copy
```

### Use Deep Copy When:

**1. Nested mutable structures:**
```python
matrix = [[1, 2], [3, 4], [5, 6]]
matrix_copy = copy.deepcopy(matrix)
```

**2. Complex objects:**
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

tree = Node(1)
tree.children = [Node(2), Node(3)]
tree_copy = copy.deepcopy(tree)  # Deep copy needed
```

**3. Configuration/state backup:**
```python
original_config = {
    'database': {'host': 'localhost', 'port': 5432},
    'cache': {'enabled': True, 'ttl': 300}
}
config_backup = copy.deepcopy(original_config)
```

---

## Copying Different Data Types

### Lists

```python
import copy

# Flat list - shallow copy is fine
flat = [1, 2, 3]
flat_copy = flat.copy()

# Nested list - need deep copy
nested = [[1, 2], [3, 4]]
nested_copy = copy.deepcopy(nested)
```

### Dictionaries

```python
import copy

# Flat dict - shallow copy is fine
flat_dict = {'a': 1, 'b': 2}
flat_copy = flat_dict.copy()

# Nested dict - need deep copy
nested_dict = {'user': {'name': 'Alice', 'scores': [90, 85]}}
nested_copy = copy.deepcopy(nested_dict)
```

### Sets

```python
import copy

# Sets
original_set = {1, 2, 3}
set_copy = original_set.copy()  # Shallow copy

# Sets with mutable elements don't exist!
# Sets require immutable elements
```

### Custom Objects

```python
import copy

class Person:
    def __init__(self, name, friends):
        self.name = name
        self.friends = friends  # List (mutable)

person1 = Person('Alice', ['Bob', 'Charlie'])

# Shallow copy
person2 = copy.copy(person1)
person2.friends.append('David')
print(person1.friends)  # ['Bob', 'Charlie', 'David'] ðŸ˜±

# Deep copy
person3 = copy.deepcopy(person1)
person3.friends.append('Eve')
print(person1.friends)  # ['Bob', 'Charlie', 'David'] âœ…
```

---

## Custom Copy Behavior

### Implementing __copy__ and __deepcopy__

```python
import copy

class Person:
    def __init__(self, name, age, friends):
        self.name = name
        self.age = age
        self.friends = friends
        self.id = id(self)  # Unique ID
    
    def __copy__(self):
        """Custom shallow copy"""
        print(f"Shallow copying {self.name}")
        # Create new instance without calling __init__
        cls = self.__class__
        new_obj = cls.__new__(cls)
        # Copy attributes
        new_obj.__dict__.update(self.__dict__)
        # Generate new ID
        new_obj.id = id(new_obj)
        return new_obj
    
    def __deepcopy__(self, memo):
        """Custom deep copy"""
        print(f"Deep copying {self.name}")
        cls = self.__class__
        new_obj = cls.__new__(cls)
        # Add to memo to handle circular references
        memo[id(self)] = new_obj
        # Deep copy all attributes
        for key, value in self.__dict__.items():
            if key == 'id':
                # Generate new ID
                setattr(new_obj, key, id(new_obj))
            else:
                setattr(new_obj, key, copy.deepcopy(value, memo))
        return new_obj

# Usage
person = Person('Alice', 30, ['Bob', 'Charlie'])

shallow = copy.copy(person)  # Prints: Shallow copying Alice
deep = copy.deepcopy(person)  # Prints: Deep copying Alice

shallow.friends.append('David')
print(person.friends)  # ['Bob', 'Charlie', 'David']

deep.friends.append('Eve')
print(person.friends)  # ['Bob', 'Charlie', 'David'] âœ…
```

### Preventing Copying

```python
import copy

class Singleton:
    def __copy__(self):
        raise TypeError("Singletons cannot be copied")
    
    def __deepcopy__(self, memo):
        raise TypeError("Singletons cannot be copied")

obj = Singleton()
# copy.copy(obj)  # Raises TypeError
# copy.deepcopy(obj)  # Raises TypeError
```

---

## Performance Considerations

### Timing Comparison

```python
import copy
import time

# Create nested structure
data = [[i for i in range(100)] for _ in range(100)]

# Shallow copy
start = time.time()
shallow = copy.copy(data)
shallow_time = time.time() - start

# Deep copy
start = time.time()
deep = copy.deepcopy(data)
deep_time = time.time() - start

print(f"Shallow copy: {shallow_time:.6f} seconds")
print(f"Deep copy: {deep_time:.6f} seconds")
print(f"Deep copy is {deep_time/shallow_time:.1f}x slower")
```

**Output:**
```
Shallow copy: 0.000012 seconds
Deep copy: 0.001234 seconds
Deep copy is 102.8x slower
```

### Memory Usage

```python
import sys

original = [[1, 2, 3] for _ in range(1000)]

shallow = copy.copy(original)
deep = copy.deepcopy(original)

print(f"Original: {sys.getsizeof(original):,} bytes")
print(f"Shallow:  {sys.getsizeof(shallow):,} bytes")  
print(f"Deep:     {sys.getsizeof(deep):,} bytes (+ nested objects)")
```

---

## Real-Life Practical Examples

### Example 1: Configuration Management

```python
import copy

# Default configuration
DEFAULT_CONFIG = {
    'database': {
        'host': 'localhost',
        'port': 5432,
        'pool_size': 10
    },
    'cache': {
        'enabled': True,
        'ttl': 300
    },
    'logging': {
        'level': 'INFO',
        'handlers': ['console', 'file']
    }
}

def get_config(overrides=None):
    """Get configuration with optional overrides"""
    # Deep copy to avoid modifying default
    config = copy.deepcopy(DEFAULT_CONFIG)
    
    if overrides:
        # Apply overrides
        for key, value in overrides.items():
            if isinstance(value, dict) and key in config:
                config[key].update(value)
            else:
                config[key] = value
    
    return config

# Usage
dev_config = get_config({'database': {'host': 'localhost', 'port': 5433}})
prod_config = get_config({'database': {'host': 'prod.example.com'}})

print(DEFAULT_CONFIG['database']['host'])  # Still 'localhost' âœ…
```

### Example 2: Game State Management

```python
import copy

class GameState:
   def __init__(self):
        self.level = 1
        self.player = {
            'hp': 100,
            'position': [0, 0],
            'inventory': []
        }
        self.enemies = []
    
    def save_checkpoint(self):
        """Save current state"""
        return copy.deepcopy(self.__dict__)
    
    def load_checkpoint(self, checkpoint):
        """Restore saved state"""
        self.__dict__ = copy.deepcopy(checkpoint)

# Usage
game = GameState()
game.player['position'] = [10, 20]
game.player['inventory'].append('sword')

# Save
checkpoint = game.save_checkpoint()

# Continue playing
game.player['hp'] = 50
game.player['position'] = [30, 40]
game.player['inventory'].append('shield')

# Death! Restore checkpoint
game.load_checkpoint(checkpoint)
print(game.player['hp'])  # 100 âœ…
print(game.player['inventory'])  # ['sword'] âœ…
```

### Example 3: Undo/Redo System

```python
import copy

class Document:
    def __init__(self):
        self.content = []
        self.history = []
        self.history_index = -1
    
    def add_line(self, line):
        """Add line with undo support"""
        # Save state before modification
        self._save_state()
        self.content.append(line)
    
    def remove_line(self, index):
        """Remove line with undo support"""
        self._save_state()
        del self.content[index]
    
    def _save_state(self):
        """Save current state for undo"""
        # Remove redo history
        self.history = self.history[:self.history_index + 1]
        # Save deep copy
        self.history.append(copy.deepcopy(self.content))
        self.history_index += 1
    
    def undo(self):
        """Undo last change"""
        if self.history_index > 0:
            self.history_index -= 1
            self.content = copy.deepcopy(self.history[self.history_index])
    
    def redo(self):
        """Redo last undone change"""
        if self.history_index < len(self.history) - 1:
            self.history_index += 1
            self.content = copy.deepcopy(self.history[self.history_index])

# Usage
doc = Document()
doc.add_line("First line")
doc.add_line("Second line")
doc.add_line("Third line")
print(doc.content)  # ['First line', 'Second line', 'Third line']

doc.undo()
print(doc.content)  # ['First line', 'Second line']

doc.redo()
print(doc.content)  # ['First line', 'Second line', 'Third line']
```

---

## Common Mistakes to Avoid

### Mistake 1: Using Assignment Instead of Copy

```python
# âŒ BAD
original = [1, 2, 3]
backup = original
backup.append(4)  # Modifies original!

# âœ… GOOD
original = [1, 2, 3]
backup = original.copy()
backup.append(4)  # Original unchanged
```

### Mistake 2: Shallow Copy for Nested Structures

```python
# âŒ BAD
matrix = [[1, 2], [3, 4]]
matrix_copy = matrix.copy()  # Shallow!
matrix_copy[0].append(999)  # Modifies original!

# âœ… GOOD
import copy
matrix = [[1, 2], [3, 4]]
matrix_copy = copy.deepcopy(matrix)
matrix_copy[0].append(999)  # Original unchanged
```

### Mistake 3: Forgetting import copy

```python
# âŒ BAD
data = [[1, 2], [3, 4]]
# copy.deepcopy(data)  # NameError!

# âœ… GOOD
import copy
data = [[1, 2], [3, 4]]
copy.deepcopy(data)
```

### Mistake 4: Copying Uncopyable Objects

```python
import copy

# File objects can't be deep copied
f = open('file.txt')
data = {'file': f}
# copy.deepcopy(data)  # Error!

# Solution: Don't copy file handles
data_copy = copy.copy(data)  # Shallow copy is OK
```

### Mistake 5: Not Testing for Shared References

```python
# Always test your copies!
original = [[1, 2], [3, 4]]
copied = original.copy()

# Test: Modify and check
copied[0].append(999)
if 999 in original[0]:
    print("ERROR: Shallow copy detected, need deep copy!")
```

---

## Summary

**ðŸ“Œ Assignment ( = )**
- Creates alias to same object
- No copying happens
- Modifications affect original

**ðŸ“Œ Shallow Copy**
- Creates new container
- Nested objects are shared
- Use: `.copy()`, `list()`, `[:]`

**ðŸ“Œ Deep Copy**
- Creates new container
- Recursively copies nested objects
- Use: `copy.deepcopy()`

**ðŸ“Œ When to Use**
- Flat structures â†’ Shallow copy
- Nested structures â†’ Deep copy
- Need performance â†’ Shallow copy
- Need independence â†’ Deep copy

**ðŸ“Œ The copy Module**
- `copy.copy()` - Shallow copy
- `copy.deepcopy()` - Deep copy
- Custom: `__copy__` and `__deepcopy__`

---

## Practice Exercises

### Exercise 1: Copy Tester
**Task:** Function that tests if two objects share references.

### Exercise 2: Safe List Operations
**Task:** Create list class that automatically deep copies on assignment.

### Exercise 3: Configuration Manager
**Task:** Config system with default, environment-specific deep copies.

### Exercise 4: Matrix Calculator
**Task:** Matrix operations that don't modify original matrices.

### Exercise 5: Game Save System
**Task:** Save/load game state with deep copy checkpoint system..

### Exercise 6: Document Version Control
**Task:** Basic version control with copy-based history.

### Exercise 7: Copy Performance Analyzer
**Task:** Measure and compare shallow vs deep copy performance.

### Exercise 8: Circular Reference Handler
**Task:** Deep copy objects with circular references.

### Exercise 9: Smart Copy
**Task:** Function that automatically chooses shallow or deep copy.

### Exercise 10: immutable Wrapper
**Task:** Class that prevents modification of nested mutable objects.

---

## What's Next?

**Congratulations!** You now understand copying in Python!

**In the next blog, you'll learn:**
- Enumerations (Enum)
- Creating named constants
- IntEnum and Flag
- Type-safe enums

**Happy coding!** ðŸâœ¨

