# Collections Module - Advanced Data Structures

## Table of Contents
1. [Introduction - Beyond Basic Collections](#introduction---beyond-basic-collections)
2. [The collections Module](#the-collections-module)
3. [Counter - Counting Things](#counter---counting-things)
4. [defaultdict - Dictionaries with Default Values](#defaultdict---dictionaries-with-default-values)
5. [namedtuple - Tuples with Names](#namedtuple---tuples-with-names)
6. [deque - Double-Ended Queue](#deque---double-ended-queue
)
7. [ChainMap - Multiple Dictionaries](#chainmap---multiple-dictionaries)
8. [OrderedDict - Ordered Dictionary](#ordereddict---ordered-dictionary)
9. [Real-Life Practical Examples](#real-life-practical-examples)
10. [Common Mistakes](#common-mistakes)
11. [Best Practices](#best-practices)
12. [Summary](#summary)
13. [Practice Exercises](#practice-exercises)
14. [What's Next?](#whats-next)

---

## Introduction - Beyond Basic Collections

You know lists, dicts, sets, and tuples. But Python has MORE powerful data structures!

**Real-World Analogy:**
- **Basic tools:** Hammer and screwdriver
- **Collections module:** Power tools for professionals

**Problems Collections Module Solves:**
- âŒ Counting items manually â†’ Use `Counter`
- âŒ Checking if key exists every time â†’ Use `defaultdict`
- âŒ Using indices for named data â†’ Use `namedtuple`
- âŒ Slow list operations at both ends â†’ Use `deque`

**In this blog, you'll learn:**
- Counter for counting
- defaultdict for default values
- namedtuple for simple classes
- deque for efficient queues
- Real-world applications

---

## The collections Module

### Importing

```python
from collections import Counter, defaultdict, namedtuple, deque, ChainMap, OrderedDict
```

### Built-in vs collections Module

| Built-in | collections Alternative | Advantage |
|----------|-------------------------|-----------|
| dict | defaultdict, Counter, OrderedDict | Special behaviors |
| tuple | namedtuple | Named fields |
| list | deque | Fast append/pop from both ends |
| - | ChainMap | Combine multiple dicts |

---

## Counter - Counting Things

**Define: Counter** - Dictionary for counting hashable objects.

### Basic Counter

```python
from collections import Counter

# Count items in a list
fruits = ['apple', 'banana', 'apple', 'orange', 'banana', 'apple']
counter = Counter(fruits)

print(counter)
# Counter({'apple': 3, 'banana': 2, 'orange': 1})

print(counter['apple'])   # 3
print(counter['banana'])  # 2
print(counter['grape'])   # 0 (doesn't raise KeyError!)
```

### Creating Counters

```python
from collections import Counter

# From list
counter1 = Counter(['a', 'b', 'c', 'a', 'b', 'a'])

# From string
counter2 = Counter('abracadabra')
print(counter2)  # Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})

# From dict
counter3 = Counter({'red': 4, 'blue': 2})

# From keyword arguments
counter4 = Counter(cats=4, dogs=8)
```

### Counter Methods

```python
from collections import Counter

votes = Counter({'Alice': 10, 'Bob': 7, 'Charlie': 5, 'Diana': 12})

# most_common(n) - Get n most common
print(votes.most_common(2))
# [('Diana', 12), ('Alice', 10)]

# elements() - Iterator over elements
counter = Counter(a=3, b=2)
print(list(counter.elements()))
# ['a', 'a', 'a', 'b', 'b']

# total() - Sum of all counts (Python 3.10+)
total_votes = sum(votes.values())
print(f"Total votes: {total_votes}")  # 34
```

### Counter Arithmetic

```python
from collections import Counter

# Addition
c1 = Counter(a=3, b=1)
c2 = Counter(a=1, b=2)
print(c1 + c2)  # Counter({'a': 4, 'b': 3})

# Subtraction (removes or reduces)
print(c1 - c2)  # Counter({'a': 2})

# Intersection (minimum)
print(c1 & c2)  # Counter({'a': 1, 'b': 1})

# Union (maximum)
print(c1 | c2)  # Counter({'a': 3, 'b': 2})
```

### Practical Examples

```python
from collections import Counter

# Count word frequency
text = "the quick brown fox jumps over the lazy dog"
words = text.split()
word_count = Counter(words)
print(word_count.most_common(3))
# [('the', 2), ('quick', 1), ('brown', 1)]

# Count letter frequency
letter_count = Counter(text.replace(' ', ''))
print(f"Most common letter: {letter_count.most_common(1)}")

# Find duplicates
numbers = [1, 2, 3, 2, 4, 5, 1, 6, 1]
counter = Counter(numbers)
duplicates = [num for num, count in counter.items() if count > 1]
print(f"Duplicates: {duplicates}")  # [1, 2]
```

---

## defaultdict - Dictionaries with Default Values

**Define: defaultdict** - Dictionary that provides default value for missing keys.

### The Problem defaultdict Solves

```python
# Without defaultdict - repetitive checking
fruit_colors = {}
fruits = [('apple', 'red'), ('banana', 'yellow'), ('apple', 'green')]

for fruit, color in fruits:
    if fruit not in fruit_colors:
        fruit_colors[fruit] = []  # Have to check every time!
    fruit_colors[fruit].append(color)

print(fruit_colors)
# {'apple': ['red', 'green'], 'banana': ['yellow']}
```

### With defaultdict

```python
from collections import defaultdict

# With defaultdict - automatic default!
fruit_colors = defaultdict(list)  # Auto-creates empty list
fruits = [('apple', 'red'), ('banana', 'yellow'), ('apple', 'green')]

for fruit, color in fruits:
    fruit_colors[fruit].append(color)  # No checking needed!

print(dict(fruit_colors))
# {'apple': ['red', 'green'], 'banana': ['yellow']}
```

### Different Default Types

```python
from collections import defaultdict

# Default to list
dd_list = defaultdict(list)
dd_list['key'].append('value')
print(dd_list)  # defaultdict(<class 'list'>, {'key': ['value']})

# Default to int (useful for counting)
dd_int = defaultdict(int)
dd_int['count'] += 1
print(dd_int)  # defaultdict(<class 'int'>, {'count': 1})

# Default to set
dd_set = defaultdict(set)
dd_set['items'].add('apple')
print(dd_set)  # defaultdict(<class 'set'>, {'items': {'apple'}})

# Default to string
dd_str = defaultdict(str)
print(dd_str['missing'])  # '' (empty string)

# Custom default using lambda
dd_custom = defaultdict(lambda: 'NOT FOUND')
print(dd_custom['missing'])  # 'NOT FOUND'
```

### Practical Examples

```python
from collections import defaultdict

# Group by category
items = [
    ('apple', 'fruit'),
    ('carrot', 'vegetable'),
    ('banana', 'fruit'),
    ('broccoli', 'vegetable')
]

grouped = defaultdict(list)
for item, category in items:
    grouped[category].append(item)

print(dict(grouped))
# {'fruit': ['apple', 'banana'], 'vegetable': ['carrot', 'broccoli']}

# Count occurrences
words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
counter = defaultdict(int)
for word in words:
    counter[word] += 1

print(dict(counter))
# {'apple': 3, 'banana': 2, 'cherry': 1}

# Graph adjacency list
graph = defaultdict(list)
edges = [(1, 2), (1, 3), (2, 3), (3, 4)]
for src, dst in edges:
    graph[src].append(dst)

print(dict(graph))
# {1: [2, 3], 2: [3], 3: [4]}
```

---

## namedtuple - Tuples with Names

**Define: namedtuple** - Tuple subclass with named fields (like a simple class).

### The Problem namedtuple Solves

```python
# Regular tuple - hard to remember indices
person = ('John', 30, 'Engineer')
print(person[0])  # What was index 0 again?
print(person[1])  # What was index 1?

# Dictionary - more memory, mutable
person = {'name': 'John', 'age': 30, 'job': 'Engineer'}
person['age'] = 31  # Can be changed (sometimes not wanted)
```

### Creating namedtuples

```python
from collections import namedtuple

# Define a namedtuple type
Person = namedtuple('Person', ['name', 'age', 'job'])

# Create instances
person1 = Person('John', 30, 'Engineer')
person2 = Person('Alice', 25, 'Designer')
person3 = Person(name='Bob', age=35, job='Manager')  # Named arguments

# Access by name (readable!)
print(person1.name)  # John
print(person1.age)   # 30
print(person1.job)   # Engineer

# Also works with indices
print(person1[0])    # John

# Immutable like tuples
#person1.age = 31  # AttributeError!
```

### Alternative Ways to Define Fields

```python
from collections import namedtuple

# Space-separated string
Point = namedtuple('Point', 'x y')

# Comma-separated string
Color = namedtuple('Color', 'red, green, blue')

# List
Person = namedtuple('Person', ['name', 'age'])
```

### namedtuple Methods

```python
from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'city'])
person = Person('Alice', 30, 'NYC')

# _asdict() - Convert to dictionary
print(person._asdict())
# {'name': 'Alice', 'age': 30, 'city': 'NYC'}

# _replace() - Create new instance with changed values
person2 = person._replace(age=31)
print(person2)
# Person(name='Alice', age=31, city='NYC')

# _fields - Get field names
print(Person._fields)
# ('name', 'age', 'city')

# _make() - Create from iterable
data = ['Bob', 25, 'LA']
person3 = Person._make(data)
print(person3)
# Person(name='Bob', age=25, city='LA')
```

### Practical Examples

```python
from collections import namedtuple

# Coordinates
Point = namedtuple('Point', ['x', 'y'])
p1 = Point(10, 20)
p2 = Point(30, 40)

def distance(p1, p2):
    return ((p2.x - p1.x)**2 + (p2.y - p1.y)**2) ** 0.5

print(f"Distance: {distance(p1, p2):.2f}")

# RGB Color
Color = namedtuple('Color', ['red', 'green', 'blue'])
red = Color(255, 0, 0)
green = Color(0, 255, 0)
blue = Color(0, 0, 255)

# CSV data
Student = namedtuple('Student', ['name', 'grade', 'age'])
students = [
    Student('Alice', 'A', 20),
    Student('Bob', 'B', 21),
    Student('Charlie', 'A', 19)
]

# Easy to work with
for student in students:
    print(f"{student.name}: Grade {student.grade}")
```

---

## deque - Double-Ended Queue

**Define: deque** - List optimized for fast append/pop from both ends.

### List vs deque Performance

```python
# List - slow for operations at start
mylist = [1, 2, 3]
mylist.insert(0, 0)  # Slow! Shifts all elements
mylist.pop(0)        # Slow! Shifts all elements

# deque - fast for both ends!
from collections import deque
mydeque = deque([1, 2, 3])
mydeque.appendleft(0)  # Fast!
mydeque.popleft()      # Fast!
```

### Creating and Basic Operations

```python
from collections import deque

# Create deque
dq = deque([1, 2, 3, 4, 5])
print(dq)  # deque([1, 2, 3, 4, 5])

# Append to right (like list)
dq.append(6)
print(dq)  # deque([1, 2, 3, 4, 5, 6])

# Append to left (fast!)
dq.appendleft(0)
print(dq)  # deque([0, 1, 2, 3, 4, 5, 6])

# Pop from right
dq.pop()
print(dq)  # deque([0, 1, 2, 3, 4, 5])

# Pop from left (fast!)
dq.popleft()
print(dq)  # deque([1, 2, 3, 4, 5])
```

### deque Methods

```python
from collections import deque

dq = deque([1, 2, 3, 4, 5])

# extend - add multiple elements
dq.extend([6, 7])
print(dq)  # deque([1, 2, 3, 4, 5, 6, 7])

# extendleft - add multiple to left (reverses order!)
dq.extendleft([-1, 0])
print(dq)  # deque([0, -1, 1, 2, 3, 4, 5, 6, 7])

# rotate - rotate elements
dq = deque([1, 2, 3, 4, 5])
dq.rotate(2)  # Rotate right by 2
print(dq)  # deque([4, 5, 1, 2, 3])

dq.rotate(-2)  # Rotate left by 2
print(dq)  # deque([1, 2, 3, 4, 5])
```

### Maximum Length deque

```python
from collections import deque

# Fixed-size deque (circular buffer)
recent = deque(maxlen=3)

recent.append(1)
recent.append(2)
recent.append(3)
print(recent)  # deque([1, 2, 3], maxlen=3)

recent.append(4)  # Automatically removes oldest
print(recent)  # deque([2, 3, 4], maxlen=3)

recent.append(5)
print(recent)  # deque([3, 4, 5], maxlen=3)
```

### Practical Examples

```python
from collections import deque

# Queue (FIFO)
queue = deque()
queue.append('Task 1')
queue.append('Task 2')
queue.append('Task 3')

while queue:
    task = queue.popleft()  # First In, First Out
    print(f"Processing: {task}")

# Stack (LIFO) using deque
stack = deque()
stack.append('A')
stack.append('B')
stack.append('C')

while stack:
    item = stack.pop()  # Last In, First Out
    print(f"Popped: {item}")

# Recent history tracking
recent_searches = deque(maxlen=5)
searches = ['python', 'java', 'javascript', 'rust', 'go', 'ruby']

for search in searches:
    recent_searches.append(search)
    print(f"Recent: {list(recent_searches)}")

# Last 5: ['java', 'javascript', 'rust', 'go', 'ruby']

# Palindrome checker
def is_palindrome(text):
    dq = deque(text.lower().replace(' ', ''))
    while len(dq) > 1:
        if dq.popleft() != dq.pop():
            return False
    return True

print(is_palindrome("A man a plan a canal Panama"))  # True
print(is_palindrome("hello"))  # False
```

---

## ChainMap - Multiple Dictionaries

**Define: ChainMap** - Groups multiple dicts into single view.

### Basic ChainMap

```python
from collections import ChainMap

# Multiple dictionaries
dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}
dict3 = {'c': 5, 'd': 6}

# Chain them
chain = ChainMap(dict1, dict2, dict3)

# Searches in order (dict1, then dict2, then dict3)
print(chain['a'])  # 1 (from dict1)
print(chain['b'])  # 2 (from dict1, even though dict2 has it)
print(chain['c'])  # 4 (from dict2)
print(chain['d'])  # 6 (from dict3)

# All keys
print(list(chain.keys()))  # ['d', 'c', 'b', 'a']
```

### Practical Use Case - Configuration

```python
from collections import ChainMap

# Configuration with fallbacks
defaults = {
    'theme': 'light',
    'language': 'en',
    'notifications': True
}

user_settings = {
    'theme': 'dark',
    'language': 'es'
}

# User settings override defaults
config = ChainMap(user_settings, defaults)

print(config['theme'])         # 'dark' (from user_settings)
print(config['language'])      # 'es' (from user_settings)
print(config['notifications']) # True (from defaults)
```

---

## OrderedDict - Ordered Dictionary

**Define: OrderedDict** - Dictionary that remembers insertion order.

**Note:** In Python 3.7+, regular dicts are ordered, but OrderedDict has extra features.

### OrderedDict Features

```python
from collections import OrderedDict

# Regular dict vs OrderedDict
od = OrderedDict()
od['b'] = 2
od['a'] = 1
od['c'] = 3

print(od)  # OrderedDict([('b', 2), ('a', 1), ('c', 3)])

# move_to_end() - reorder items
od.move_to_end('b')  # Move 'b' to end
print(od)  # OrderedDict([('a', 1), ('c', 3), ('b', 2)])

od.move_to_end('a', last=False)  # Move 'a' to beginning
print(od)  # OrderedDict([('a', 1), ('c', 3), ('b', 2)])

# popitem() - LIFO or FIFO
od.popitem(last=True)   # Remove from end
od.popitem(last=False)  # Remove from beginning
```

---

## Real-Life Practical Examples

### Example 1: Word Frequency Analysis

```python
from collections import Counter
import re

def analyze_text(text):
    """Analyze text for word frequency"""
    # Clean and split text
    words = re.findall(r'\w+', text.lower())
    
    # Count frequencies
    word_freq = Counter(words)
    
    print(f"Total words: {len(words)}")
    print(f"Unique words: {len(word_freq)}")
    print(f"\nMost common words:")
    for word, count in word_freq.most_common(10):
        print(f"  {word}: {count}")

text = """
Python is an amazing programming language. 
Python is easy to learn and Python is powerful.
Many programmers love Python programming.
"""

analyze_text(text)
```

### Example 2: Group Students by Grade

```python
from collections import defaultdict, namedtuple

Student = namedtuple('Student', ['name', 'grade', 'age'])

students = [
    Student('Alice', 'A', 20),
    Student('Bob', 'B', 21),
    Student('Charlie', 'A', 19),
    Student('Diana', 'C', 22),
    Student('Eve', 'B', 20)
]

# Group by grade
by_grade = defaultdict(list)
for student in students:
    by_grade[student.grade].append(student.name)

for grade, names in sorted(by_grade.items()):
    print(f"Grade {grade}: {', '.join(names)}")
```

### Example 3: Recent Activity Tracker

```python
from collections import deque
from datetime import datetime

class ActivityTracker:
    def __init__(self, max_activities=10):
        self.activities = deque(maxlen=max_activities)
    
    def add_activity(self, activity):
        """Add activity with timestamp"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        self.activities.append(f"[{timestamp}] {activity}")
    
    def show_recent(self):
        """Show recent activities"""
        print("Recent Activities:")
        for activity in self.activities:
            print(f"  {activity}")

# Usage
tracker = ActivityTracker(max_activities=5)
tracker.add_activity("User logged in")
tracker.add_activity("Viewed dashboard")
tracker.add_activity("Edited profile")
tracker.add_activity("Uploaded file")
tracker.add_activity("Logged out")
tracker.add_activity("Logged in again")  # Pushes out oldest

tracker.show_recent()
```

---

## Common Mistakes

### Mistake 1: Modifying defaultdict Without Understanding DefaultWhen iterating, defaultdict creates missing keys:

```python
from collections import defaultdict

dd = defaultdict(int)
dd['existing'] = 5

# âŒ Wrong - just checking creates the key!
for key in ['existing', 'missing']:
    if dd[key] > 0:  #  'missing' now exists with value 0!
        print(key)

# âœ… Correct - use 'in' to check existence
for key in ['existing', 'missing']:
    if key in dd and dd[key] > 0:
        print(key)
```

### Mistake 2: Forgetting namedtuple is Immutable

```python
from collections import namedtuple

Person = namedtuple('Person', ['name', 'age'])
person = Person('Alice', 30)

# âŒ Wrong - can't modify!
#person.age = 31  # AttributeError!

# âœ… Correct - create new instance
person = person._replace(age=31)
```

---

## Best Practices

### 1. Choose Right Data Structure

```python
# Use Counter for counting
from collections import Counter
counts = Counter(['a', 'b', 'a'])  # âœ…

# Use defaultdict to avoid key checking
from collections import defaultdict
groups = defaultdict(list)  # âœ…

# Use namedtuple for simple data classes
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])  # âœ…

# Use deque for queues
from collections import deque
queue = deque()  # âœ…
```

### 2. Use most_common() for Top N

```python
from collections import Counter

counts = Counter(['a', 'b', 'c', 'a', 'b', 'a'])
# âœ… Use most_common instead of sorting
top_3 = counts.most_common(3)
```

---

## Summary

**ğŸ“Œ Counter**
- Count hashtable objects
- `most_common(n)` for top N
- Arithmetic operations

**ğŸ“Œ defaultdict**
- Auto-creates default values
- No key checking needed
- Useful for grouping

**ğŸ“Œ namedtuple**
- Tuple with named fields
- Immutable and memory-efficient
- Good for simple data classes

**ğŸ“Œ deque**
- Fast append/pop from both ends
- Use for queues and stacks
- `maxlen` for circular buffers

**ğŸ“Œ ChainMap**
- Combine multiple dicts
- Good for configurations

---

## Practice Exercises

### Exercise 1: Most Common Words
**Task:** Find 10 most common words in a file.

### Exercise 2: Graph Representation
**Task:** Use defaultdict(list) to represent a graph.

### Exercise 3: Shopping Cart
**Task:** Create a shopping cart using Counter to track quantities.

### Exercise 4: URL History
**Task:** Track last 10 visited URLs using deque.

### Exercise 5: Student Records
**Task:** Use namedtuple for student data (name, id, grade).

### Exercise 6: Configuration System
**Task:** Build configuration with ChainMap (defaults, user, command-line).

### Exercise 7: Leaderboard
**Task:** Use Counter to maintain game leaderboard.

### Exercise 8: Task Queue
**Task:** Create task prioritization system with deque.

### Exercise 9: Palindrome Checker
**Task:** Use deque to efficiently check palindromes.

### Exercise 10: Data Analysis
**Task:** Analyze dataset using multiple collection types.

---

## What's Next?

**Congratulations!** You've learned Python's advanced collections!

**In the next blog, you'll learn:**
- Command-line arguments
- Building CLI tools
- argparse module
- User-friendly CLIs

**Keep practicing with real data!** ğŸ“ŠğŸ”§

