# Regular Expressions - Pattern Matching in Python

## Table of Contents
1. [Introduction - Finding Patterns in Text](#introduction---finding-patterns-in-text)
2. [What are Regular Expressions?](#what-are-regular-expressions)
3. [The re Module](#the-re-module)
4. [Basic Pattern Matching](#basic-pattern-matching)
5. [Special Characters and Metacharacters](#special-characters-and-metacharacters)
6. [Character Classes](#character-classes)
7. [Quantifiers](#quantifiers)
8. [Groups and Capturing](#groups-and-capturing)
9. [Common Regex Patterns](#common-regex-patterns)
10. [Replacing with Regex](#replacing-with-regex)
11. [Regex Flags](#regex-flags)
12. [Real-Life Practical Examples](#real-life-practical-examples)
13. [Common Mistakes](#common-mistakes)
14. [Best Practices](#best-practices)
15. [Summary](#summary)
16. [Practice Exercises](#practice-exercises)
17. [What's Next?](#whats-next)

---

## Introduction - Finding Patterns in Text

Imagine you need to:
- Find all email addresses in a document
- Validate phone numbers
- Extract all URLs from HTML
- Check if a password meets requirements

Would you write complex code with loops and conditions? There's a better way!

**Real-World Analogy:**
- **Without regex:** Searching for a specific book by reading every word
- **With regex:** Using a pattern like "Find all books published in 202X"

**In this blog, you'll learn:**
- Pattern matching with regular expressions
- The `re` module
- Common regex patterns
- Text validation and extraction
- Real-world regex applications

---

## What are Regular Expressions?

**Define: Regular Expression (regex)** - A pattern that describes a set of strings for searching, matching, and replacing text.

### Why Use Regex?

**Without Regex (manual validation):**
```python
def is_valid_email(email):
    if '@' not in email:
        return False
    if email.count('@') != 1:
        return False
    local, domain = email.split('@')
    if not local or not domain:
        return False
    if '.' not in domain:
        return False
    # ... many more checks!
    return True
```

**With Regex:**
```python
import re

def is_valid_email(email):
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))
```

**Benefits:**
- ‚úÖ Concise and powerful
- ‚úÖ Industry standard
- ‚úÖ Handles complex patterns easily
- ‚úÖ Highly optimized

---

## The re Module

Python's `re` module provides regex functionality.

### Importing

```python
import re
```

### Main Functions

| Function | Purpose | Example |
|----------|---------|---------|
| `re.match()` | Match at start of string | Check if string starts with pattern |
| `re.search()` | Search anywhere in string | Find pattern anywhere |
| `re.findall()` | Find all matches | Extract all emails |
| `re.finditer()` | Iterator of matches | Loop through matches |
| `re.sub()` | Replace matches | Replace all phone numbers |
| `re.split()` | Split by pattern | Split on multiple delimiters |

---

## Basic Pattern Matching

### re.match() - Match at Start

```python
import re

# Match returns None if no match
result = re.match(r'hello', 'hello world')
if result:
    print("Matched!")  # Matched!

result = re.match(r'world', 'hello world')
if result:
    print("Matched!")
else:
    print("Not matched!")  # Not matched! (world not at start)
```

### re.search() - Search Anywhere

```python
import re

# Search finds pattern anywhere
result = re.search(r'world', 'hello world')
if result:
    print("Found!")  # Found!
    print(f"Position: {result.start()}-{result.end()}")  # Position: 6-11

# Get the matched text
match = re.search(r'\d+', 'I have 25 apples')
if match:
    print(match.group())  # 25
```

### re.findall() - Find All Matches

```python
import re

text = "My numbers are 10, 25, and 100"

# Find all numbers
numbers = re.findall(r'\d+', text)
print(numbers)  # ['10', '25', '100']

# Find all words
words = re.findall(r'\w+', text)
print(words)  # ['My', 'numbers', 'are', '10', '25', 'and', '100']
```

### re.finditer() - Iterator of Matches

```python
import re

text = "Emails: john@example.com, jane@test.com"

for match in re.finditer(r'\w+@\w+\.\w+', text):
    print(f"Found: {match.group()} at position {match.start()}")

# Output:
# Found: john@example.com at position 8
# Found: jane@test.com at position 26
```

---

## Special Characters and Metacharacters

### Basic Metacharacters

| Character | Meaning | Example |
|-----------|---------|---------|
| `.` | Any character (except newline) | `a.c` matches "abc", "a5c" |
| `^` | Start of string | `^Hello` matches "Hello world" |
| `$` | End of string | `world$` matches "Hello world" |
| `*` | 0 or more | `ab*` matches "a", "ab", "abb" |
| `+` | 1 or more | `ab+` matches "ab", "abb" |
| `?` | 0 or 1 | `colou?r` matches "color", "colour" |
| `|` | OR | `cat|dog` matches "cat" or "dog" |
| `()` | Group | `(ab)+` matches "ab", "abab" |
| `[]` | Character set | `[aeiou]` matches any vowel |
| `\` | Escape special char | `\.` matches literal dot |

### Examples

```python
import re

# Dot (.) - any character
print(re.findall(r'c.t', 'cat cut cot c5t'))  # ['cat', 'cut', 'cot', 'c5t']

# Caret (^) - start of string
print(re.match(r'^Hello', 'Hello World'))  # Match object
print(re.match(r'^World', 'Hello World'))  # None

# Dollar ($) - end of string
print(re.search(r'World$', 'Hello World'))  # Match object
print(re.search(r'Hello$', 'Hello World'))  # None

# Pipe (|) - OR
print(re.findall(r'cat|dog', 'I have a cat and a dog'))  # ['cat', 'dog']
```

---

## Character Classes

### Predefined Character Classes

| Class | Meaning | Equivalent |
|-------|---------|------------|
| `\d` | Digit | `[0-9]` |
| `\D` | Non-digit | `[^0-9]` |
| `\w` | Word character | `[a-zA-Z0-9_]` |
| `\W` | Non-word character | `[^a-zA-Z0-9_]` |
| `\s` | Whitespace | `[ \t\n\r\f\v]` |
| `\S` | Non-whitespace | `[^ \t\n\r\f\v]` |

### Examples

```python
import re

text = "Phone: 123-456-7890"

# \d - digits
print(re.findall(r'\d', text))  # ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0']
print(re.findall(r'\d+', text))  # ['123', '456', '7890']

# \w - word characters
print(re.findall(r'\w+', text))  # ['Phone', '123', '456', '7890']

# \s - whitespace
print(re.findall(r'\s', text))  # [' ']
```

### Custom Character Classes

```python
import re

# [aeiou] - any vowel
print(re.findall(r'[aeiou]', 'hello world'))  # ['e', 'o', 'o']

# [0-9] - any digit
print(re.findall(r'[0-9]', 'Room 101'))  # ['1', '0', '1']

# [a-z] - lowercase letters
print(re.findall(r'[a-z]+', 'Hello World'))  # ['ello', 'orld']

# [a-zA-Z] - any letter
print(re.findall(r'[a-zA-Z]+', 'Hello123World'))  # ['Hello', 'World']

# [^0-9] - NOT a digit
print(re.findall(r'[^0-9]+', 'Room 101'))  # ['Room ', '']

# [a-z0-9] - letters or digits
print(re.findall(r'[a-z0-9]+', 'test123'))  # ['test123']
```

---

## Quantifiers

**Define: Quantifier** - Specifies how many times a pattern should match.

### Quantifier Types

| Quantifier | Meaning | Example |
|------------|---------|---------|
| `*` | 0 or more | `ab*` matches "a", "ab", "abb" |
| `+` | 1 or more | `ab+` matches "ab", "abb" |
| `?` | 0 or 1 | `ab?` matches "a", "ab" |
| `{n}` | Exactly n | `a{3}` matches "aaa" |
| `{n,}` | n or more | `a{2,}` matches "aa", "aaa" |
| `{n,m}` | Between n and m | `a{2,4}` matches "aa", "aaa", "aaaa" |

### Examples

```python
import re

# * - zero or more
print(re.findall(r'ab*', 'a ab abb abbb'))  # ['a', 'ab', 'abb', 'abbb']

# + - one or more
print(re.findall(r'ab+', 'a ab abb abbb'))  # ['ab', 'abb', 'abbb']

# ? - zero or one
print(re.findall(r'colou?r', 'color colour'))  # ['color', 'colour']

# {n} - exactly n
print(re.findall(r'\d{3}', '12 123 1234'))  # ['123', '123']

# {n,} - n or more
print(re.findall(r'\d{2,}', '1 12 123 1234'))  # ['12', '123', '1234']

# {n,m} - between n and m
print(re.findall(r'\d{2,3}', '1 12 123 1234'))  # ['12', '123', '123']
```

### Greedy vs Non-Greedy

```python
import re

text = '<div>First</div><div>Second</div>'

# Greedy (default) - matches as much as possible
print(re.findall(r'<div>.*</div>', text))
# ['<div>First</div><div>Second</div>']

# Non-greedy - matches as little as possible (add ?)
print(re.findall(r'<div>.*?</div>', text))
# ['<div>First</div>', '<div>Second</div>']
```

---

## Groups and Capturing

**Define: Group** - Parentheses `()` create groups that can be extracted separately.

### Basic Groups

```python
import re

# Extract area code and number separately
phone = "Call me at 555-1234"
match = re.search(r'(\d{3})-(\d{4})', phone)

if match:
    print(match.group(0))  # 555-1234 (entire match)
    print(match.group(1))  # 555 (first group)
    print(match.group(2))  # 1234 (second group)
```

### Named Groups

```python
import re

# Named groups for clarity
email = "Contact: john.doe@example.com"
match = re.search(r'(?P<username>[\w.]+)@(?P<domain>[\w.]+)', email)

if match:
    print(match.group('username'))  # john.doe
    print(match.group('domain'))    # example.com
    print(match.groupdict())  # {'username': 'john.doe', 'domain': 'example.com'}
```

### Non-Capturing Groups

```python
import re

# (?:...) - group without capturing
text = "http://example.com and https://test.com"

# Without non-capturing group
matches = re.findall(r'(http|https)://(\w+\.\w+)', text)
print(matches)  # [('http', 'example.com'), ('https', 'test.com')]

# With non-capturing group
matches = re.findall(r'(?:http|https)://(\w+\.\w+)', text)
print(matches)  # ['example.com', 'test.com']
```

---

## Common Regex Patterns

### Email Validation

```python
import re

def is_valid_email(email):
    """Simple email validation"""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

print(is_valid_email("user@example.com"))     # True
print(is_valid_email("invalid.email"))        # False
print(is_valid_email("user@domain"))          # False
```

### Phone Number Validation

```python
import re

def is_valid_phone(phone):
    """US phone number: (123) 456-7890 or 123-456-7890"""
    pattern = r'^(\(\d{3}\)|\d{3})[-\s]?\d{3}[-\s]?\d{4}$'
    return bool(re.match(pattern, phone))

print(is_valid_phone("(555) 123-4567"))   # True
print(is_valid_phone("555-123-4567"))     # True
print(is_valid_phone("555 123 4567"))     # True
print(is_valid_phone("12345"))            # False
```

### URL Extraction

```python
import re

text = """
Visit https://www.example.com and http://test.org
for more information.
"""

urls = re.findall(r'https?://[\w.-]+\.\w+', text)
print(urls)
# ['https://www.example.com', 'http://test.org']
```

### Password Strength Validation

```python
import re

def is_strong_password(password):
    """
    Strong password requirements:
    - At least 8 characters
    - At least one uppercase letter
    - At least one lowercase letter
    - At least one digit
    - At least one special character
    """
    if len(password) < 8:
        return False
    
    has_upper = bool(re.search(r'[A-Z]', password))
    has_lower = bool(re.search(r'[a-z]', password))
    has_digit = bool(re.search(r'\d', password))
    has_special = bool(re.search(r'[!@#$%^&*(),.?":{}|<>]', password))
    
    return has_upper and has_lower and has_digit and has_special

print(is_strong_password("Weak1"))              # False (too short, no special)
print(is_strong_password("Strong123!Pass"))     # True
```

---

## Replacing with Regex

### re.sub() - Substitute Matches

```python
import re

# Basic replacement
text = "I have 3 cats and 5 dogs"
result = re.sub(r'\d+', 'X', text)
print(result)  # I have X cats and X dogs

# Replace with function
def multiply_by_two(match):
    num = int(match.group())
    return str(num * 2)

result = re.sub(r'\d+', multiply_by_two, text)
print(result)  # I have 6 cats and 10 dogs
```

### Using Groups in Replacement

```python
import re

# Swap first and last name
names = "John Doe, Jane Smith"
result = re.sub(r'(\w+) (\w+)', r'\2, \1', names)
print(result)  # Doe, John, Smith, Jane

# Format phone numbers
phones = "Call 5551234567 or 5559876543"
result = re.sub(r'(\d{3})(\d{3})(\d{4})', r'(\1) \2-\3', phones)
print(result)  # Call (555) 123-4567 or (555) 987-6543
```

### Remove Extra Whitespace

```python
import re

text = "Too    many     spaces"

# Replace multiple spaces with single space
result = re.sub(r'\s+', ' ', text)
print(result)  # Too many spaces

# Remove leading/trailing whitespace
result = re.sub(r'^\s+|\s+$', '', '  hello world  ')
print(result)  # hello world
```

---

## Regex Flags

**Define: Flags** - Modify how regex patterns are applied.

### Common Flags

| Flag | Meaning | Example |
|------|---------|---------|
| `re.IGNORECASE` or `re.I` | Case-insensitive | Match "hello" and "HELLO" |
| `re.MULTILINE` or `re.M` | `^` and `$` match line boundaries | Match multiple lines |
| `re.DOTALL` or `re.S` | `.` matches newline | Match across lines |
| `re.VERBOSE` or `re.X` | Allow comments and whitespace | Make patterns readable |

### Examples

```python
import re

# Case-insensitive matching
text = "Hello WORLD hello"
matches = re.findall(r'hello', text, re.IGNORECASE)
print(matches)  # ['Hello', 'hello']

# Multiline mode
text = """Line 1
Line 2
Line 3"""

# Without MULTILINE, ^ only matches string start
matches = re.findall(r'^Line', text)
print(matches)  # ['Line']

# With MULTILINE, ^ matches line start
matches = re.findall(r'^Line', text, re.MULTILINE)
print(matches)  # ['Line', 'Line', 'Line']

# DOTALL - dot matches newline
text = "Hello\nWorld"
match = re.search(r'Hello.World', text, re.DOTALL)
print(match.group() if match else None)  # Hello\nWorld

# VERBOSE - readable patterns
pattern = r'''
    ^                  # Start of string
    [a-zA-Z0-9._%+-]+  # Username
    @                  # @ symbol
    [a-zA-Z0-9.-]+     # Domain name
    \.[a-zA-Z]{2,}     # Top-level domain
    $                  # End of string
'''
email = "test@example.com"
match = re.match(pattern, email, re.VERBOSE)
print("Valid" if match else "Invalid")  # Valid
```

### Combining Flags

```python
import re

# Combine multiple flags with |
pattern = r'^hello'
text = "HELLO\nworld"

match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)
print("Found" if match else "Not found")  # Found
```

---

## Real-Life Practical Examples

### Example 1: Extract Data from Log File

```python
import re

log_text = """
2024-01-15 10:30:45 ERROR: Database connection failed
2024-01-15 10:31:12 INFO: Retrying connection
2024-01-15 10:31:15 ERROR: Connection timeout
2024-01-15 10:32:00 INFO: Successfully connected
"""

# Extract all ERROR messages
errors = re.findall(r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} ERROR: (.+)', log_text)
print("Errors found:")
for error in errors:
    print(f"  - {error}")

# Extract timestamps and levels
pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) (\w+): (.+)'
for match in re.finditer(pattern, log_text):
    timestamp, level, message = match.groups()
    print(f"[{timestamp}] {level}: {message}")
```

### Example 2: Clean and Format Text

```python
import re

def clean_text(text):
    """Clean and normalize text"""
    # Remove extra whitespace
    text = re.sub(r'\s+', ' ', text)
    
    # Remove special characters (keep letters, numbers, spaces)
    text = re.sub(r'[^a-zA-Z0-9\s]', '', text)
    
    # Remove leading/trailing whitespace
    text = text.strip()
    
    return text

messy_text = "Hello!!!   Too   many   $$spaces$$   here..."
print(clean_text(messy_text))
# Hello Too many spaces here
```

### Example 3: Extract Contact Information

```python
import re

resume = """
John Doe
Email: john.doe@example.com
Phone: (555) 123-4567
Website: https://johndoe.com
LinkedIn: https://linkedin.com/in/johndoe
"""

# Extract email
email = re.search(r'[\w.+-]+@[\w-]+\.[\w.-]+', resume)
print(f"Email: {email.group()}" if email else "No email found")

# Extract phone
phone = re.search(r'\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}', resume)
print(f"Phone: {phone.group()}" if phone else "No phone found")

# Extract all URLs
urls = re.findall(r'https?://[\w.-]+(?:/[\w.-]*)*', resume)
print(f"URLs: {urls}")
```

### Example 4: Validate Credit Card Number

```python
import re

def validate_credit_card(card_number):
    """
    Validate credit card format (groups of 4 digits)
    Accepts: 1234-5678-9012-3456 or 1234 5678 9012 3456
    """
    # Remove spaces and dashes
    card_number = re.sub(r'[-\s]', '', card_number)
    
    # Check if 16 digits
    if not re.match(r'^\d{16}$', card_number):
        return False
    
    return True

print(validate_credit_card("1234-5678-9012-3456"))  # True
print(validate_credit_card("1234 5678 9012 3456"))  # True
print(validate_credit_card("1234"))                 # False
```

### Example 5: Parse CSV with Regex

```python
import re

csv_line = 'John Doe,30,"Engineer, Senior",New York'

# Simple split won't work due to comma in quotes
# Use regex to handle quoted fields
fields = re.findall(r'(?:[^,"]|"(?:[^"]|"")*")+', csv_line)
fields = [field.strip(' "') for field in fields]

print(fields)
# ['John Doe', '30', 'Engineer, Senior', 'New York']
```

---

## Common Mistakes

### Mistake 1: Forgetting to Escape Special Characters

```python
import re

# ‚ùå Wrong - dot matches any character
pattern = r'example.com'
text = "example-com"
print(bool(re.search(pattern, text)))  # True (matches!)

# ‚úÖ Correct - escape the dot
pattern = r'example\.com'
text = "example-com"
print(bool(re.search(pattern, text)))  # False
```

### Mistake 2: Not Using Raw Strings

```python
import re

# ‚ùå Wrong - backslash needs escaping
pattern = '\\d+'  # Have to double backslashes!

# ‚úÖ Correct - use raw string
pattern = r'\d+'  # Much cleaner!
```

### Mistake 3: Greedy Matching

```python
import re

html = '<div>First</div><div>Second</div>'

# ‚ùå Greedy - matches too much
result = re.findall(r'<div>.*</div>', html)
print(result)  # ['<div>First</div><div>Second</div>']

# ‚úÖ Non-greedy - use ?
result = re.findall(r'<div>.*?</div>', html)
print(result)  # ['<div>First</div>', '<div>Second</div>']
```

### Mistake 4: Not Validating Match Object

```python
import re

text = "Hello World"

# ‚ùå Wrong - can cause error if no match
# match = re.search(r'Goodbye', text)
# print(match.group())  # AttributeError!

# ‚úÖ Correct - check if match exists
match = re.search(r'Goodbye', text)
if match:
    print(match.group())
else:
    print("No match found")
```

### Mistake 5: Overusing Regex

```python
# ‚ùå Wrong - regex overkill for simple task
import re
result = re.search(r'hello', 'hello world')

# ‚úÖ Correct - use string methods when simpler
result = 'hello' in 'hello world'
```

---

## Best Practices

### 1. Use Raw Strings

```python
# ‚úÖ Always use raw strings for regex patterns
pattern = r'\d{3}-\d{2}-\d{4}'
```

### 2. Compile Patterns for Repeated Use

```python
import re

# ‚úÖ Compile once, use many times (faster!)
email_pattern = re.compile(r'[\w.+-]+@[\w-]+\.[\w.-]+')

emails = ["test@example.com", "invalid", "user@test.com"]
for email in emails:
    if email_pattern.match(email):
        print(f"{email} is valid")
```

### 3. Use Verbose Mode for Complex Patterns

```python
import re

# ‚úÖ Make complex patterns readable
phone_pattern = re.compile(r'''
    ^                  # Start of string
    \(?                # Optional opening parenthesis
    \d{3}              # Area code (3 digits)
    \)?                # Optional closing parenthesis
    [-.\s]?            # Optional separator
    \d{3}              # First 3 digits
    [-.\s]?            # Optional separator
    \d{4}              # Last 4 digits
    $                  # End of string
''', re.VERBOSE)
```

### 4. Name Your Groups

```python
import re

# ‚úÖ Named groups are self-documenting
pattern = r'(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})'
match = re.search(pattern, '2024-01-15')
if match:
    print(f"Year: {match.group('year')}")
```

### 5. Test Your Regex

```python
import re

def test_email_pattern():
    """Test email validation pattern"""
    pattern = r'^[\w.+-]+@[\w-]+\.[\w.-]+$'
    
    valid_emails = [
        "user@example.com",
        "test.user@test.co.uk",
        "user+tag@example.com"
    ]
    
    invalid_emails = [
        "invalid",
        "@example.com",
        "user@",
        "user @example.com"
    ]
    
    for email in valid_emails:
        assert re.match(pattern, email), f"{email} should be valid"
    
    for email in invalid_emails:
        assert not re.match(pattern, email), f"{email} should be invalid"
    
    print("All tests passed!")

test_email_pattern()
```

---

## Summary

### Key Concepts

**üìå Regular Expressions**
- Powerful pattern matching for text
- More concise than manual string manipulation
- Industry standard for validation and extraction

**üìå re Module Functions**
- `match()` - match at start
- `search()` - search anywhere
- `findall()` - find all matches
- `finditer()` - iterate matches
- `sub()` - replace matches

**üìå Metacharacters**
- `.` - any character
- `^` - start, `$` - end
- `*` - 0+, `+` - 1+, `?` - 0 or 1
- `[]` - character class
- `()` - group

**üìå Character Classes**
- `\d` - digit, `\w` - word, `\s` - whitespace
- `[a-z]` - range, `[^...]` - negation

**üìå Best Practices**
- Use raw strings (`r''`)
- Compile for repeated use
- Use verbose mode for readability
- Test your patterns
- Don't overuse regex

---

## Practice Exercises

### Exercise 1: Email Extractor
**Task:** Write a function that extracts all email addresses from a text.

```python
text = """
Contact us at support@example.com or sales@company.com
For urgent matters: urgent@help.org
"""
# Expected: ['support@example.com', 'sales@company.com', 'urgent@help.org']
```

### Exercise 2: Phone Number Formatter
**Task:** Write a function that formats phone numbers to (XXX) XXX-XXXX format.

```python
phones = ["5551234567", "555-123-4567", "555.123.4567"]
# Expected: ["(555) 123-4567", "(555) 123-4567", "(555) 123-4567"]
```

### Exercise 3: Password Validator
**Task:** Create a comprehensive password validator that checks:
- Minimum 8 characters
- At least one uppercase
- At least one lowercase
- At least one digit
- At least one special character
- No spaces

### Exercise 4: URL Parser
**Task:** Extract protocol, domain, and path from URLs.

```python
url = "https://www.example.com/path/to/page?query=value"
# Expected: protocol='https', domain='www.example.com', path='/path/to/page'
```

### Exercise 5: Date Format Converter
**Task:** Convert dates from YYYY-MM-DD to MM/DD/YYYY format.

```python
dates = ["2024-01-15", "2024-12-25", "2023-07-04"]
# Expected: ["01/15/2024", "12/25/2024", "07/04/2023"]
```

### Exercise 6: HTML Tag Remover
**Task:** Remove all HTML tags from text.

```python
html = "<p>Hello <b>World</b>!</p><div>Test</div>"
# Expected: "Hello World!Test"
```

### Exercise 7: Username Validator
**Task:** Validate usernames (3-16 characters, letters/numbers/underscore, no special chars).

### Exercise 8: Extract Hashtags
**Task:** Extract all hashtags from social media text.

```python
tweet = "Learning #Python is fun! #coding #webdev"
# Expected: ['#Python', '#coding', '#webdev']
```

### Exercise 9: IP Address Validator
**Task:** Validate IPv4 addresses (0-255 for each octet).

```python
ips = ["192.168.1.1", "256.1.1.1", "192.168.1"]
# Expected: [True, False, False]
```

### Exercise 10: Word Counter
**Task:** Count occurrences of a word (case-insensitive, whole word only).

```python
text = "The cat sat on the mat. The cat was happy."
word = "cat"
# Expected: 2
```

---

## What's Next?

**Congratulations!** You've mastered regular expressions in Python!

### Next Topics

**In the next blog, you'll learn:**
- Working with datetime
- Handling dates and times
- Time zones and formatting
- Calculating time differences

### Building on This

Regular expressions are used in:
- **Web scraping** - Extract data from HTML
- **Data validation** - Forms, inputs
- **Text processing** - Log analysis, parsing
- **Search engines** - Pattern-based searching

### Continue Learning

- Practice with real-world text data
- Learn regex testing tools (regex101.com)
- Explore advanced patterns
- Combine with file processing

**Keep practicing! Regex is a skill that improves with use!** üöÄ

