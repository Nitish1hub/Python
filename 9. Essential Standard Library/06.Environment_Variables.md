# Environment Variables - Configuration and Secrets Management

## Table of Contents
1. [Introduction - What Are Environment Variables?](#introduction---what-are-environment-variables)
2. [Reading Environment Variables](#reading-environment-variables)
3. [Setting Environment Variables](#setting-environment-variables)
4. [The os.environ Dictionary](#the-osenviron-dictionary)
5. [Default Values and Safety](#default-values-and-safety)
6. [The .env File Pattern](#the-env-file-pattern)
7. [python-dotenv Library](#python-dotenv-library)
8. [Configuration Management](#configuration-management)
9. [Security Best Practices](#security-best-practices)
10. [Real-Life Practical Examples](#real-life-practical-examples)
11. [Common Mistakes to Avoid](#common-mistakes-to-avoid)
12. [Summary](#summary)
13. [Practice Exercises](#practice-exercises)
14. [What's Next?](#whats-next)

---

## Introduction - What Are Environment Variables?

**Define: Environment Variables** - Key-value pairs stored in the operating system that programs can access.

### Why Use Environment Variables?

**‚ùå Hardcoded (BAD):**
```python
# config.py
DATABASE_URL = "postgresql://user:password123@localhost/mydb"
API_KEY = "sk_live_abc123xyz"
```

**Problems:**
- Passwords in source code!
- Can't change config without editing code
- Different settings for dev/staging/production
- Security risk if code is shared

**‚úÖ Environment Variables (GOOD):**
```python
# config.py
import os

DATABASE_URL = os.environ['DATABASE_URL']
API_KEY = os.environ['API_KEY']
```

**Benefits:**
- ‚úÖ No secrets in code
- ‚úÖ Easy to change per environment
- ‚úÖ Secure credential management
- ‚úÖ Follow 12-factor app principles

---

## Reading Environment Variables

### Using os.environ

```python
import os

# Get environment variable (raises KeyError if not found)
home_dir = os.environ['HOME']  # Linux/Mac
# user_profile = os.environ['USERPROFILE']  # Windows

print(f"Home directory: {home_dir}")
```

### Safe Access with get()

```python
import os

# Get with default value (returns None if not found)
debug_mode = os.environ.get('DEBUG')
print(f"Debug mode: {debug_mode}")  # None if not set

# Get with custom default
port = os.environ.get('PORT', '8080')
print(f"Port: {port}")  # '8080' if PORT not set
```

### Using os.getenv() - Same as os.environ.get()

```python
import os

# os.getenv() is alias for os.environ.get()
database_url = os.getenv('DATABASE_URL', 'sqlite:///default.db')
print(f"Database: {database_url}")
```

### Type Conversion

```python
import os

# Environment variables are always strings!
port_str = os.getenv('PORT', '8080')
port = int(port_str)  # Convert to int

debug_str = os.getenv('DEBUG', 'false')
debug = debug_str.lower() == 'true'  # Convert to bool

timeout_str = os.getenv('TIMEOUT', '30.5')
timeout = float(timeout_str)  # Convert to float

print(f"Port: {port} (type: {type(port)})")
print(f"Debug: {debug} (type: {type(debug)})")
print(f"Timeout: {timeout} (type: {type(timeout)})")
```

---

## Setting Environment Variables

### From Python Code

```python
import os

# Set environment variable
os.environ['MY_VAR'] = 'my_value'

# Verify
print(os.environ['MY_VAR'])  # my_value

# Delete environment variable
del os.environ['MY_VAR']

# Or use pop
api_key = os.environ.pop('API_KEY', None)
```

**‚ö†Ô∏è Note:** Changes only affect current process and child processes!

### From Terminal (Linux/Mac)

```bash
# Temporary (current session only)
export DATABASE_URL="postgresql://localhost/mydb"
export DEBUG="true"

# Run Python script
python app.py

# Multiple variables at once
export DATABASE_URL="postgresql://localhost/mydb" DEBUG="true"
```

### From Terminal (Windows)

```batch
REM Temporary (current session)
set DATABASE_URL=postgresql://localhost/mydb
set DEBUG=true

REM Run Python script
python app.py

REM PowerShell
$env:DATABASE_URL="postgresql://localhost/mydb"
$env:DEBUG="true"
```

### Permanent Environment Variables

**Linux/Mac (.bashrc or .zshrc):**
```bash
# Add to ~/.bashrc or ~/.zshrc
export DATABASE_URL="postgresql://localhost/mydb"
export API_KEY="your_key_here"
```

**Windows (System Settings):**
- Search "Environment Variables" in Start menu
- Edit system or user variables
- Add new variables

---

## The os.environ Dictionary

**Define: os.environ** - Dictionary-like object containing all environment variables.

### Dictionary Operations

```python
import os

# Check if variable exists
if 'DATABASE_URL' in os.environ:
    print("Database configured")

# Get all variables
for key, value in os.environ.items():
    print(f"{key} = {value}")

# Get all keys
all_vars = list(os.environ.keys())
print(f"Total environment variables: {len(all_vars)}")

# Copy environment
env_copy = os.environ.copy()
```

### Listing Common Variables

```python
import os

# Common variables
common_vars = ['HOME', 'USER', 'PATH', 'SHELL', 'PWD']

for var in common_vars:
    value = os.environ.get(var, 'Not set')
    print(f"{var}: {value}")
```

**Example output (Linux/Mac):**
```
HOME: /home/username
USER: username
PATH: /usr/local/bin:/usr/bin:/bin
SHELL: /bin/bash
PWD: /home/username/projects
```

---

## Default Values and Safety

### Handling Missing Variables

```python
import os
import sys

def get_required_env(name):
    """Get environment variable or exit if not found"""
    value = os.getenv(name)
    if value is None:
        print(f"ERROR: {name} environment variable is required")
        sys.exit(1)
    return value

def get_env_int(name, default=None):
    """Get environment variable as integer"""
    value = os.getenv(name)
    if value is None:
        return default
    try:
        return int(value)
    except ValueError:
        print(f"WARNING: {name}='{value}' is not a valid integer, using default: {default}")
        return default

# Usage
DATABASE_URL = get_required_env('DATABASE_URL')
PORT = get_env_int('PORT', 8080)
DEBUG = os.getenv('DEBUG', 'false').lower() == 'true'
```

### Config Class Pattern

```python
import os

class Config:
    """Application configuration from environment variables"""
    
    # Required settings
    DATABASE_URL = os.environ['DATABASE_URL']
    SECRET_KEY = os.environ['SECRET_KEY']
    
    # Optional with defaults
    DEBUG = os.getenv('DEBUG', 'false').lower() == 'true'
    PORT = int(os.getenv('PORT', 8080))
    HOST = os.getenv('HOST', 'localhost')
    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
    
    # Computed settings
    DATABASE_ECHO = DEBUG
    
    @classmethod
    def validate(cls):
        """Validate configuration"""
        if cls.PORT < 1 or cls.PORT > 65535:
            raise ValueError(f"Invalid PORT: {cls.PORT}")
        
        if cls.LOG_LEVEL not in ['DEBUG', 'INFO', 'WARNING', 'ERROR']:
            raise ValueError(f"Invalid LOG_LEVEL: {cls.LOG_LEVEL}")

# Usage
Config.validate()
print(f"Starting server on {Config.HOST}:{Config.PORT}")
```

---

## The .env File Pattern

**Define: .env file** - Text file containing key=value pairs for environment variables.

### Creating .env File

```bash
# .env
DATABASE_URL=postgresql://user:pass@localhost/mydb
API_KEY=sk_test_abc123
DEBUG=true
PORT=8080
LOG_LEVEL=INFO
```

### Manual Loading (Without Libraries)

```python
# load_env.py
import os

def load_env(filepath='.env'):
    """Load environment variables from .env file"""
    if not os.path.exists(filepath):
        return
    
    with open(filepath) as f:
        for line in f:
            line = line.strip()
            
            # Skip empty lines and comments
            if not line or line.startswith('#'):
                continue
            
            # Parse key=value
            if '=' in line:
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                # Remove quotes if present
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                # Set only if not already set
                if key not in os.environ:
                    os.environ[key] = value

# Usage
load_env()
database_url = os.getenv('DATABASE_URL')
```

---

## python-dotenv Library

**Define: python-dotenv** - Popular library for loading .env files.

### Installation

```bash
pip install python-dotenv
```

### Basic Usage

```python
from dotenv import load_dotenv
import os

# Load .env file
load_dotenv()

# Now access variables
database_url = os.getenv('DATABASE_URL')
api_key = os.getenv('API_KEY')
debug = os.getenv('DEBUG', 'false').lower() == 'true'

print(f"Database: {database_url}")
print(f"Debug mode: {debug}")
```

### Advanced Features

```python
from dotenv import load_dotenv, find_dotenv, dotenv_values
import os

# Find .env file automatically (searches parent directories)
load_dotenv(find_dotenv())

# Load specific file
load_dotenv('.env.production')

# Load without modifying os.environ (get dict instead)
config = dotenv_values('.env')
print(config)  # {'DATABASE_URL': '...', 'API_KEY': '...'}

# Override existing environment variables
load_dotenv(override=True)

# Multiple .env files (last wins)
load_dotenv('.env')
load_dotenv('.env.local', override=True)  # Override with local settings
```

### .env File Best Practices

```bash
# .env

# Database configuration
DATABASE_URL=postgresql://localhost/mydb
DATABASE_POOL_SIZE=10

# API keys (never commit real keys!)
API_KEY=your_api_key_here
SECRET_KEY=your_secret_key_here

# Application settings
DEBUG=true
LOG_LEVEL=DEBUG
PORT=8080

# External services
REDIS_URL=redis://localhost:6379
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587

# Feature flags
ENABLE_CACHING=true
ENABLE_ANALYTICS=false
```

### .env.example Template

```bash
# .env.example
# Copy this to .env and fill in your values

DATABASE_URL=postgresql://user:password@localhost/dbname
API_KEY=your_api_key
SECRET_KEY=generate_random_secret
DEBUG=false
PORT=8080
```

**In .gitignore:**
```
.env
.env.local
```

---

## Configuration Management

### Different Environments

```python
# config.py
import os
from dotenv import load_dotenv

class Config:
    """Base configuration"""
    load_dotenv()
    
    SECRET_KEY = os.environ['SECRET_KEY']
    DATABASE_URL = os.environ['DATABASE_URL']

class DevelopmentConfig(Config):
    """Development configuration"""
    DEBUG = True
    TESTING = False

class ProductionConfig(Config):
    """Production configuration"""
    DEBUG = False
    TESTING = False

class TestingConfig(Config):
    """Testing configuration"""
    DEBUG = True
    TESTING = True
    DATABASE_URL = 'sqlite:///:memory:'

# Select config based on environment
env = os.getenv('ENVIRONMENT', 'development')

config_map = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'testing': TestingConfig
}

config = config_map.get(env, DevelopmentConfig)
```

### Using Environment-Specific Files

```python
import os
from dotenv import load_dotenv

# Load base .env
load_dotenv('.env')

# Load environment-specific overrides
env = os.getenv('ENVIRONMENT', 'development')
env_file = f'.env.{env}'

if os.path.exists(env_file):
    load_dotenv(env_file, override=True)

print(f"Running in {env} environment")
```

**File structure:**
```
.env                 # Base settings
.env.development     # Development overrides
.env.production      # Production overrides
.env.testing         # Testing overrides
.env.local           # Local developer settings (not committed)
```

---

## Security Best Practices

### 1. Never Commit Secrets

```bash
# .gitignore
.env
.env.local
.env.*.local
*.key
*.pem
secrets.json
```

### 2. Use Environment Variables for Secrets

```python
# ‚ùå BAD - Hardcoded secrets
API_KEY = "sk_live_abc123"
PASSWORD = "password123"

# ‚úÖ GOOD - From environment
API_KEY = os.environ['API_KEY']
PASSWORD = os.environ['PASSWORD']
```

### 3. Validate Required Variables on Startup

```python
import os
import sys

REQUIRED_ENV_VARS = [
    'DATABASE_URL',
    'SECRET_KEY',
    'API_KEY',
]

missing_vars = [var for var in REQUIRED_ENV_VARS if var not in os.environ]

if missing_vars:
    print("ERROR: Missing required environment variables:")
    for var in missing_vars:
        print(f"  - {var}")
    sys.exit(1)
```

### 4. Use Secrets Management Tools

```python
# Example: AWS Secrets Manager
import boto3
import json

def get_secret(secret_name):
    """Get secret from AWS Secrets Manager"""
    client = boto3.client('secretsmanager')
    response = client.get_secret_value(SecretId=secret_name)
    return json.loads(response['SecretString'])

# Get database credentials from AWS
if os.getenv('USE_AWS_SECRETS') == 'true':
    secrets = get_secret('myapp/database')
    DATABASE_URL = secrets['url']
else:
    DATABASE_URL = os.getenv('DATABASE_URL')
```

### 5. Don't Log Sensitive Values

```python
import os
import logging

def safe_config_logging():
    """Log configuration without exposing secrets"""
    config = {
        'DEBUG': os.getenv('DEBUG'),
        'PORT': os.getenv('PORT'),
        'DATABASE_URL': '***' if 'DATABASE_URL' in os.environ else 'Not set',
        'API_KEY': '***' if 'API_KEY' in os.environ else 'Not set',
    }
    
    logging.info(f"Configuration: {config}")
```

---

## Real-Life Practical Examples

### Example 1: Flask Web Application

```python
# app.py
from flask import Flask
from dotenv import load_dotenv
import os

load_dotenv()

app = Flask(__name__)

# Configure from environment
app.config['SECRET_KEY'] = os.environ['SECRET_KEY']
app.config['DATABASE_URL'] = os.environ['DATABASE_URL']
app.config['DEBUG'] = os.getenv('DEBUG', 'false').lower() == 'true'

# External services
app.config['REDIS_URL'] = os.getenv('REDIS_URL')
app.config['EMAIL_HOST'] = os.getenv('EMAIL_HOST')
app.config['SENDGRID_API_KEY'] = os.getenv('SENDGRID_API_KEY')

# Feature flags
app.config['ENABLE_CACHING'] = os.getenv('ENABLE_CACHING', 'true').lower() == 'true'

@app.route('/')
def index():
    return f"Running in {'DEBUG' if app.config['DEBUG'] else 'PRODUCTION'} mode"

if __name__ == '__main__':
    port = int(os.getenv('PORT', 5000))
    app.run(host='0.0.0.0', port=port)
```

### Example 2: Database Connection

```python
# database.py
import os
from sqlalchemy import create_engine
from dotenv import load_dotenv

load_dotenv()

class Database:
    def __init__(self):
        self.url = os.environ['DATABASE_URL']
        self.pool_size = int(os.getenv('DB_POOL_SIZE', 10))
        self.max_overflow = int(os.getenv('DB_MAX_OVERFLOW', 20))
        self.echo = os.getenv('DB_ECHO', 'false').lower() == 'true'
        
        self.engine = create_engine(
            self.url,
            pool_size=self.pool_size,
            max_overflow=self.max_overflow,
            echo=self.echo
        )
    
    def get_connection(self):
        return self.engine.connect()

# Usage
db = Database()
conn = db.get_connection()
```

### Example 3: API Client with Authentication

```python
# api_client.py
import os
import requests
from dotenv import load_dotenv

load_dotenv()

class APIClient:
    def __init__(self):
        self.base_url = os.getenv('API_BASE_URL', 'https://api.example.com')
        self.api_key = os.environ['API_KEY']
        self.timeout = int(os.getenv('API_TIMEOUT', 30))
        
    def _get_headers(self):
        return {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }
    
    def get(self, endpoint):
        url = f"{self.base_url}/{endpoint}"
        response = requests.get(
            url,
            headers=self._get_headers(),
            timeout=self.timeout
        )
        response.raise_for_status()
        return response.json()
    
    def post(self, endpoint, data):
        url = f"{self.base_url}/{endpoint}"
        response = requests.post(
            url,
            headers=self._get_headers(),
            json=data,
            timeout=self.timeout
        )
        response.raise_for_status()
        return response.json()

# Usage
client = APIClient()
data = client.get('users/123')
```

---

## Common Mistakes to Avoid

### Mistake 1: Not Checking if Variable Exists

```python
# ‚ùå BAD - Raises KeyError if not set
database_url = os.environ['DATABASE_URL']

# ‚úÖ GOOD - Returns None if not set
database_url = os.getenv('DATABASE_URL')

# ‚úÖ BETTER - Default value
database_url = os.getenv('DATABASE_URL', 'sqlite:///default.db')
```

### Mistake 2: Forgetting Type Conversion

```python
# ‚ùå BAD - PORT is a string!
PORT = os.getenv('PORT', 8080)  # Returns 8080 as string!

# ‚úÖ GOOD - Convert to int
PORT = int(os.getenv('PORT', 8080))
```

### Mistake 3: Committing .env Files

```bash
# ‚ùå BAD
git add .env
git commit -m "Add configuration"

# ‚úÖ GOOD - Add to .gitignore
echo ".env" >> .gitignore
git add .env.example
git commit -m "Add environment template"
```

### Mistake 4: Not Loading .env File

```python
# ‚ùå BAD - Forgetting to load
import os
api_key = os.getenv('API_KEY')  # None!

# ‚úÖ GOOD - Load first
from dotenv import load_dotenv
load_dotenv()
api_key = os.getenv('API_KEY')
```

### Mistake 5: Modifying os.environ Unnecessarily

```python
# ‚ùå BAD - Don't modify unless necessary
os.environ['MY_VAR'] = 'value'

# ‚úÖ GOOD - Use regular variables
my_var = os.getenv('MY_VAR', 'default')
```

---

## Summary

**üìå Why Environment Variables?**
- Keep secrets out of code
- Different config per environment
- Secure credential management

**üìå Reading Variables**
- `os.environ['KEY']` - Raises error if missing
- `os.getenv('KEY', default)` - Safe with default
- Always convert types (they're strings!)

**üìå .env Files**
- Store variables in `.env` file
- Use `python-dotenv` to load
- Never commit `.env` to git
- Provide `.env.example` template

**üìå Best Practices**
- Validate required variables on startup
- Use different files per environment
- Don't log sensitive values
- Use secrets management for production

---

## Practice Exercises

### Exercise 1: Configuration Class
**Task:** Create Config class that loads all settings from environment with validation.

### Exercise 2: Multi-Environment Setup
**Task:** Support dev/staging/production with environment-specific .env files.

### Exercise 3: Secret Validator
**Task:** Script that checks if all required environment variables are set.

### Exercise 4: Database Connector
**Task:** Create database connection class configured entirely from environment.

### Exercise 5: API Client
**Task:** Build API client with base URL, API key, timeout from environment.

### Exercise 6: Email Sender
**Task:** Email service configured from SMTP settings in environment.

### Exercise 7: Feature Flags
**Task:** Implement feature flag system using environment variables.

### Exercise 8: Config File Generator
**Task:** Generate .env file from template with secure random secrets.

### Exercise 9: Environment Inspector
**Task:** CLI tool to list, search, and validate environment variables.

### Exercise 10: Docker Integration
**Task:** Dockerize app with environment variables passed from compose file.

---

## What's Next?

**Congratulations!** You now understand environment variables and configuration!

**In the next blog, you'll learn:**
- Copy vs Deepcopy
- Shallow and deep copying
- Avoiding mutation bugs
- The copy module

**Keep your secrets safe!** üîíüîê

