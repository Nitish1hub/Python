# Advanced Type System & Reflection - Professional Python Techniques

## Table of Contents
1. [Introduction - Type Safety and Introspection](#introduction---type-safety-and-introspection)
2. [Advanced Generics with TypeVar](#advanced-generics-with-typevar)
3. [Generic Classes](#generic-classes)
4. [Covariance and Contravariance](#covariance-and-contravariance)
5. [Protocol - Structural Subtyping](#protocol---structural-subtyping)
6. [Literal and Final Types](#literal-and-final-types)
7. [TypedDict - Structured Dictionaries](#typeddict---structured-dictionaries)
8. [Reflection and Introspection](#reflection-and-introspection)
9. [Dynamic Attribute Access](#dynamic-attribute-access)
10. [Python Conventions - Discards and Underscores](#python-conventions---discards-and-underscores)
11. [Mixins - Python's Partial Classes](#mixins---pythons-partial-classes)
12. [Dictionary as Anonymous Types](#dictionary-as-anonymous-types)
13. [Real-Life Practical Examples](#real-life-practical-examples)
14. [Best Practices](#best-practices)
15. [Summary](#summary)
16. [Practice Exercises](#practice-exercises)
17. [What's Next?](#whats-next)

---

## Introduction - Type Safety and Introspection

Python is dynamically typed, but modern Python offers powerful tools for type safety and runtime inspection!

**What you'll learn:**
- ‚úÖ Advanced generic types with TypeVar
- ‚úÖ Covariance and Contravariance
- ‚úÖ Protocol for structural typing
- ‚úÖ Reflection and introspection
- ‚úÖ Dynamic attribute manipulation
- ‚úÖ Python conventions and idioms

---

## Advanced Generics with TypeVar

**Define: TypeVar** - Creates type variables for generic programming.

### Basic TypeVar

```python
from typing import TypeVar, List

# Define type variable
T = TypeVar('T')

def first_element(items: List[T]) -> T:
    """Return first element, preserving type"""
    return items[0]

# Type checker knows return type!
numbers = [1, 2, 3]
first_num = first_element(numbers)  # Type: int

strings = ['a', 'b', 'c']
first_str = first_element(strings)  # Type: str
```

### Constrained TypeVar

```python
from typing import TypeVar

# Constrained to specific types
NumberT = TypeVar('NumberT', int, float)

def add_numbers(a: NumberT, b: NumberT) -> NumberT:
    """Add two numbers of same type"""
    return a + b

print(add_numbers(5, 10))      # OK: int
print(add_numbers(5.5, 2.3))   # OK: float
# add_numbers(5, 2.3)          # Error: different types
# add_numbers("a", "b")        # Error: not int or float
```

### Bounded TypeVar

```python
from typing import TypeVar, List

class Animal:
    def speak(self) -> str:
        return "Some sound"

class Dog(Animal):
    def speak(self) -> str:
        return "Woof!"

class Cat(Animal):
    def speak(self) -> str:
        return "Meow!"

# Bounded type variable
AnimalT = TypeVar('AnimalT', bound=Animal)

def make_speak(animal: AnimalT) -> AnimalT:
    """Make animal speak and return it"""
    print(animal.speak())
    return animal

# Works with Animal and subclasses
dog = Dog()
cat = Cat()

make_speak(dog)  # Type: Dog
make_speak(cat)  # Type: Cat
```

### Multiple TypeVars

```python
from typing import TypeVar, Tuple

K = TypeVar('K')
V = TypeVar('V')

def swap_pair(pair: Tuple[K, V]) -> Tuple[V, K]:
    """Swap tuple elements"""
    return (pair[1], pair[0])

# Type preserved
result = swap_pair((1, "hello"))  # Type: Tuple[str, int]
print(result)  # ("hello", 1)
```

---

## Generic Classes

**Define: Generic** - Base class for creating generic types.

### Creating Generic Class

```python
from typing import Generic, TypeVar, List

T = TypeVar('T')

class Stack(Generic[T]):
    """Generic stack implementation"""
    def __init__(self) -> None:
        self._items: List[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> T:
        if not self._items:
            raise IndexError("Stack is empty")
        return self._items.pop()
    
    def peek(self) -> T:
        if not self._items:
            raise IndexError("Stack is empty")
        return self._items[-1]
    
    def is_empty(self) -> bool:
        return len(self._items) == 0

# Use with different types
int_stack = Stack[int]()
int_stack.push(1)
int_stack.push(2)
print(int_stack.pop())  # 2 (Type: int)

str_stack = Stack[str]()
str_stack.push("hello")
str_stack.push("world")
print(str_stack.pop())  # "world" (Type: str)
```

### Generic with Multiple Type Parameters

```python
from typing import Generic, TypeVar, Optional

K = TypeVar('K')
V = TypeVar('V')

class Pair(Generic[K, V]):
    """Generic key-value pair"""
    def __init__(self, key: K, value: V) -> None:
        self.key = key
        self.value = value
    
    def get_key(self) -> K:
        return self.key
    
    def get_value(self) -> V:
        return self.value
    
    def __repr__(self) -> str:
        return f"Pair({self.key!r}, {self.value!r})"

# Different type combinations
pair1 = Pair[str, int]("age", 25)
pair2 = Pair[int, str](1, "first")
pair3 = Pair[str, List[int]]("scores", [90, 85, 88])

print(pair1.get_value())  # Type: int
print(pair2.get_value())  # Type: str
```

### Generic Cache

```python
from typing import Generic, TypeVar, Optional, Callable
from functools import wraps

T = TypeVar('T')

class Cache(Generic[T]):
    """Generic caching system"""
    def __init__(self) -> None:
        self._cache: dict[str, T] = {}
    
    def get(self, key: str) -> Optional[T]:
        return self._cache.get(key)
    
    def set(self, key: str, value: T) -> None:
        self._cache[key] = value
    
    def clear(self) -> None:
        self._cache.clear()

# Type-safe caches
user_cache = Cache[dict]()
user_cache.set("user_123", {"name": "Alice", "age": 25})

number_cache = Cache[int]()
number_cache.set("count", 42)
```

---

## Covariance and Contravariance

**Define: Variance** - How subtyping relationships are preserved in generic types.

### Understanding Variance

Variance determines how type relationships work with generic types:

- **Invariant** (default): No subtype relationship
- **Covariant**: Preserves subtype relationship (for outputs/return types)
- **Contravariant**: Reverses subtype relationship (for inputs/parameters)

```python
# Type hierarchy
class Animal:
    pass

class Dog(Animal):
    pass

class Puppy(Dog):
    pass

# Dog is a subtype of Animal
# Puppy is a subtype of Dog
```

### Invariance (Default Behavior)

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')  # Invariant by default

class Box(Generic[T]):
    def __init__(self, item: T) -> None:
        self.item = item
    
    def get(self) -> T:
        return self.item
    
    def set(self, item: T) -> None:
        self.item = item

# Invariant: Box[Dog] is NOT a subtype of Box[Animal]
def process_animal_box(box: Box[Animal]) -> None:
    box.set(Animal())  # Could set any Animal!

dog_box = Box[Dog](Dog())
# process_animal_box(dog_box)  # Error! Not safe!
# Why? We could set a Cat inside dog_box!
```

### Covariance - Output Types

**Covariant**: When type produces/returns values (read-only).

```python
from typing import TypeVar, Generic

# Covariant type variable
T_co = TypeVar('T_co', covariant=True)

class Producer(Generic[T_co]):
    """Read-only container (producing values)"""
    def __init__(self, item: T_co) -> None:
        self._item = item
    
    def get(self) -> T_co:
        """Only output, no input"""
        return self._item
    
    # No set method! Covariant types are outputs only

# Covariant: Producer[Dog] IS a subtype of Producer[Animal]
def process_animals(producer: Producer[Animal]) -> None:
    animal = producer.get()  # Always safe!
    print(f"Got animal: {animal}")

dog_producer = Producer[Dog](Dog())
process_animals(dog_producer)  # ‚úÖ OK! Covariant

# Why safe? Dog.get() returns Dog, which IS an Animal
```

### Real-World Covariant Example

```python
from typing import TypeVar, Generic, Iterator

T_co = TypeVar('T_co', covariant=True)

class ReadOnlyCollection(Generic[T_co]):
    """Covariant collection (read-only)"""
    def __init__(self, items: list[T_co]) -> None:
        self._items = items.copy()
    
    def __iter__(self) -> Iterator[T_co]:
        return iter(self._items)
    
    def get(self, index: int) -> T_co:
        return self._items[index]
    
    def __len__(self) -> int:
        return len(self._items)

# Type hierarchy
class Shape:
    def area(self) -> float:
        return 0.0

class Circle(Shape):
    def __init__(self, radius: float) -> None:
        self.radius = radius
    
    def area(self) -> float:
        return 3.14 * self.radius ** 2

# Covariant usage
def total_area(shapes: ReadOnlyCollection[Shape]) -> float:
    """Sum areas of shapes"""
    return sum(shape.area() for shape in shapes)

circles = ReadOnlyCollection[Circle]([Circle(5), Circle(10)])
total = total_area(circles)  # ‚úÖ OK! Circle collection as Shape collection
print(f"Total area: {total}")
```

### Contravariance - Input Types

**Contravariant**: When type consumes/accepts values (write-only).

```python
from typing import TypeVar, Generic

# Contravariant type variable
T_contra = TypeVar('T_contra', contravariant=True)

class Consumer(Generic[T_contra]):
    """Write-only container (consuming values)"""
    def __init__(self) -> None:
        self._items: list = []
    
    def add(self, item: T_contra) -> None:
        """Only input, no output"""
        self._items.append(item)
        print(f"Consumed: {item}")
    
    # No get method! Contravariant types are inputs only

# Contravariant: Consumer[Animal] IS a subtype of Consumer[Dog]
def feed_dogs(consumer: Consumer[Dog]) -> None:
    consumer.add(Dog())  # Always safe!

animal_consumer = Consumer[Animal]()
feed_dogs(animal_consumer)  # ‚úÖ OK! Contravariant (reversed!)

# Why safe? Consumer[Animal].add() accepts Dog (Dog IS an Animal)
```

### Real-World Contravariant Example

```python
from typing import TypeVar, Generic, Callable

T_contra = TypeVar('T_contra', contravariant=True)

class Validator(Generic[T_contra]):
    """Validate values (contravariant consumer)"""
    def __init__(self, validate_fn: Callable[[T_contra], bool]) -> None:
        self._validate = validate_fn
    
    def is_valid(self, item: T_contra) -> bool:
        """Consume item for validation"""
        return self._validate(item)

class User:
    def __init__(self, age: int) -> None:
        self.age = age

class AdminUser(User):
    def __init__(self, age: int, permissions: list[str]) -> None:
        super().__init__(age)
        self.permissions = permissions

# Validator for any User
user_validator = Validator[User](lambda u: u.age >= 18)

# Can use User validator for AdminUser (contravariant!)
def check_admin(validator: Validator[AdminUser], admin: AdminUser) -> bool:
    return validator.is_valid(admin)

admin = AdminUser(25, ["read", "write"])
result = check_admin(user_validator, admin)  # ‚úÖ OK! Contravariant
print(f"Valid: {result}")
```

### Variance Rules Summary

```python
# Given: Dog < Animal (Dog is subtype of Animal)

# INVARIANT (default)
Box[Dog] ‚â† Box[Animal]  # No relationship

# COVARIANT (output/return types)
Producer[Dog] < Producer[Animal]  # Preserves relationship
# Use when: Reading/returning values

# CONTRAVARIANT (input/parameter types)
Consumer[Animal] < Consumer[Dog]  # Reverses relationship
# Use when: Accepting/consuming values
```

### Function Variance

```python
from typing import Callable, TypeVar

class Animal:
    def speak(self) -> str:
        return "..."

class Dog(Animal):
    def speak(self) -> str:
        return "Woof"

class Cat(Animal):
    def speak(self) -> str:
        return "Meow"

# Function types are:
# - Contravariant in parameters (input)
# - Covariant in return types (output)

def process_with_function(animals: list[Animal], 
                         fn: Callable[[Animal], Animal]) -> list[Animal]:
    return [fn(animal) for animal in animals]

# Return type: Covariant (Dog < Animal, so OK to return Dog when Animal expected)
def make_dog(animal: Animal) -> Dog:
    return Dog()

# Parameter type: Contravariant (Can accept broader type)
def process_any_object(obj: object) -> Animal:
    return Animal()

animals = [Animal(), Dog(), Cat()]

# Both work due to variance!
result1 = process_with_function(animals, make_dog)  # Return covariant
result2 = process_with_function(animals, process_any_object)  # Param contravariant
```

### Liskov Substitution Principle (LSP)

**LSP**: Subtypes must be substitutable for their base types.

```python
from typing import TypeVar, Generic

T_co = TypeVar('T_co', covariant=True)

class Animal:
    def speak(self) -> str:
        return "Some sound"

class Dog(Animal):
    def speak(self) -> str:
        return "Woof"
    
    def fetch(self) -> str:  # Additional method OK
        return "Fetching..."

# Follows LSP
class AnimalShelter(Generic[T_co]):
    def __init__(self, animals: list[T_co]) -> None:
        self._animals = animals
    
    def get_all(self) -> list[T_co]:
        return self._animals.copy()

def count_animals(shelter: AnimalShelter[Animal]) -> int:
    return len(shelter.get_all())

dog_shelter = AnimalShelter[Dog]([Dog(), Dog()])
count = count_animals(dog_shelter)  # ‚úÖ LSP satisfied
```

### Built-in Covariant Types

```python
from typing import Sequence, Mapping

# Sequence is covariant (read-only)
class Animal:
    pass

class Dog(Animal):
    pass

def process_animals(animals: Sequence[Animal]) -> None:
    """Sequence is covariant"""
    for animal in animals:
        print(animal)

dogs: list[Dog] = [Dog(), Dog()]
process_animals(dogs)  # ‚úÖ OK! list[Dog] -> Sequence[Animal]

# Mapping is covariant in value type
dog_dict: dict[str, Dog] = {"buddy": Dog()}

def show_animals(animals: Mapping[str, Animal]) -> None:
    """Mapping covariant in values"""
    for name, animal in animals.items():
        print(f"{name}: {animal}")

show_animals(dog_dict)  # ‚úÖ OK!
```

### Practical Tips

```python
# ‚úÖ GOOD - Covariant for read-only
from typing import TypeVar, Generic

T_co = TypeVar('T_co', covariant=True)

class ReadOnlyRepo(Generic[T_co]):
    def get_all(self) -> list[T_co]:
        ...

# ‚úÖ GOOD - Contravariant for write-only
T_contra = TypeVar('T_contra', contravariant=True)

class WriteOnlyRepo(Generic[T_contra]):
    def add(self, item: T_contra) -> None:
        ...

# ‚úÖ GOOD - Invariant for read-write
T = TypeVar('T')

class ReadWriteRepo(Generic[T]):
    def get(self) -> T:
        ...
    def set(self, item: T) -> None:
        ...
```

---

## Protocol - Structural Subtyping

**Define: Protocol** - Defines interface based on structure, not inheritance (Python 3.8+).

### Basic Protocol

```python
from typing import Protocol

class Drawable(Protocol):
    """Anything with a draw method"""
    def draw(self) -> str:
        ...

class Circle:
    def draw(self) -> str:
        return "Drawing circle"

class Square:
    def draw(self) -> str:
        return "Drawing square"

# No inheritance needed!
def render(shape: Drawable) -> None:
    print(shape.draw())

# Both work because they have draw() method
circle = Circle()
square = Square()

render(circle)  # OK
render(square)  # OK
```

### Protocol with Properties

```python
from typing import Protocol

class Sized(Protocol):
    """Anything with size property"""
    @property
    def size(self) -> int:
        ...

class Array:
    def __init__(self, items: list) -> None:
        self._items = items
    
    @property
    def size(self) -> int:
        return len(self._items)

class File:
    def __init__(self, path: str) -> None:
        self.path = path
    
    @property
    def size(self) -> int:
        # Would get file size
        return 1024

def print_size(obj: Sized) -> None:
    print(f"Size: {obj.size}")

# Both work!
arr = Array([1, 2, 3])
file = File("test.txt")

print_size(arr)
print_size(file)
```

### Runtime Checkable Protocol

```python
from typing import Protocol, runtime_checkable

@runtime_checkable
class Closeable(Protocol):
    """Anything that can be closed"""
    def close(self) -> None:
        ...

class File:
    def close(self) -> None:
        print("File closed")

class Connection:
    def close(self) -> None:
        print("Connection closed")

# Runtime check
file = File()
print(isinstance(file, Closeable))  # True

# Works with any object that has close()
def cleanup(resource: Closeable) -> None:
    if isinstance(resource, Closeable):
        resource.close()
```

---

## Literal and Final Types

### Literal Types

```python
from typing import Literal

def set_log_level(level: Literal["DEBUG", "INFO", "WARNING", "ERROR"]) -> None:
    """Only accept specific string values"""
    print(f"Log level set to {level}")

set_log_level("DEBUG")     # OK
set_log_level("INFO")      # OK
# set_log_level("TRACE")   # Error: not in Literal

# Multiple types
def open_file(mode: Literal["r", "w", "a", "rb", "wb"]) -> None:
    print(f"Opening file in {mode} mode")

# Boolean literals
def process(flag: Literal[True]) -> None:
    """Only accepts True"""
    print("Processing...")

process(True)   # OK
# process(False) # Error
```

### Final Types

```python
from typing import Final

# Final variable (constant)
MAX_SIZE: Final = 100
PI: Final[float] = 3.14159

# Cannot reassign
# MAX_SIZE = 200  # Error

class Config:
    # Final class variable
    VERSION: Final = "1.0.0"
    
    def __init__(self) -> None:
        # Final instance variable
        self.id: Final = 12345

config = Config()
# config.id = 99999  # Error: cannot reassign
```

---

## TypedDict - Structured Dictionaries

**Define: TypedDict** - Dictionary with defined structure and types (Python 3.8+).

### Basic TypedDict

```python
from typing import TypedDict

class User(TypedDict):
    """User dictionary structure"""
    name: str
    age: int
    email: str

# Type-checked dictionary
user: User = {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com"
}

# Type checker knows structure
print(user["name"])  # OK
# print(user["phone"])  # Error: key doesn't exist
```

### Optional Keys

```python
from typing import TypedDict, NotRequired  # Python 3.11+

class Person(TypedDict):
    name: str
    age: int
    email: NotRequired[str]  # Optional key

# Valid without email
person1: Person = {"name": "Bob", "age": 30}

# Valid with email
person2: Person = {"name": "Alice", "age": 25, "email": "alice@example.com"}
```

### Alternative Optional Syntax (Python 3.8+)

```python
from typing import TypedDict

class Person(TypedDict, total=False):
    """All keys optional"""
    name: str
    age: int
    email: str

# All combinations valid
p1: Person = {}
p2: Person = {"name": "Alice"}
p3: Person = {"name": "Bob", "age": 30, "email": "bob@example.com"}
```

### Nested TypedDict

```python
from typing import TypedDict, List

class Address(TypedDict):
    street: str
    city: str
    zipcode: str

class Employee(TypedDict):
    name: str
    employee_id: int
    address: Address
    skills: List[str]

# Nested structure
employee: Employee = {
    "name": "Charlie",
    "employee_id": 12345,
    "address": {
        "street": "123 Main St",
        "city": "NYC",
        "zipcode": "10001"
    },
    "skills": ["Python", "JavaScript"]
}

print(employee["address"]["city"])  # Type-safe access
```

---

## Reflection and Introspection

**Define: Reflection** - Examining and modifying code at runtime.

### Basic Introspection

```python
# type() - Get object's type
x = 42
print(type(x))  # <class 'int'>

# isinstance() - Check type
print(isinstance(x, int))     # True
print(isinstance(x, str))     # False
print(isinstance(x, (int, float)))  # True (OR check)

# issubclass() - Check inheritance
class Animal:
    pass

class Dog(Animal):
    pass

print(issubclass(Dog, Animal))  # True
print(issubclass(Dog, object))  # True (everything inherits from object)
```

### dir() - List Attributes

```python
class Person:
    def __init__(self, name: str) -> None:
        self.name = name
        self.age = 0
    
    def greet(self) -> str:
        return f"Hello, I'm {self.name}"

person = Person("Alice")

# List all attributes and methods
attributes = dir(person)
print([attr for attr in attributes if not attr.startswith('_')])
# ['age', 'greet', 'name']

# Filter for methods
methods = [attr for attr in dir(person) if callable(getattr(person, attr))]
```

### vars() and __dict__

```python
class Student:
    def __init__(self, name: str, grade: int) -> None:
        self.name = name
        self.grade = grade

student = Student("Bob", 85)

# vars() returns __dict__
print(vars(student))
# {'name': 'Bob', 'grade': 85}

# Direct __dict__ access
print(student.__dict__)
# {'name': 'Bob', 'grade': 85}

# Modify attributes dynamically
student.__dict__['subject'] = 'Math'
print(student.subject)  # 'Math'
```

### Inspect Module

```python
import inspect

class Calculator:
    """A simple calculator"""
    
    def add(self, a: int, b: int) -> int:
        """Add two numbers"""
        return a + b
    
    def multiply(self, a: int, b: int) -> int:
        """Multiply two numbers"""
        return a * b

calc = Calculator()

# Get class docstring
print(inspect.getdoc(Calculator))

# Get method signature
sig = inspect.signature(calc.add)
print(sig)  # (a: int, b: int) -> int

# Get source code
print(inspect.getsource(calc.add))

# Check if callable
print(inspect.ismethod(calc.add))  # True
print(inspect.isfunction(calc.add))  # False (it's a method)

# Get members
for name, obj in inspect.getmembers(calc):
    if inspect.ismethod(obj):
        print(f"Method: {name}")
```

---

## Dynamic Attribute Access

### getattr, setattr, hasattr

```python
class Config:
    def __init__(self) -> None:
        self.debug = False
        self.port = 8080

config = Config()

# hasattr() - Check if attribute exists
if hasattr(config, 'debug'):
    print("Debug mode available")

# getattr() - Get attribute dynamically
port = getattr(config, 'port', 3000)  # Default: 3000
print(port)  # 8080

# Get non-existent with default
timeout = getattr(config, 'timeout', 30)
print(timeout)  # 30

# setattr() - Set attribute dynamically
setattr(config, 'host', 'localhost')
print(config.host)  # 'localhost'

# delattr() - Delete attribute
delattr(config, 'debug')
print(hasattr(config, 'debug'))  # False
```

### Dynamic Method Invocation

```python
class Calculator:
    def add(self, a: int, b: int) -> int:
        return a + b
    
    def subtract(self, a: int, b: int) -> int:
        return a - b
    
    def multiply(self, a: int, b: int) -> int:
        return a * b

calc = Calculator()

# Get method by name
operation = "add"
method = getattr(calc, operation)

# Call dynamically
result = method(10, 5)
print(f"{operation}: {result}")  # add: 15

# Process multiple operations
operations = ["add", "subtract", "multiply"]
for op in operations:
    method = getattr(calc, op)
    print(f"{op}(10, 3) = {method(10, 3)}")
```

### Property Introspection

```python
class User:
    def __init__(self, name: str) -> None:
        self._name = name
    
    @property
    def name(self) -> str:
        return self._name
    
    @name.setter
    def name(self, value: str) -> None:
        self._name = value

user = User("Alice")

# Check if it's a property
print(isinstance(type(user).name, property))  # True

# Get property object
prop = type(user).name
print(f"Has getter: {prop.fget is not None}")
print(f"Has setter: {prop.fset is not None}")
```

---

## Python Conventions - Discards and Underscores

### Underscore (_) as Discard

```python
# Ignore values in unpacking
name, _, age = ("Alice", "unused", 25)
print(f"{name} is {age}")  # Alice is 25

# Ignore in loops
for _ in range(5):
    print("Hello")

# Ignore multiple values
first, *_, last = [1, 2, 3, 4, 5]
print(f"First: {first}, Last: {last}")  # First: 1, Last: 5

# Ignore in tuple unpacking
point = (10, 20, 30)
x, _, _ = point
print(f"X: {x}")  # X: 10

# Multiple discards
data = ("Alice", 25, "NYC", "Engineer", "Female")
name, age, *_, gender = data
print(f"{name}, {age}, {gender}")  # Alice, 25, Female
```

### Single Underscore (_) Convention

```python
class BankAccount:
    def __init__(self, balance: float) -> None:
        self._balance = balance  # "Internal use" convention
    
    def get_balance(self) -> float:
        return self._balance

# _balance is accessible but conventionally private
account = BankAccount(1000)
print(account._balance)  # Works, but discouraged
```

### Double Underscore (__) Name Mangling

```python
class Secret:
    def __init__(self) -> None:
        self.__secret = "hidden"  # Name mangled
    
    def reveal(self) -> str:
        return self.__secret

secret = Secret()
# print(secret.__secret)  # AttributeError
print(secret.reveal())    # "hidden"

# Actual name after mangling
print(secret._Secret__secret)  # "hidden" (name mangled)
```

### Underscore in REPL

```python
# In Python REPL/Jupyter
>>> 5 + 3
8
>>> _ * 2  # _ holds last result
16
>>> _
16
```

### Numeric Literals with Underscores

```python
# Improve readability
million = 1_000_000
byte_size = 1_024
credit_card = 1234_5678_9012_3456

print(million)  # 1000000
print(f"{byte_size:,}")  # 1,024
```

---

## Mixins - Python's Partial Classes

**Define: Mixin** - Small class that provides specific functionality (Python's alternative to partial classes).

### Basic Mixin

```python
class JsonMixin:
    """Mixin for JSON serialization"""
    def to_json(self) -> str:
        import json
        return json.dumps(self.__dict__)
    
    @classmethod
    def from_json(cls, json_str: str):
        import json
        data = json.loads(json_str)
        return cls(**data)

class LoggingMixin:
    """Mixin for logging"""
    def log(self, message: str) -> None:
        print(f"[{self.__class__.__name__}] {message}")

class User(JsonMixin, LoggingMixin):
    """User with JSON and logging capabilities"""
    def __init__(self, name: str, email: str) -> None:
        self.name = name
        self.email = email

# Use mixin methods
user = User("Alice", "alice@example.com")
user.log("User created")

json_str = user.to_json()
print(json_str)  # {"name": "Alice", "email": "alice@example.com"}

# Recreate from JSON
user2 = User.from_json(json_str)
print(user2.name)  # Alice
```

### Timestamp Mixin

```python
from datetime import datetime

class TimestampMixin:
    """Add timestamp tracking"""
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def touch(self) -> None:
        """Update timestamp"""
        self.updated_at = datetime.now()

class ValidationMixin:
    """Add validation"""
    def validate(self) -> bool:
        """Override in subclass"""
        return True
    
    def is_valid(self) -> bool:
        try:
            return self.validate()
        except Exception:
            return False

class Article(TimestampMixin, ValidationMixin):
    def __init__(self, title: str, content: str) -> None:
        super().__init__()
        self.title = title
        self.content = content
    
    def validate(self) -> bool:
        return bool(self.title and self.content)

# Use combined functionality
article = Article("Python Tips", "Learn Python...")
print(f"Created: {article.created_at}")
print(f"Valid: {article.is_valid()}")

article.touch()
print(f"Updated: {article.updated_at}")
```

### Multiple Mixins Pattern

```python
class SerializeMixin:
    """Serialization capabilities"""
    def to_dict(self) -> dict:
        return {k: v for k, v in self.__dict__.items() if not k.startswith('_')}

class CompareMixin:
    """Comparison capabilities"""
    def __eq__(self, other) -> bool:
        if not isinstance(other, self.__class__):
            return False
        return self.__dict__ == other.__dict__

class CopyMixin:
    """Copying capabilities"""
    def copy(self):
        import copy
        return copy.deepcopy(self)

class Product(SerializeMixin, CompareMixin, CopyMixin):
    def __init__(self, name: str, price: float) -> None:
        self.name = name
        self.price = price

# All mixin functionality available
p1 = Product("Widget", 19.99)
p2 = Product("Widget", 19.99)

print(p1 == p2)  # True (CompareMixin)
print(p1.to_dict())  # {'name': 'Widget', 'price': 19.99} (SerializeMixin)

p3 = p1.copy()  # CopyMixin
p3.price = 24.99
print(p1.price)  # 19.99 (unchanged)
```

---

## Dictionary as Anonymous Types

**Python Alternative:** Use dictionaries or SimpleNamespace for lightweight data structures.

### Dictionary as Data Container

```python
# Anonymous type (C# style) ‚Üí Python dict
user = {
    "name": "Alice",
    "age": 25,
    "email": "alice@example.com"
}

# Type-safe with TypedDict
from typing import TypedDict

class UserDict(TypedDict):
    name: str
    age: int
    email: str

def process_user(user: UserDict) -> None:
    print(f"{user['name']} ({user['age']})")

process_user(user)
```

### SimpleNamespace - Dot Access

```python
from types import SimpleNamespace

# Create anonymous object with dot access
person = SimpleNamespace(
    name="Bob",
    age=30,
    city="NYC"
)

print(person.name)  # Dot access like object!
print(person.age)

# Add attributes dynamically
person.occupation = "Developer"
print(person.occupation)

# Convert dict to SimpleNamespace
data = {"x": 10, "y": 20}
point = SimpleNamespace(**data)
print(f"Point: ({point.x}, {point.y})")
```

### Dataclass for Structured Data

```python
from dataclasses import dataclass

@dataclass
class Point:
    """Lightweight data container"""
    x: float
    y: float
    
    def distance_from_origin(self) -> float:
        return (self.x**2 + self.y**2) ** 0.5

# Clean syntax
point = Point(3, 4)
print(point.distance_from_origin())  # 5.0
```

### Factory Functions for Anonymous Types

```python
def create_response(status: int, message: str, data=None):
    """Factory for response objects"""
    from types import SimpleNamespace
    
    return SimpleNamespace(
        status=status,
        message=message,
        data=data or {},
        is_success=lambda: 200 <= status < 300
    )

# Use like anonymous type
response = create_response(200, "OK", {"user": "Alice"})
print(response.message)  # OK
print(response.is_success())  # True
```

---

## Real-Life Practical Examples

### Example 1: Generic Repository Pattern

```python
from typing import Generic, TypeVar, List, Optional
from dataclasses import dataclass

T = TypeVar('T')

class Repository(Generic[T]):
    """Generic data repository"""
    def __init__(self) -> None:
        self._items: List[T] = []
        self._id_counter = 0
    
    def add(self, item: T) -> T:
        if hasattr(item, 'id'):
            setattr(item, 'id', self._id_counter)
            self._id_counter += 1
        self._items.append(item)
        return item
    
    def get_all(self) -> List[T]:
        return self._items.copy()
    
    def find_by_id(self, item_id: int) -> Optional[T]:
        for item in self._items:
            if hasattr(item, 'id') and getattr(item, 'id') == item_id:
                return item
        return None

@dataclass
class User:
    name: str
    email: str
    id: int = 0

@dataclass
class Product:
    name: str
    price: float
    id: int = 0

# Type-safe repositories
user_repo = Repository[User]()
user_repo.add(User("Alice", "alice@example.com"))
user_repo.add(User("Bob", "bob@example.com"))

product_repo = Repository[Product]()
product_repo.add(Product("Widget", 19.99))

print(user_repo.get_all())
```

### Example 2: Plugin System with Protocols

```python
from typing import Protocol, List
import importlib
import inspect

class Plugin(Protocol):
    """Plugin interface using Protocol"""
    name: str
    version: str
    
    def initialize(self) -> None:
        ...
    
    def execute(self, data: dict) -> dict:
        ...

class PluginManager:
    """Manage plugins dynamically"""
    def __init__(self) -> None:
        self.plugins: List[Plugin] = []
    
    def register(self, plugin: Plugin) -> None:
        plugin.initialize()
        self.plugins.append(plugin)
        print(f"Registered: {plugin.name} v{plugin.version}")
    
    def execute_all(self, data: dict) -> dict:
        for plugin in self.plugins:
            data = plugin.execute(data)
        return data

# Example plugin (no inheritance needed!)
class LoggingPlugin:
    name = "Logger"
    version = "1.0.0"
    
    def initialize(self) -> None:
        print("Logging plugin initialized")
    
    def execute(self, data: dict) -> dict:
        print(f"Processing: {data}")
        return data

class ValidationPlugin:
    name = "Validator"
    version = "1.0.0"
    
    def initialize(self) -> None:
        print("Validation plugin initialized")
    
    def execute(self, data: dict) -> dict:
        if 'user' not in data:
            raise ValueError("Missing user")
        return data

# Use plugin system
manager = PluginManager()
manager.register(LoggingPlugin())
manager.register(ValidationPlugin())

result = manager.execute_all({"user": "Alice", "action": "login"})
```

### Example 3: Dynamic Configuration with Reflection

```python
import os
from typing import Any

class DynamicConfig:
    """Load configuration from environment with type hints"""
    
    def __init__(self) -> None:
        self._load_from_annotations()
    
    def _load_from_annotations(self) -> None:
        """Load config from type hints"""
        for attr, hint in self.__annotations__.items():
            env_var = attr.upper()
            value = os.getenv(env_var)
            
            if value is None:
                # Use default if exists
                if hasattr(self, attr):
                    continue
                raise ValueError(f"Missing required config: {env_var}")
            
            # Convert to correct type
            typed_value = self._convert_type(value, hint)
            setattr(self, attr, typed_value)
    
    def _convert_type(self, value: str, hint: type) -> Any:
        """Convert string to hinted type"""
        if hint == bool:
            return value.lower() in ('true', '1', 'yes')
        elif hint == int:
            return int(value)
        elif hint == float:
            return float(value)
        return value
    
    def __repr__(self) -> str:
        attrs = {k: v for k, v in vars(self).items() if not k.startswith('_')}
        return f"{self.__class__.__name__}({attrs})"

class AppConfig(DynamicConfig):
    """Application configuration"""
    debug: bool = False
    port: int = 8080
    host: str = "localhost"
    timeout: float = 30.0

# Set environment variables
os.environ['DEBUG'] = 'true'
os.environ['PORT'] = '3000'

# Auto-load from environment
config = AppConfig()
print(config)  # Shows typed values
print(f"Debug: {config.debug}")  # bool
print(f"Port: {config.port}")    # int
```

---

## Best Practices

### 1. Use Type Hints for API Boundaries

```python
# ‚úÖ GOOD - Clear types at boundaries
def process_user_data(user_id: int, data: dict[str, Any]) -> bool:
    """Type hints on public functions"""
    pass

# Internal functions can be less strict
def _helper(x):
    """Private helper, type hints optional"""
    pass
```

### 2. Protocol Over ABC

```python
# ‚úÖ GOOD - Protocol (structural)
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> str: ...

# ‚ùå Less flexible - ABC (nominal)
from abc import ABC, abstractmethod

class Drawable(ABC):
    @abstractmethod
    def draw(self) -> str: ...
```

### 3. TypeVar with Bounds

```python
# ‚úÖ GOOD - Bounded TypeVar
from typing import TypeVar

T = TypeVar('T', bound='BaseClass')

# ‚ùå BAD - Unconstrained when you know the type
T = TypeVar('T')  # Too permissive
```

### 4. Use TypedDict for Structured Data

```python
# ‚úÖ GOOD - TypedDict for API responses
from typing import TypedDict

class UserResponse(TypedDict):
    id: int
    name: str
    email: str

# ‚ùå BAD - Plain dict (no type checking)
def get_user() -> dict:
    return {"id": 1, "name": "Alice"}
```

### 5. Avoid Overusing Reflection

```python
# ‚úÖ GOOD - Direct access when structure is known
class Config:
    def __init__(self):
        self.debug = False

config = Config()
use_debug = config.debug

# ‚ùå BAD - Unnecessary reflection
use_debug = getattr(config, 'debug')  # Overkill for known attribute
```

---

## Summary

**üìå Advanced Generics**
- TypeVar - Type variables
- Generic base class
- Covariance and Contravariance
- Protocol - Structural typing
- Literal and Final types
- TypedDict - Structured dicts

**üìå Variance Types**
- Invariant (default) - No subtype relationship
- Covariant (output) - Preserves subtype relationship
- Contravariant (input) - Reverses subtype relationship
- Liskov Substitution Principle (LSP)

**üìå Reflection**
- type(), isinstance(), issubclass()
- dir(), vars(), __dict__
- getattr, setattr, hasattr
- inspect module

**üìå Python Conventions**
- _ for discards
- _name for internal use
- __name for name mangling
- Numeric literal underscores

**üìå Python Alternatives**
- Mixins (partial classes)
- Dict/SimpleNamespace (anonymous types)
- Dataclasses (structured data)

---

## Practice Exercises

### Exercise 1: Generic LinkedList
**Task:** Implement generic LinkedList[T] with type safety.

### Exercise 2: Plugin System
**Task:** Create plugin system using Protocol (no inheritance).

### Exercise 3: Covariant Repository
**Task:** Implement ReadOnlyRepository[T_co] with covariant type parameter for query operations.

### Exercise 4: Contravariant Validator
**Task:** Create Validator[T_contra] with contravariant type parameter for validation logic.

### Exercise 5: ORM with Reflection
**Task:** Build simple ORM that maps classes to database using reflection.

### Exercise 6: Configuration Loader
**Task:** Load config from dict using type hints automatically.

### Exercise 7: Serialization Mixin
**Task:** Create mixin for JSON/XML serialization.

### Exercise 8: Dynamic Validator
**Task:** Validate objects based on type hints at runtime.

### Exercise 9: Generic Cache
**Task:** Implement Cache[K, V] with TTL support.

### Exercise 10: Protocol-based Logger
**Task:** Logger that works with any object having log() method.

### Exercise 11: Attribute Inspector
**Task:** Tool to inspect and document class attributes.

### Exercise 12: Dynamic Proxy
**Task:** Create proxy that logs all method calls using reflection.

---

## What's Next?

**Congratulations!** You've mastered advanced Python type system and reflection!

**You now understand:**
- ‚úÖ Advanced generics (TypeVar, Generic, Protocol)
- ‚úÖ Covariance and Contravariance (type variance)
- ‚úÖ Complete reflection and introspection
- ‚úÖ Python conventions and idioms
- ‚úÖ Mixins as partial classes
- ‚úÖ Dynamic programming techniques
- ‚úÖ Liskov Substitution Principle (LSP)

**Your Python mastery is complete!** üéâüêç‚ú®

**Continue learning:**
- Web frameworks (Django, FastAPI)
- Data science (NumPy, Pandas)
- Machine learning (TensorFlow, PyTorch)
- DevOps (Docker, Kubernetes with Python)

**Keep coding!** üíªüöÄ
