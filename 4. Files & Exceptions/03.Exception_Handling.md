# Exception Handling

## Table of Contents
1. [Introduction - Handling Errors Gracefully](#introduction---handling-errors-gracefully)
2. [What Are Exceptions?](#what-are-exceptions)
3. [Common Built-in Exceptions](#common-built-in-exceptions)
4. [The try-except Block](#the-try-except-block)
5. [Handling Multiple Exceptions](#handling-multiple-exceptions)
6. [The else Clause](#the-else-clause)
7. [The finally Clause](#the-finally-clause)
8. [Raising Exceptions](#raising-exceptions)
9. [Creating Custom Exceptions](#creating-custom-exceptions)
10. [Real-Life Practical Examples](#real-life-practical-examples)
11. [Common Mistakes](#common-mistakes)
12. [Best Practices](#best-practices)
13. [Summary](#summary)
14. [Practice Exercises](#practice-exercises)
15. [What's Next?](#whats-next)

---

## Introduction - Handling Errors Gracefully

Errors happen! Users enter wrong input, files go missing, networks fail. Until now, errors crashed your programs. Exception handling lets you anticipate problems and handle them gracefully.

**Real-World Analogy:** Exception handling is like having a backup plan:
- **No exception handling** = Your car breaks down and you're stuck
- **With exception handling** = Car breaks down, but you call a tow truck and get home safely

**In this blog, you'll learn:**
- What exceptions are and why they occur
- Catching and handling different errors
- Cleanup code that always runs
- Creating intelligent error messages
- Building crash-proof programs

---

## What Are Exceptions?

**Define: Exception** - An error that occurs during program execution, disrupting normal flow.

### Program Without Exception Handling

```python
# This crashes if user enters non-number
age = int(input("Enter age: "))  # User types "hello" ‚Üí CRASH! üí•
print(f"You are {age} years old")
# Program stops here if error occurs
```

### Program With Exception Handling

```python
# This handles the error gracefully
try:
    age = int(input("Enter age: "))
    print(f"You are {age} years old")
except ValueError:
    print("Please enter a valid number!")
# Program continues! ‚úÖ
```

### When Do Exceptions Occur?

**Common scenarios:**
- User enters invalid input
- File doesn't exist
- Division by zero
- Index out of range
- Key not in dictionary
- Network connection fails
- Insufficient memory

**Without exception handling:**
```
Traceback (most recent call last):
  File "main.py", line 2, in <module>
    age = int("hello")
ValueError: invalid literal for int() with base 10: 'hello'
```

**With exception handling:**
```
Please enter a valid number!
```

---

## Common Built-in Exceptions

### ValueError - Invalid Value

```python
# Converting invalid string to integer
number = int("hello")  # ValueError!

# Unpacking wrong number of values
a, b = [1, 2, 3]  # ValueError: too many values to unpack
```

### TypeError - Wrong Type

```python
# Adding incompatible types
result = "5" + 5  # TypeError: can only concatenate str to str

# Calling non-function
x = 5
x()  # TypeError: 'int' object is not callable
```

### ZeroDivisionError - Division by Zero

```python
result = 10 / 0  # ZeroDivisionError: division by zero
```

### IndexError - Index Out of Range

```python
numbers = [1, 2, 3]
print(numbers[5])  # IndexError: list index out of range
```

### KeyError - Key Not in Dictionary

```python
person = {"name": "Alice", "age": 25}
print(person["city"])  # KeyError: 'city'
```

### FileNotFoundError - File Doesn't Exist

```python
file = open("missing.txt", "r")  # FileNotFoundError!
```

### AttributeError - Attribute Doesn't Exist

```python
text = "hello"
text.append("!")  # AttributeError: 'str' has no attribute 'append'
```

### NameError - Variable Not Defined

```python
print(undefined_variable)  # NameError: name 'undefined_variable' is not defined
```

---

## The try-except Block

**Define: try block** - Code that might raise an exception.

**Define: except block** - Code that handles the exception.

### Basic Syntax

```python
try:
    # Code that might cause error
    risky_operation()
except ExceptionType:
    # Handle the error
    print("Error occurred!")
```

### Example 1: Division by Zero

```python
try:
    numerator = 10
    denominator = 0
    result = numerator / denominator
    print(result)
except ZeroDivisionError:
    print("Cannot divide by zero!")

print("Program continues...")

# Output:
# Cannot divide by zero!
# Program continues...
```

### Example 2: Invalid Input

```python
try:
    age = int(input("Enter your age: "))  # User enters "twenty"
    print(f"You are {age} years old")
except ValueError:
    print("Please enter a number!")

# Output (if user enters "twenty"):
# Enter your age: twenty
# Please enter a number!
```

### Example 3: Missing File

```python
try:
    with open("data.txt", "r") as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("File not found! Please check the filename.")

# Output (if file doesn't exist):
# File not found! Please check the filename.
```

### Catching Any Exception

```python
try:
    # Some risky code
    risky_operation()
except:
    print("Something went wrong!")

# Better - catch specific exception
try:
    risky_operation()
except Exception as e:
    print(f"Error: {e}")
```

---

## Handling Multiple Exceptions

### Method 1: Multiple except Blocks

```python
try:
    num = int(input("Enter number: "))
    result = 10 / num
    print(result)
except ValueError:
    print("Invalid input! Please enter a number.")
except ZeroDivisionError:
    print("Cannot divide by zero!")

# Test 1: User enters "hello"
# Output: Invalid input! Please enter a number.

# Test 2: User enters 0
# Output: Cannot divide by zero!

# Test 3: User enters 2
# Output: 5.0
```

### Method 2: Tuple of Exceptions

```python
try:
    # Code that might fail
    operation()
except (ValueError, TypeError):
    print("Invalid value or type!")

# Handles both ValueError and TypeError
```

### Method 3: Getting Exception Details

```python
try:
    num = int("hello")
except ValueError as e:
    print(f"Error occurred: {e}")
    print(f"Exception type: {type(e)}")

# Output:
# Error occurred: invalid literal for int() with base 10: 'hello'
# Exception type: <class 'ValueError'>
```

### Example: Calculator with Error Handling

```python
def safe_divide(a, b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print("Error: Cannot divide by zero!")
        return None
    except TypeError:
        print("Error: Please provide numbers!")
        return None

# Test
print(safe_divide(10, 2))    # 5.0
print(safe_divide(10, 0))    # Error: Cannot divide by zero! ‚Üí None
print(safe_divide(10, "5"))  # Error: Please provide numbers! ‚Üí None
```

---

## The else Clause

**Define: else clause** - Code that runs ONLY if no exception occurred.

### Syntax

```python
try:
    # Risky code
    operation()
except ExceptionType:
    # Handle error
    print("Error!")
else:
    # Runs only if no error
    print("Success!")
```

### Example

```python
try:
    num = int(input("Enter a number: "))
except ValueError:
    print("Invalid input!")
else:
    print(f"You entered: {num}")
    print("Thank you!")

# Test 1: User enters "5"
# Output:
# You entered: 5
# Thank you!

# Test 2: User enters "hello"
# Output:
# Invalid input!
```

### When to Use else?

```python
# Reading a file
try:
    file = open("data.txt", "r")
except FileNotFoundError:
    print("File not found!")
else:
    # Only read if file opened successfully
    content = file.read()
    print(content)
    file.close()
```

---

## The finally Clause

**Define: finally clause** - Code that ALWAYS runs, whether exception occurred or not.

### Syntax

```python
try:
    # Risky code
    operation()
except ExceptionType:
    # Handle error
    print("Error!")
finally:
    # Always runs
    print("Cleanup code")
```

### Example: File Operations

```python
file = None
try:
    file = open("data.txt", "r")
    content = file.read()
    print(content)
except FileNotFoundError:
    print("File not found!")
finally:
    # Always close file if it was opened
    if file:
        file.close()
        print("File closed")

# With 'with' statement (better!)
try:
    with open("data.txt", "r") as file:
        content = file.read()
        print(content)
except FileNotFoundError:
    print("File not found!")
```

### Example: Resource Cleanup

```python
def process_data():
    print("Opening database connection...")
    
    try:
        print("Processing data...")
        # Some operation that might fail
        result = 10 / 0
        print(result)
    except ZeroDivisionError:
        print("Error: Division by zero!")
    finally:
        print("Closing database connection...")
        # This ALWAYS runs, even with error!

process_data()

# Output:
# Opening database connection...
# Processing data...
# Error: Division by zero!
# Closing database connection...
```

### Complete try-except-else-finally

```python
try:
    num = int(input("Enter number: "))
    result = 10 / num
except ValueError:
    print("Invalid input!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
else:
    print(f"Result: {result}")
finally:
    print("Operation complete!")

# Test 1: User enters "hello"
# Output:
# Invalid input!
# Operation complete!

# Test 2: User enters 0
# Output:
# Cannot divide by zero!
# Operation complete!

# Test 3: User enters 2
# Output:
# Result: 5.0
# Operation complete!
```

---

## Raising Exceptions

**Define: Raising an exception** - Intentionally triggering an exception in your code.

### Basic raise

```python
def set_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative!")
    print(f"Age set to {age}")

set_age(25)   # Age set to 25
set_age(-5)   # ValueError: Age cannot be negative!
```

### Re-raising Exceptions

```python
try:
    num = int(input("Enter positive number: "))
    if num < 0:
        raise ValueError("Number must be positive!")
except ValueError as e:
    print(f"Error: {e}")
    # Re-raise the same exception
    raise

# Output (if -5 entered):
# Error: Number must be positive!
# Traceback... ValueError: Number must be positive!
```

### Example: Input Validation

```python
def validate_email(email):
    if "@" not in email:
        raise ValueError("Email must contain @")
    if "." not in email:
        raise ValueError("Email must contain a domain")
    return True

try:
    email = input("Enter email: ")
    validate_email(email)
    print("Email is valid!")
except ValueError as e:
    print(f"Invalid email: {e}")

# Test 1: "alice@email.com" ‚Üí Email is valid!
# Test 2: "aliceemail.com" ‚Üí Invalid email: Email must contain @
# Test 3: "alice@email" ‚Üí Invalid email: Email must contain a domain
```

### Example: Withdraw Function

```python
def withdraw(balance, amount):
    if amount > balance:
        raise ValueError("Insufficient funds!")
    if amount <= 0:
        raise ValueError("Amount must be positive!")
    return balance - amount

try:
    balance = 100
    balance = withdraw(balance, 150)
except ValueError as e:
    print(f"Transaction failed: {e}")
else:
    print(f"New balance: ${balance}")

# Output: Transaction failed: Insufficient funds!
```

---

## Creating Custom Exceptions

**Define: Custom exception** - Your own exception class for specific errors.

### Basic Custom Exception

```python
class NegativeNumberError(Exception):
    pass

def square_root(n):
    if n < 0:
        raise NegativeNumberError("Cannot calculate square root of negative number!")
    return n ** 0.5

try:
    result = square_root(-4)
except NegativeNumberError as e:
    print(f"Error: {e}")

# Output: Error: Cannot calculate square root of negative number!
```

### Custom Exception with Details

```python
class InvalidAgeError(Exception):
    def __init__(self, age, message="Age is invalid"):
        self.age = age
        self.message = message
        super().__init__(self.message)
    
    def __str__(self):
        return f"{self.message} (got {self.age})"

def set_age(age):
    if age < 0:
        raise InvalidAgeError(age, "Age cannot be negative")
    if age > 150:
        raise InvalidAgeError(age, "Age seems unrealistic")
    print(f"Age set to {age}")

try:
    set_age(200)
except InvalidAgeError as e:
    print(f"Error: {e}")

# Output: Error: Age seems unrealistic (got 200)
```

### Example: Banking System

```python
class InsufficientFundsError(Exception):
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        message = f"Cannot withdraw ${amount}. Current balance: ${balance}"
        super().__init__(message)

class NegativeAmountError(Exception):
    pass

def withdraw(balance, amount):
    if amount < 0:
        raise NegativeAmountError("Amount cannot be negative!")
    if amount > balance:
        raise InsufficientFundsError(balance, amount)
    return balance - amount

# Test
balance = 100

try:
    balance = withdraw(balance, 150)
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")
except NegativeAmountError as e:
    print(f"Invalid amount: {e}")

# Output: Transaction failed: Cannot withdraw $150. Current balance: $100
```

---

## Real-Life Practical Examples

### Example 1: Robust Input Function

```python
def get_integer(prompt, min_value=None, max_value=None):
    while True:
        try:
            value = int(input(prompt))
            
            if min_value is not None and value < min_value:
                print(f"Value must be at least {min_value}")
                continue
            
            if max_value is not None and value > max_value:
                print(f"Value must be at most {max_value}")
                continue
            
            return value
        except ValueError:
            print("Please enter a valid integer!")

# Usage
age = get_integer("Enter age (1-120): ", min_value=1, max_value=120)
print(f"Age: {age}")

# Interactive test:
# Enter age (1-120): hello
# Please enter a valid integer!
# Enter age (1-120): -5
# Value must be at least 1
# Enter age (1-120): 200
# Value must be at most 120
# Enter age (1-120): 25
# Age: 25
```

### Example 2: Safe File Reader

```python
def read_file_safely(filename):
    try:
        with open(filename, "r") as file:
            content = file.read()
            return content
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found!")
        return None
    except PermissionError:
        print(f"Error: No permission to read '{filename}'!")
        return None
    except Exception as e:
        print(f"Unexpected error: {e}")
        return None

# Test
content = read_file_safely("data.txt")
if content:
    print(content)
else:
    print("Could not read file")
```

### Example 3: Calculator with Full Error Handling

```python
def calculator():
    print("Simple Calculator")
    print("=" * 30)
    
    try:
        num1 = float(input("Enter first number: "))
        operator = input("Enter operator (+, -, *, /): ")
        num2 = float(input("Enter second number: "))
        
        if operator == "+":
            result = num1 + num2
        elif operator == "-":
            result = num1 - num2
        elif operator == "*":
            result = num1 * num2
        elif operator == "/":
            if num2 == 0:
                raise ZeroDivisionError("Cannot divide by zero!")
            result = num1 / num2
        else:
            raise ValueError(f"Unknown operator: {operator}")
        
        print(f"\nResult: {num1} {operator} {num2} = {result}")
        
    except ValueError as e:
        if "could not convert" in str(e):
            print("\nError: Please enter valid numbers!")
        else:
            print(f"\nError: {e}")
    except ZeroDivisionError as e:
        print(f"\nError: {e}")
    except Exception as e:
        print(f"\nUnexpected error: {e}")

# Test
calculator()

# Example session:
# Simple Calculator
# ==============================
# Enter first number: 10
# Enter operator (+, -, *, /): /
# Enter second number: 0
#
# Error: Cannot divide by zero!
```

### Example 4: Grade Validation System

```python
class InvalidGradeError(Exception):
    pass

def validate_grade(grade):
    try:
        # Convert to float
        grade_value = float(grade)
        
        # Check range
        if grade_value < 0 or grade_value > 100:
            raise InvalidGradeError(f"Grade must be between 0 and 100 (got {grade_value})")
        
        return grade_value
    except ValueError:
        raise InvalidGradeError(f"Grade must be a number (got '{grade}')")

def add_grade(student_grades, student_name, grade):
    try:
        validated_grade = validate_grade(grade)
        student_grades[student_name] = validated_grade
        print(f"Grade {validated_grade} added for {student_name}")
    except InvalidGradeError as e:
        print(f"Error: {e}")

# Test
grades = {}
add_grade(grades, "Alice", "95")     # Grade 95.0 added for Alice
add_grade(grades, "Bob", "105")      # Error: Grade must be between 0 and 100 (got 105.0)
add_grade(grades, "Charlie", "A+")   # Error: Grade must be a number (got 'A+')

print(f"\nFinal grades: {grades}")
# Final grades: {'Alice': 95.0}
```

### Example 5: Data Parser with Multiple Error Types

```python
def parse_user_data(data_string):
    """
    Parse user data in format: name,age,email
    Example: "Alice,25,alice@email.com"
    """
    try:
        parts = data_string.split(",")
        
        if len(parts) != 3:
            raise ValueError(f"Expected 3 parts, got {len(parts)}")
        
        name, age_str, email = parts
        
        # Validate name
        name = name.strip()
        if len(name) == 0:
            raise ValueError("Name cannot be empty")
        
        # Validate age
        try:
            age = int(age_str.strip())
            if age < 0 or age > 150:
                raise ValueError(f"Invalid age: {age}")
        except ValueError:
            raise ValueError(f"Age must be a number (got '{age_str.strip()}')")
        
        # Validate email
        email = email.strip()
        if "@" not in email:
            raise ValueError("Email must contain @")
        
        return {
            "name": name,
            "age": age,
            "email": email
        }
    
    except ValueError as e:
        print(f"Parse error: {e}")
        return None

# Test
test_data = [
    "Alice,25,alice@email.com",
    "Bob,hello,bob@email.com",
    "Charlie,30",
    ",25,email@test.com",
    "Dave,200,dave@email.com"
]

for data in test_data:
    print(f"\nParsing: {data}")
    result = parse_user_data(data)
    if result:
        print(f"  Success: {result}")

# Output:
# Parsing: Alice,25,alice@email.com
#   Success: {'name': 'Alice', 'age': 25, 'email': 'alice@email.com'}
#
# Parsing: Bob,hello,bob@email.com
# Parse error: Age must be a number (got 'hello')
#
# Parsing: Charlie,30
# Parse error: Expected 3 parts, got 2
#
# Parsing: ,25,email@test.com
# Parse error: Name cannot be empty
#
# Parsing: Dave,200,dave@email.com
# Parse error: Invalid age: 200
```

### Example 6: Configuration Loader

```python
def load_config(filename):
    config = {}
    
    try:
        with open(filename, "r") as file:
            line_number = 0
            
            for line in file:
                line_number = line_number + 1
                line = line.strip()
                
                # Skip empty lines and comments
                if not line or line.startswith("#"):
                    continue
                
                # Parse key=value
                if "=" not in line:
                    raise ValueError(f"Line {line_number}: Missing '=' in '{line}'")
                
                key, value = line.split("=", 1)
                key = key.strip()
                value = value.strip()
                
                if not key:
                    raise ValueError(f"Line {line_number}: Empty key")
                
                config[key] = value
        
        return config
    
    except FileNotFoundError:
        print(f"Error: Config file '{filename}' not found!")
        return None
    except ValueError as e:
        print(f"Error parsing config: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error: {e}")
        return None

# Create test config file
with open("app.config", "w") as f:
    f.write("# Application Configuration\n")
    f.write("app_name=My App\n")
    f.write("version=1.0\n")
    f.write("debug=true\n")

# Load config
config = load_config("app.config")
if config:
    print("Configuration loaded successfully:")
    for key, value in config.items():
        print(f"  {key} = {value}")

# Output:
# Configuration loaded successfully:
#   app_name = My App
#   version = 1.0
#   debug = true
```

---

## Common Mistakes

### Mistake 1: Catching All Exceptions

**‚ùå Wrong Way:**
```python
try:
    # Some code
    operation()
except:
    pass  # Silently ignore ALL errors - BAD!
```

**‚úÖ Correct Way:**
```python
try:
    operation()
except ValueError:
    # Handle specific error
    print("Invalid value!")
except FileNotFoundError:
    print("File not found!")
```

### Mistake 2: Empty except Block

**‚ùå Wrong Way:**
```python
try:
    risky_operation()
except Exception:
    pass  # Error is hidden!
```

**‚úÖ Correct Way:**
```python
try:
    risky_operation()
except Exception as e:
    print(f"Error occurred: {e}")
    # Or log it
```

### Mistake 3: Too Broad try Block

**‚ùå Wrong Way:**
```python
try:
    # 100 lines of code
    # Too much code in try block!
    # Hard to know what caused error
    lots_of_operations()
except ValueError:
    print("Error!")
```

**‚úÖ Correct Way:**
```python
# Only wrap risky code
setup_operations()

try:
    risky_operation()
except ValueError:
    print("Error in risky operation!")

more_safe_operations()
```

### Mistake 4: Wrong Exception Order

**‚ùå Wrong Way:**
```python
try:
    operation()
except Exception:  # Catches everything first!
    print("General error")
except ValueError:  # Never reached!
    print("Value error")
```

**‚úÖ Correct Way:**
```python
try:
    operation()
except ValueError:  # Specific first
    print("Value error")
except Exception:  # General last
    print("General error")
```

### Mistake 5: Not Using finally for Cleanup

**‚ùå Wrong Way:**
```python
file = open("data.txt", "r")
try:
    content = file.read()
except Exception:
    print("Error!")
file.close()  # Might not run if exception!
```

**‚úÖ Correct Way:**
```python
file = open("data.txt", "r")
try:
    content = file.read()
except Exception:
    print("Error!")
finally:
    file.close()  # Always runs!

# Or better - use with statement
try:
    with open("data.txt", "r") as file:
        content = file.read()
except Exception:
    print("Error!")
```

---

## Best Practices

### ‚úÖ Do This:

1. **Catch Specific Exceptions**
   ```python
   # Good
   try:
       num = int(input("Enter number: "))
   except ValueError:
       print("Invalid number!")
   ```

2. **Use else for Success Code**
   ```python
   try:
       file = open("data.txt", "r")
   except FileNotFoundError:
       print("File not found!")
   else:
       content = file.read()
       file.close()
   ```

3. **Use finally for Cleanup**
   ```python
   file = None
   try:
       file = open("data.txt", "r")
       content = file.read()
   except Exception:
       print("Error!")
   finally:
       if file:
           file.close()
   ```

4. **Provide Helpful Error Messages**
   ```python
   try:
       age = int(input("Age: "))
   except ValueError:
       print("Error: Please enter a valid number for age")
   ```

5. **Log Exceptions**
   ```python
   try:
       operation()
   except Exception as e:
       print(f"Error occurred: {e}")
       # In real apps, log to file
   ```

### ‚ùå Avoid This:

1. **Don't Catch and Ignore**
   ```python
   # Avoid
   try:
       operation()
   except:
       pass  # BAD!
   ```

2. **Don't Use Bare except**
   ```python
   # Avoid
   try:
       operation()
   except:  # Too broad!
       print("Error")
   
   # Better
   except Exception as e:
       print(f"Error: {e}")
   ```

3. **Don't Put Too Much in try**
   ```python
   # Avoid
   try:
       # 50 lines of code
       # Hard to debug!
   except ValueError:
       print("Error")
   ```

---

## Summary

Congratulations! You can now build crash-proof programs! üéâ

**üéØ Key Takeaways:**

**üìå Exceptions**
- Errors that occur during execution
- Disrupt normal program flow
- Can be caught and handled

**üìå try-except**
- `try:` - code that might fail
- `except ExceptionType:` - handle specific error
- Multiple except blocks for different errors
- `as e` to get error details

**üìå else and finally**
- `else:` - runs if NO exception
- `finally:` - ALWAYS runs (cleanup code)

**üìå Raising Exceptions**
- `raise ExceptionType("message")` - trigger error
- Useful for input validation
- Can re-raise exceptions

**üìå Custom Exceptions**
- Create classes inheriting from `Exception`
- Add custom attributes and messages
- Useful for domain-specific errors

**üìå Common Exceptions**
- `ValueError` - invalid value
- `TypeError` - wrong type
- `ZeroDivisionError` - divide by zero
- `IndexError` - index out of range
- `KeyError` - key not in dict
- `FileNotFoundError` - file missing

**üí° Remember:**
- Catch specific exceptions (not bare `except`)
- Provide helpful error messages
- Use `finally` for cleanup
- Don't hide errors silently
- Keep try blocks focused
- Validate user input

---

## Practice Exercises

### Exercise 1: Safe Division

**Task:** Create a function `safe_divide(a, b)` that handles division by zero and type errors gracefully.

---

### Exercise 2: Age Validator

**Task:** Write a function that gets user age and validates it (must be number, 0-120 range). Keep asking until valid.

---

### Exercise 3: File Reader

**Task:** Create a function that reads a file and handles file not found, permission errors, and empty files.

---

### Exercise 4: List Access

**Task:** Write a function `safe_get(lst, index)` that returns list element or None if index is out of range.

---

### Exercise 5: Dictionary Lookup

**Task:** Create function `get_value(dictionary, key, default)` that returns value or default if key doesn't exist (don't use built-in `.get()`).

---

### Exercise 6: Custom Exception

**Task:** Create `InvalidPasswordError` exception class. Use it in a function that validates password (min 8 chars, has digit, has uppercase).

---

### Exercise 7: Calculator

**Task:** Build a calculator that handles invalid input, division by zero, and unknown operators.

---

### Exercise 8: CSV Reader

**Task:** Read a CSV file and handle missing file, malformed lines, and invalid data types.

---

### Exercise 9: Login System

**Task:** Create a login function that raises `InvalidUsernameError` or `InvalidPasswordError` custom exceptions.

---

### Exercise 10: Retry Mechanism

**Task:** Create a function that retries an operation up to 3 times if it fails, with different messages for each attempt.

---

## What's Next?

You've mastered exception handling! üéâ

In the next blogs, **Chapters 11-15: Object-Oriented Programming (OOP)**, you'll learn:

- Why OOP? Problems with procedural programming
- Classes and objects - creating your own data types
- Encapsulation - hiding and protecting data
- Inheritance - building on existing classes
- Polymorphism - many forms of the same interface
- Abstraction - hiding complexity
- Real-world OOP projects

**Why this matters:** OOP is how professional software is built! From games to web apps to data science libraries - everything uses OOP. It's the key to writing organized, reusable, maintainable code.

**Get ready to:** Transform from writing scripts to building real software systems!

---

**Keep practicing!** Exception handling is crucial for professional applications. Try adding error handling to all your previous projects!

Remember: Errors are not failures, they're opportunities to make your program smarter! üí™
