# File Handling

## Table of Contents
1. [Introduction - Working with Files](#introduction---working-with-files)
2. [Why File Handling?](#why-file-handling)
3. [Opening Files](#opening-files)
4. [Reading Files](#reading-files)
5. [Writing Files](#writing-files)
6. [File Modes](#file-modes)
7. [Context Managers (with Statement)](#context-managers-with-statement)
8. [Working with File Paths](#working-with-file-paths)
9. [Working with CSV Files](#working-with-csv-files)
10. [Real-Life Practical Examples](#real-life-practical-examples)
11. [Common Mistakes](#common-mistakes)
12. [Best Practices](#best-practices)
13. [Summary](#summary)
14. [Practice Exercises](#practice-exercises)
15. [What's Next?](#whats-next)

---

## Introduction - Working with Files

Until now, all your data disappeared when the program ended! File handling changes that - your programs can now save data permanently and read it back later.

**Real-World Analogy:** Think of file handling like using a notebook:
- **Reading a file** = Opening your notebook and reading what's written
- **Writing a file** = Writing new notes in your notebook
- **Appending a file** = Adding more notes at the end
- **Closing a file** = Closing your notebook when done

**In this blog, you'll learn:**
- Opening and closing files properly
- Reading file contents in different ways
- Writing data to files
- The `with` statement for automatic cleanup
- Working with CSV (spreadsheet data)
- Handling file paths correctly

---

## Why File Handling?

### Programs Need to Remember!

**Without files:**
```python
# User enters data
name = input("Enter name: ")  # Alice
age = input("Enter age: ")    # 25

# Program use the data
print(f"Hello, {name}!")

# Program ends ‚Üí DATA LOST! üò¢
```

**With files:**
```python
# Save data
file = open("user.txt", "w")
file.write("Alice\n")
file.write("25\n")
file.close()

# Later... even after restarting computer
# Read data back
file = open("user.txt", "r")
name = file.readline().strip()
age = file.readline().strip()
file.close()

print(f"Welcome back, {name}!")  # Data survived! üéâ
```

### Real Applications

**Files are used for:**
- **Configuration** - Save app settings
- **Data storage** - Save user data, game progress
- **Logging** - Track errors and events
- **Reports** - Generate sales reports, analytics
- **Data exchange** - Share data between programs (CSV, JSON)
- **Backup** - Save copies of important data

---

## Opening Files

**Define: File object** - A connection to a file that allows reading/writing.

### Basic Syntax

```python
file = open("filename.txt", "mode")
# ... use the file ...
file.close()  # IMPORTANT: Always close!
```

### Opening a File for Reading

```python
# Open file for reading
file = open("data.txt", "r")

# Do something with file
content = file.read()
print(content)

# Close when done
file.close()
```

### What If File Doesn't Exist?

```python
# Reading non-existent file ‚Üí Error!
# file = open("missing.txt", "r")  # FileNotFoundError!

# Check if file exists first (we'll learn better way later)
import os
if os.path.exists("data.txt"):
    file = open("data.txt", "r")
    content = file.read()
    file.close()
    print(content)
else:
    print("File not found!")
```

---

## Reading Files

### Method 1: read() - Read Entire File

```python
# Create a test file first
file = open("story.txt", "w")
file.write("Once upon a time,\nthere was a programmer\nwho learned Python.")
file.close()

# Read entire file as one string
file = open("story.txt", "r")
content = file.read()
print(content)
file.close()

# Output:
# Once upon a time,
# there was a programmer
# who learned Python.
```

### Method 2: read(n) - Read n Characters

```python
file = open("story.txt", "r")

# Read first 10 characters
chunk = file.read(10)
print(chunk)  # Once upon

# Read next 10 characters
chunk = file.read(10)
print(chunk)  #  a time,\nt

file.close()
```

### Method 3: readline() - Read One Line

```python
file = open("story.txt", "r")

# Read first line
line1 = file.readline()
print(line1)  # Once upon a time,\n

# Read second line
line2 = file.readline()
print(line2)  # there was a programmer\n

# Read third line
line3 = file.readline()
print(line3)  # who learned Python.

# Read again (end of file)
line4 = file.readline()
print(line4)  # Empty string ""

file.close()
```

### Method 4: readlines() - Read All Lines as List

```python
file = open("story.txt", "r")

# Read all lines into a list
lines = file.readlines()
print(lines)
# ['Once upon a time,\n', 'there was a programmer\n', 'who learned Python.']

file.close()

# Process each line
for line in lines:
    print(line.strip())  # Remove \n
```

### Method 5: Iterate Over File (Best!)

```python
file = open("story.txt", "r")

# Most efficient way - iterate directly
for line in file:
    print(line.strip())

file.close()

# Output:
# Once upon a time,
# there was a programmer
# who learned Python.
```

---

## Writing Files

### Method 1: write() - Write String

```python
# Open file for writing (creates if doesn't exist)
file = open("output.txt", "w")

file.write("Hello, World!\n")
file.write("This is line 2.\n")
file.write("This is line 3.")

file.close()

# Read it back
file = open("output.txt", "r")
print(file.read())
file.close()

# Output:
# Hello, World!
# This is line 2.
# This is line 3.
```

**Warning:** Mode "w" **overwrites** existing files!

```python
# File has: "Hello, World!"
file = open("output.txt", "w")
file.write("New content")  # Old content GONE!
file.close()
```

### Method 2: writelines() - Write List of Strings

```python
lines = [
    "Line 1\n",
    "Line 2\n",
    "Line 3\n"
]

file = open("output.txt", "w")
file.writelines(lines)
file.close()

# Read it back
file = open("output.txt", "r")
print(file.read())
file.close()
```

### Appending to Files

```python
# Create initial file
file = open("log.txt", "w")
file.write("Program started\n")
file.close()

# Append more data (doesn't erase!)
file = open("log.txt", "a")
file.write("User logged in\n")
file.close()

# Append again
file = open("log.txt", "a")
file.write("User logged out\n")
file.close()

# Read final content
file = open("log.txt", "r")
print(file.read())
file.close()

# Output:
# Program started
# User logged in
# User logged out
```

---

## File Modes

**Define: File mode** - A string that specifies how a file should be opened.

### Common Modes

| Mode | Description | Creates? | Overwrites? |
|------|-------------|----------|-------------|
| `"r"` | Read (default) | No | No |
| `"w"` | Write | Yes | Yes |
| `"a"` | Append | Yes | No |
| `"r+"` | Read and write | No | No |
| `"w+"` | Write and read | Yes | Yes |
| `"a+"` | Append and read | Yes | No |

### Mode "r" - Read Only

```python
# File must exist
file = open("data.txt", "r")
content = file.read()
file.close()

# Cannot write
# file.write("text")  # Error!
```

### Mode "w" - Write Only

```python
# Creates file if doesn't exist
# ERASES file if exists!
file = open("data.txt", "w")
file.write("New content")
file.close()

# Cannot read
# content = file.read()  # Error!
```

### Mode "a" - Append Only

```python
# Creates file if doesn't exist
# Adds to end if exists
file = open("log.txt", "a")
file.write("New log entry\n")
file.close()
```

### Mode "r+" - Read and Write

```python
# File must exist
file = open("data.txt", "r+")

# Read
content = file.read()
print(content)

# Write (adds to end)
file.write("\nNew line")

file.close()
```

### Text vs Binary Mode

```python
# Text mode (default) - for .txt, .csv, .py files
file = open("data.txt", "r")  # Same as "rt"

# Binary mode - for images, videos, exe files
file = open("image.png", "rb")  # Read binary
file = open("output.png", "wb")  # Write binary
```

---

## Context Managers (with Statement)

**Define: Context manager** - Automatically handles setup and cleanup (like closing files).

### The Problem with open/close

```python
# What if error happens before close?
file = open("data.txt", "r")
content = file.read()
# Some error happens here!
file.close()  # This might never run! üò±
```

### The Solution: `with` Statement

```python
# File automatically closed - even if error!
with open("data.txt", "r") as file:
    content = file.read()
    print(content)
# File automatically closed here! No need for file.close()
```

**Benefits:**
- ‚úÖ Automatic cleanup
- ‚úÖ Closes file even if error occurs
- ‚úÖ Cleaner code
- ‚úÖ No forgetting to close

### Examples with `with`

**Reading:**
```python
with open("data.txt", "r") as file:
    for line in file:
        print(line.strip())
```

**Writing:**
```python
with open("output.txt", "w") as file:
    file.write("Line 1\n")
    file.write("Line 2\n")
```

**Multiple files:**
```python
# Copy file content
with open("input.txt", "r") as input_file:
    with open("output.txt", "w") as output_file:
        content = input_file.read()
        output_file.write(content)

# Or on one line (Python 3.1+)
with open("input.txt", "r") as input_file, open("output.txt", "w") as output_file:
    content = input_file.read()
    output_file.write(content)
```

---

## Working with File Paths

### Absolute vs Relative Paths

**Define: Absolute path** - Complete path from root directory.

**Define: Relative path** - Path from current working directory.

```python
# Absolute path (Windows)
file = open(r"C:\Users\Alice\Documents\data.txt", "r")

# Absolute path (Mac/Linux)
file = open("/home/alice/documents/data.txt", "r")

# Relative path (same directory as Python script)
file = open("data.txt", "r")

# Relative path (subdirectory)
file = open("data/students.txt", "r")

# Relative path (parent directory)
file = open("../config.txt", "r")
```

### Using os.path Module

```python
import os

# Current working directory
print(os.getcwd())  # C:\Users\Alice\Projects

# Check if file exists
if os.path.exists("data.txt"):
    print("File exists!")

# Check if path is file or directory
print(os.path.isfile("data.txt"))  # True
print(os.path.isdir("data"))       # True

# Get file size (bytes)
size = os.path.getsize("data.txt")
print(f"Size: {size} bytes")

# Join paths (handles / or \ automatically)
path = os.path.join("data", "students.txt")
print(path)  # data\students.txt (Windows) or data/students.txt (Mac/Linux)

# Get directory name
directory = os.path.dirname(r"C:\Users\Alice\data.txt")
print(directory)  # C:\Users\Alice

# Get file name
filename = os.path.basename(r"C:\Users\Alice\data.txt")
print(filename)  # data.txt
```

### Creating Directories

```python
import os

# Create directory
if not os.path.exists("logs"):
    os.mkdir("logs")

# Create nested directories
if not os.path.exists("data/2024/january"):
    os.makedirs("data/2024/january")

# List files in directory
files = os.listdir("data")
print(files)  # ['students.txt', 'grades.txt', ...]
```

---

## Working with CSV Files

**Define: CSV** - Comma-Separated Values, a simple format for tabular data.

### What is CSV?

```
name,age,city
Alice,25,New York
Bob,30,Los Angeles
Charlie,22,Chicago
```

Each line is a row, commas separate columns.

### Writing CSV Files (Manual)

```python
# Simple CSV writing
with open("students.csv", "w") as file:
    # Header
    file.write("name,age,grade\n")
    
    # Data rows
    file.write("Alice,20,A\n")
    file.write("Bob,22,B\n")
    file.write("Charlie,21,A+\n")
```

### Reading CSV Files (Manual)

```python
with open("students.csv", "r") as file:
    # Read all lines
    lines = file.readlines()
    
    # First line is header
    header = lines[0].strip().split(",")
    print(header)  # ['name', 'age', 'grade']
    
    # Rest are data
    for line in lines[1:]:
        data = line.strip().split(",")
        name, age, grade = data
        print(f"{name} is {age} years old, grade: {grade}")

# Output:
# Alice is 20 years old, grade: A
# Bob is 22 years old, grade: B
# Charlie is 21 years old, grade: A+
```

### Using csv Module (Better!)

```python
import csv

# Writing CSV
with open("students.csv", "w", newline="") as file:
    writer = csv.writer(file)
    
    # Write header
    writer.writerow(["name", "age", "grade"])
    
    # Write data rows
    writer.writerow(["Alice", 20, "A"])
    writer.writerow(["Bob", 22, "B"])
    writer.writerow(["Charlie", 21, "A+"])

# Reading CSV
with open("students.csv", "r") as file:
    reader = csv.reader(file)
    
    # Skip header
    header = next(reader)
    print(header)
    
    # Read data
    for row in reader:
        name, age, grade = row
        print(f"{name}: {age} years, grade {grade}")
```

### Using DictReader/DictWriter

```python
import csv

# Writing with DictWriter
students = [
    {"name": "Alice", "age": 20, "grade": "A"},
    {"name": "Bob", "age": 22, "grade": "B"},
    {"name": "Charlie", "age": 21, "grade": "A+"}
]

with open("students.csv", "w", newline="") as file:
    fieldnames = ["name", "age", "grade"]
    writer = csv.DictWriter(file, fieldnames=fieldnames)
    
    writer.writeheader()
    writer.writerows(students)

# Reading with DictReader
with open("students.csv", "r") as file:
    reader = csv.DictReader(file)
    
    for row in reader:
        print(f"{row['name']} is {row['age']} years old")
```

---

## Real-Life Practical Examples

### Example 1: Simple To-Do List App

```python
def add_task(task):
    with open("todos.txt", "a") as file:
        file.write(task + "\n")
    print("Task added!")

def view_tasks():
    try:
        with open("todos.txt", "r") as file:
            tasks = file.readlines()
            if tasks:
                print("\nüìù Your To-Do List:")
                for i, task in enumerate(tasks, 1):
                    print(f"{i}. {task.strip()}")
            else:
                print("No tasks yet!")
    except FileNotFoundError:
        print("No tasks yet!")

def clear_tasks():
    with open("todos.txt", "w") as file:
        pass  # Empty file
    print("All tasks cleared!")

# Test the app
add_task("Learn Python")
add_task("Build a project")
add_task("Practice coding")
view_tasks()

# Output:
# Task added!
# Task added!
# Task added!
# 
# üìù Your To-Do List:
# 1. Learn Python
# 2. Build a project
# 3. Practice coding
```

### Example 2: Grade Manager

```python
def save_grade(name, subject, grade):
    with open("grades.csv", "a") as file:
        file.write(f"{name},{subject},{grade}\n")

def get_student_grades(student_name):
    grades = []
    try:
        with open("grades.csv", "r") as file:
            for line in file:
                name, subject, grade = line.strip().split(",")
                if name == student_name:
                    grades.append({"subject": subject, "grade": int(grade)})
    except FileNotFoundError:
        return []
    return grades

def calculate_average(student_name):
    grades = get_student_grades(student_name)
    if not grades:
        return 0
    total = sum(g["grade"] for g in grades)
    return total / len(grades)

# Test
save_grade("Alice", "Math", "95")
save_grade("Alice", "English", "88")
save_grade("Alice", "Science", "92")
save_grade("Bob", "Math", "78")

print("Alice's grades:")
for g in get_student_grades("Alice"):
    print(f"  {g['subject']}: {g['grade']}")

avg = calculate_average("Alice")
print(f"Alice's average: {avg:.1f}")

# Output:
# Alice's grades:
#   Math: 95
#   English: 88
#   Science: 92
# Alice's average: 91.7
```

### Example 3: Log File Analyzer

```python
def write_log(message):
    import datetime
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open("app.log", "a") as file:
        file.write(f"[{timestamp}] {message}\n")

def count_errors():
    error_count = 0
    try:
        with open("app.log", "r") as file:
            for line in file:
                if "ERROR" in line:
                    error_count = error_count + 1
    except FileNotFoundError:
        return 0
    return error_count

def get_recent_logs(n=5):
    try:
        with open("app.log", "r") as file:
            lines = file.readlines()
            return lines[-n:]  # Last n lines
    except FileNotFoundError:
        return []

# Test
write_log("INFO: Application started")
write_log("INFO: User logged in")
write_log("ERROR: Database connection failed")
write_log("INFO: Retrying connection")
write_log("ERROR: Connection timeout")

print(f"Total errors: {count_errors()}")
print("\nRecent logs:")
for log in get_recent_logs(3):
    print(log.strip())

# Output:
# Total errors: 2
# 
# Recent logs:
# [2024-02-16 10:30:45] ERROR: Database connection failed
# [2024-02-16 10:30:46] INFO: Retrying connection
# [2024-02-16 10:30:47] ERROR: Connection timeout
```

### Example 4: Contact Book

```python
import csv

def add_contact(name, phone, email):
    with open("contacts.csv", "a", newline="") as file:
        writer = csv.writer(file)
        writer.writerow([name, phone, email])
    print(f"Contact {name} added!")

def search_contact(name):
    try:
        with open("contacts.csv", "r") as file:
            reader = csv.reader(file)
            for row in reader:
                if row[0].lower() == name.lower():
                    return {
                        "name": row[0],
                        "phone": row[1],
                        "email": row[2]
                    }
    except FileNotFoundError:
        return None
    return None

def list_all_contacts():
    try:
        with open("contacts.csv", "r") as file:
            reader = csv.reader(file)
            contacts = list(reader)
            return contacts
    except FileNotFoundError:
        return []

# Test
add_contact("Alice", "555-1234", "alice@email.com")
add_contact("Bob", "555-5678", "bob@email.com")

contact = search_contact("Alice")
if contact:
    print(f"\nFound: {contact['name']}")
    print(f"Phone: {contact['phone']}")
    print(f"Email: {contact['email']}")

print("\nAll contacts:")
for contact in list_all_contacts():
    print(f"{contact[0]}: {contact[1]}")

# Output:
# Contact Alice added!
# Contact Bob added!
#
# Found: Alice
# Phone: 555-1234
# Email: alice@email.com
#
# All contacts:
# Alice: 555-1234
# Bob: 555-5678
```

### Example 5: Configuration File Manager

```python
def save_config(settings):
    with open("config.txt", "w") as file:
        for key, value in settings.items():
            file.write(f"{key}={value}\n")

def load_config():
    config = {}
    try:
        with open("config.txt", "r") as file:
            for line in file:
                line = line.strip()
                if "=" in line:
                    key, value = line.split("=", 1)
                    config[key] = value
    except FileNotFoundError:
        return {}
    return config

def update_config(key, value):
    config = load_config()
    config[key] = value
    save_config(config)

# Test
settings = {
    "theme": "dark",
    "font_size": "14",
    "auto_save": "true"
}

save_config(settings)
print("Config saved!")

loaded = load_config()
print(f"\nLoaded config: {loaded}")

update_config("theme", "light")
print(f"\nUpdated config: {load_config()}")

# Output:
# Config saved!
#
# Loaded config: {'theme': 'dark', 'font_size': '14', 'auto_save': 'true'}
#
# Updated config: {'theme': 'light', 'font_size': '14', 'auto_save': 'true'}
```

### Example 6: Word Counter

```python
def count_words_in_file(filename):
    try:
        with open(filename, "r") as file:
            content = file.read()
            words = content.split()
            return len(words)
    except FileNotFoundError:
        return 0

def count_lines_in_file(filename):
    try:
        with open(filename, "r") as file:
            lines = file.readlines()
            return len(lines)
    except FileNotFoundError:
        return 0

def get_file_stats(filename):
    try:
        with open(filename, "r") as file:
            content = file.read()
            
            stats = {
                "characters": len(content),
                "words": len(content.split()),
                "lines": len(content.splitlines()),
                "paragraphs": len([p for p in content.split("\n\n") if p.strip()])
            }
            return stats
    except FileNotFoundError:
        return None

# Create test file
with open("essay.txt", "w") as file:
    file.write("Python is amazing.\n")
    file.write("I love programming.\n")
    file.write("\n")
    file.write("Files are useful!")

# Analyze file
stats = get_file_stats("essay.txt")
if stats:
    print("File Statistics:")
    print(f"  Characters: {stats['characters']}")
    print(f"  Words: {stats['words']}")
    print(f"  Lines: {stats['lines']}")
    print(f"  Paragraphs: {stats['paragraphs']}")

# Output:
# File Statistics:
#   Characters: 62
#   Words: 8
#   Lines: 4
#   Paragraphs: 2
```

---

## Common Mistakes

### Mistake 1: Forgetting to Close Files

**‚ùå Wrong Way:**
```python
file = open("data.txt", "r")
content = file.read()
# Forgot to close! File handle stays open
```

**‚úÖ Correct Way:**
```python
# Best: Use with statement
with open("data.txt", "r") as file:
    content = file.read()
# Automatically closed!
```

### Mistake 2: Using "w" Mode Accidentally

**‚ùå Wrong Way:**
```python
# Oops! This ERASES existing data!
file = open("important_data.txt", "w")
file.write("Hello")
file.close()
```

**‚úÖ Correct Way:**
```python
# Use "a" to append instead
file = open("important_data.txt", "a")
file.write("Hello\n")
file.close()
```

### Mistake 3: Not Handling Missing Files

**‚ùå Wrong Way:**
```python
file = open("missing.txt", "r")  # Crash if doesn't exist!
```

**‚úÖ Correct Way:**
```python
import os

if os.path.exists("missing.txt"):
    with open("missing.txt", "r") as file:
        content = file.read()
else:
    print("File not found!")
```

### Mistake 4: Reading File Multiple Times

**‚ùå Wrong Way:**
```python
file = open("data.txt", "r")
content1 = file.read()  # Reads all
content2 = file.read()  # Empty! Already at end
file.close()
```

**‚úÖ Correct Way:**
```python
with open("data.txt", "r") as file:
    content = file.read()

# Use content multiple times
print(content)
print(content)
```

### Mistake 5: Forgetting Newlines

**‚ùå Wrong Way:**
```python
file = open("output.txt", "w")
file.write("Line 1")
file.write("Line 2")  # No newline!
file.close()
# File contains: Line 1Line 2
```

**‚úÖ Correct Way:**
```python
with open("output.txt", "w") as file:
    file.write("Line 1\n")
    file.write("Line 2\n")
# File contains:
# Line 1
# Line 2
```

---

## Best Practices

### ‚úÖ Do This:

1. **Always Use `with` Statement**
   ```python
   # Good - automatic cleanup
   with open("data.txt", "r") as file:
       content = file.read()
   ```

2. **Check File Existence**
   ```python
   import os
   
   if os.path.exists("data.txt"):
       with open("data.txt", "r") as file:
           content = file.read()
   ```

3. **Use Appropriate Mode**
   ```python
   # Reading - use "r"
   with open("data.txt", "r") as file:
       content = file.read()
   
   # Appending - use "a"
   with open("log.txt", "a") as file:
       file.write("New entry\n")
   ```

4. **Strip Lines When Reading**
   ```python
   with open("data.txt", "r") as file:
       for line in file:
           line = line.strip()  # Remove \n
           print(line)
   ```

5. **Use CSV Module for CSV Files**
   ```python
   import csv
   
   with open("data.csv", "r") as file:
       reader = csv.reader(file)
       for row in reader:
           print(row)
   ```

### ‚ùå Avoid This:

1. **Don't Forget to Close (if not using `with`)**
   ```python
   # Avoid
   file = open("data.txt", "r")
   content = file.read()
   # Missing file.close()!
   ```

2. **Don't Use "w" When You Mean "a"**
   ```python
   # Avoid - erases file!
   file = open("log.txt", "w")
   file.write("Log entry")
   ```

3. **Don't Read Entire Large Files**
   ```python
   # Avoid for huge files
   content = file.read()  # Could use too much memory
   
   # Better - iterate line by line
   for line in file:
       process(line)
   ```

---

## Summary

Congratulations! You can now make your programs remember data! üéâ

**üéØ Key Takeaways:**

**üìå Opening Files**
- `open(filename, mode)` - opens file
- Always close files (or use `with`)
- Modes: "r" (read), "w" (write/overwrite), "a" (append)

**üìå Reading Files**
- `read()` - entire file as string
- `readline()` - one line at a time
- `readlines()` - all lines as list
- **Best:** Iterate with `for line in file`

**üìå Writing Files**
- `write(string)` - write string
- `writelines(list)` - write list of strings
- Remember `\n` for newlines!
- "w" **erases** file, "a" **adds** to end

**üìå Context Manager**
- `with open(file) as f:` - automatic cleanup
- No need for `file.close()`
- Works even if errors occur

**üìå File Paths**
- Use `os.path` module
- `os.path.exists()` - check if exists
- `os.path.join()` - build paths correctly
- `os.listdir()` - list directory contents

**üìå CSV Files**
- Import `csv` module
- `csv.reader()` and `csv.writer()`
- `csv.DictReader()` and `csv.DictWriter()` for dictionaries
- Remember `newline=""` when writing

**üí° Remember:**
- Always use `with` statement
- Check if files exist before reading
- Use "a" mode to append (not erase)
- Strip lines to remove `\n`
- CSV module handles commas in data

---

## Practice Exercises

### Exercise 1: File Creator

**Task:** Write a function that creates a file with user-specified name and content.

---

### Exercise 2: Line Counter

**Task:** Count and return the number of lines in a text file.

---

### Exercise 3: Word Search

**Task:** Search for a specific word in a file and return how many times it appears.

---

### Exercise 4: File Merger

**Task:** Combine contents of multiple files into one output file.

---

### Exercise 5: Student Database

**Task:** Create functions to add, search, and display student records in a CSV file (name, age, grade).

---

### Exercise 6: Backup Creator

**Task:** Copy a file to a backup with timestamp in filename (e.g., `data_backup_2024-02-16.txt`).

---

### Exercise 7: Log Filter

**Task:** Read a log file and write only "ERROR" lines to a new file.

---

### Exercise 8: CSV to Dictionary

**Task:** Read a CSV file and convert it to a list of dictionaries.

---

### Exercise 9: Duplicate Line Remover

**Task:** Read a file and write a new file with duplicate lines removed.

---

### Exercise 10: File Statistics

**Task:** Create a function that returns detailed statistics about a text file (characters, words, lines, longest line, shortest line).

---

## What's Next?

You've mastered file handling! üéâ

In the next blog, **Chapter 10: Exception Handling**, you'll learn:

- What are exceptions and why they happen
- try/except blocks for error handling
- Handling specific exception types
- finally clause for cleanup
- Raising exceptions intentionally
- Creating custom exceptions

**Why this matters:** Errors happen in every program! Exception handling lets you create robust applications that handle problems gracefully instead of crashing.

**Get ready to:** Build bulletproof programs that never crash unexpectedly!

---

**Keep practicing!** Try building a journal app, contact manager, or data analyzer. File handling is essential for real applications!

Remember: Programs that remember data are useful programs! üíæ
