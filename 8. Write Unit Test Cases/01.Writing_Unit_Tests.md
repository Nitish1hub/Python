# Writing Unit Test Cases in Python

## Table of Contents
1. [Introduction - Why Testing Matters?](#introduction---why-testing-matters)
2. [What is Unit Testing?](#what-is-unit-testing)
3. [Python unittest Module](#python-unittest-module)
4. [Writing Your First Test](#writing-your-first-test)
5. [Test Assertions](#test-assertions)
6. [Test Fixtures (setUp and tearDown)](#test-fixtures-setup-and-teardown)
7. [Testing Exceptions](#testing-exceptions)
8. [Introduction to pytest](#introduction-to-pytest)
9. [pytest Fixtures](#pytest-fixtures)
10. [Mocking and Patching](#mocking-and-patching)
11. [Test Coverage](#test-coverage)
12. [Real-Life Testing Examples](#real-life-testing-examples)
13. [Common Mistakes](#common-mistakes)
14. [Best Practices](#best-practices)
15. [Summary](#summary)
16. [Practice Exercises](#practice-exercises)

---

## Introduction - Why Testing Matters?

Testing ensures your code works correctly and continues to work as you make changes!

**Real-World Analogy:**
- **No tests:** Building a house without inspections - looks good until something breaks
- **With tests:** Quality control at every step - catch problems early
- **Unit tests:** Testing each brick individually before building the wall

**Benefits of Testing:**
- ‚úÖ **Catch bugs early** - Before users find them
- ‚úÖ **Confidence in changes** - Refactor without fear
- ‚úÖ **Documentation** - Tests show how code should work
- ‚úÖ **Better design** - Testable code is cleaner code
- ‚úÖ **Save time** - Automated testing faster than manual

**In this blog, you'll learn:**
- Write unit tests with unittest
- Use pytest framework
- Mock external dependencies
- Measure test coverage
- Follow testing best practices

---

## What is Unit Testing?

**Define: Unit Test** - A test that verifies a single "unit" (function, method, class) works correctly in isolation.

### Types of Tests

**1. Unit Tests** ‚ö° (This blog's focus)
- Test individual functions/methods
- Fast execution
- No external dependencies
- Example: Test `add(2, 3)` returns `5`

**2. Integration Tests** üîó
- Test multiple components together
- Database, API calls
- Example: Test user registration saves to database

**3. End-to-End Tests** üéØ
- Test entire application flow
- Simulate real user behavior
- Example: Test complete checkout process

### Unit Test Characteristics

**Good unit tests are:**
- ‚úÖ **Fast** - Run in milliseconds
- ‚úÖ **Isolated** - Don't depend on other tests
- ‚úÖ **Repeatable** - Same result every time
- ‚úÖ **Self-validating** - Pass or fail clearly
- ‚úÖ **Timely** - Written with or before code

---

## Python unittest Module

**unittest** is Python's built-in testing framework (inspired by JUnit).

### Basic Structure

```python
import unittest

class TestMyCode(unittest.TestCase):
    """Test case class inherits from unittest.TestCase"""
    
    def test_something(self):
        """Test method must start with 'test_'"""
        result = 2 + 2
        self.assertEqual(result, 4)

if __name__ == '__main__':
    unittest.main()
```

### Running Tests

```bash
# Run test file
python test_mycode.py

# Run with verbose output
python test_mycode.py -v

# Run specific test
python -m unittest test_mycode.TestMyCode.test_something

# Discover and run all tests
python -m unittest discover
```

---

## Writing Your First Test

### Example: Testing a Calculator

**File: calculator.py**
```python
"""Simple calculator module"""

def add(a, b):
    """Add two numbers"""
    return a + b

def subtract(a, b):
    """Subtract b from a"""
    return a - b

def multiply(a, b):
    """Multiply two numbers"""
    return a * b

def divide(a, b):
    """Divide a by b"""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
```

**File: test_calculator.py**
```python
import unittest
from calculator import add, subtract, multiply, divide

class TestCalculator(unittest.TestCase):
    """Test calculator functions"""
    
    def test_add(self):
        """Test addition"""
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        self.assertEqual(add(0, 0), 0)
    
    def test_subtract(self):
        """Test subtraction"""
        self.assertEqual(subtract(5, 3), 2)
        self.assertEqual(subtract(10, 10), 0)
        self.assertEqual(subtract(0, 5), -5)
    
    def test_multiply(self):
        """Test multiplication"""
        self.assertEqual(multiply(2, 3), 6)
        self.assertEqual(multiply(5, 0), 0)
        self.assertEqual(multiply(-2, 3), -6)
    
    def test_divide(self):
        """Test division"""
        self.assertEqual(divide(6, 2), 3)
        self.assertEqual(divide(5, 2), 2.5)
        self.assertEqual(divide(0, 5), 0)

if __name__ == '__main__':
    unittest.main()
```

**Output:**
```
....
----------------------------------------------------------------------
Ran 4 tests in 0.001s

OK
```

---

## Test Assertions

Assertions verify expected behavior. unittest provides many assertion methods.

### Common Assertions

```python
import unittest

class TestAssertions(unittest.TestCase):
    """Demonstrate various assertions"""
    
    def test_equality(self):
        """Test equality"""
        self.assertEqual(1 + 1, 2)
        self.assertNotEqual(1 + 1, 3)
    
    def test_boolean(self):
        """Test boolean values"""
        self.assertTrue(5 > 3)
        self.assertFalse(5 < 3)
    
    def test_none(self):
        """Test None values"""
        result = None
        self.assertIsNone(result)
        
        result = "value"
        self.assertIsNotNone(result)
    
    def test_membership(self):
        """Test item in collection"""
        fruits = ['apple', 'banana', 'orange']
        self.assertIn('apple', fruits)
        self.assertNotIn('grape', fruits)
    
    def test_type(self):
        """Test type checking"""
        self.assertIsInstance(42, int)
        self.assertIsInstance("hello", str)
        self.assertIsInstance([1, 2], list)
    
    def test_comparison(self):
        """Test comparisons"""
        self.assertGreater(5, 3)
        self.assertLess(3, 5)
        self.assertGreaterEqual(5, 5)
        self.assertLessEqual(3, 5)
    
    def test_sequences(self):
        """Test sequence equality"""
        list1 = [1, 2, 3]
        list2 = [1, 2, 3]
        self.assertListEqual(list1, list2)
        
        dict1 = {'a': 1, 'b': 2}
        dict2 = {'a': 1, 'b': 2}
        self.assertDictEqual(dict1, dict2)
    
    def test_float_comparison(self):
        """Test floating point numbers"""
        # Use assertAlmostEqual for floats
        result = 0.1 + 0.2
        self.assertAlmostEqual(result, 0.3, places=7)
    
    def test_regex(self):
        """Test regex pattern matching"""
        text = "Hello World"
        self.assertRegex(text, r'Hello.*')
        self.assertNotRegex(text, r'Goodbye')

if __name__ == '__main__':
    unittest.main()
```

### Custom Assertion Messages

```python
def test_with_message(self):
    """Add custom failure messages"""
    age = 15
    self.assertGreaterEqual(age, 18, "User must be 18 or older")
```

---

## Test Fixtures (setUp and tearDown)

**Define: Fixture** - Setup and cleanup code that runs before/after each test.

### Basic Fixtures

```python
import unittest

class TestWithFixtures(unittest.TestCase):
    """Demonstrate setUp and tearDown"""
    
    def setUp(self):
        """Run before each test method"""
        print("Setting up test...")
        self.data = [1, 2, 3, 4, 5]
        self.temp_file = "test_temp.txt"
    
    def tearDown(self):
        """Run after each test method"""
        print("Cleaning up...")
        import os
        if os.path.exists(self.temp_file):
            os.remove(self.temp_file)
    
    def test_data_manipulation(self):
        """Test using fixture data"""
        self.data.append(6)
        self.assertEqual(len(self.data), 6)
    
    def test_another_operation(self):
        """Another test - data is fresh from setUp"""
        self.assertEqual(len(self.data), 5)  # Still 5!

if __name__ == '__main__':
    unittest.main()
```

### Class-Level Fixtures

```python
class TestWithClassFixtures(unittest.TestCase):
    """Setup/teardown for entire test class"""
    
    @classmethod
    def setUpClass(cls):
        """Run once before all tests in class"""
        print("Setting up class...")
        cls.expensive_resource = "Database connection"
    
    @classmethod
    def tearDownClass(cls):
        """Run once after all tests in class"""
        print("Tearing down class...")
        cls.expensive_resource = None
    
    def test_one(self):
        """Test using class resource"""
        self.assertIsNotNone(self.expensive_resource)
    
    def test_two(self):
        """Another test using same resource"""
        self.assertIsNotNone(self.expensive_resource)
```

### Real-World Fixture Example

```python
import unittest
import tempfile
import os

class TestFileProcessor(unittest.TestCase):
    """Test file processing with proper setup/cleanup"""
    
    def setUp(self):
        """Create temporary test file"""
        self.test_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.test_dir, "test.txt")
        
        with open(self.test_file, 'w') as f:
            f.write("Line 1\nLine 2\nLine 3")
    
    def tearDown(self):
        """Clean up test files"""
        if os.path.exists(self.test_file):
            os.remove(self.test_file)
        if os.path.exists(self.test_dir):
            os.rmdir(self.test_dir)
    
    def test_read_file(self):
        """Test file reading"""
        with open(self.test_file, 'r') as f:
            content = f.read()
        self.assertIn("Line 1", content)
    
    def test_count_lines(self):
        """Test line counting"""
        with open(self.test_file, 'r') as f:
            lines = f.readlines()
        self.assertEqual(len(lines), 3)
```

---

## Testing Exceptions

Test that your code raises exceptions when it should!

### Basic Exception Testing

```python
import unittest

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

class TestExceptions(unittest.TestCase):
    """Test exception handling"""
    
    def test_divide_by_zero_raises_error(self):
        """Test that dividing by zero raises ValueError"""
        with self.assertRaises(ValueError):
            divide(10, 0)
    
    def test_divide_by_zero_message(self):
        """Test exception message"""
        with self.assertRaises(ValueError) as context:
            divide(10, 0)
        
        self.assertEqual(str(context.exception), "Cannot divide by zero")
    
    def test_normal_division_no_error(self):
        """Test that normal division doesn't raise error"""
        result = divide(10, 2)
        self.assertEqual(result, 5)
```

### Testing Multiple Exception Types

```python
def process_age(age):
    if not isinstance(age, int):
        raise TypeError("Age must be an integer")
    if age < 0:
        raise ValueError("Age cannot be negative")
    if age > 150:
        raise ValueError("Invalid age")
    return age

class TestAgeValidation(unittest.TestCase):
    """Test age validation"""
    
    def test_string_raises_type_error(self):
        """Test non-integer raises TypeError"""
        with self.assertRaises(TypeError):
            process_age("25")
    
    def test_negative_raises_value_error(self):
        """Test negative age raises ValueError"""
        with self.assertRaises(ValueError):
            process_age(-5)
    
    def test_too_old_raises_value_error(self):
        """Test age > 150 raises ValueError"""
        with self.assertRaises(ValueError):
            process_age(200)
    
    def test_valid_age_returns_age(self):
        """Test valid age is returned"""
        self.assertEqual(process_age(25), 25)
```

---

## Introduction to pytest

**pytest** is a popular, more powerful alternative to unittest.

### Why pytest?

**Advantages:**
- ‚úÖ Simpler syntax (no classes required)
- ‚úÖ Better output
- ‚úÖ Powerful fixtures
- ‚úÖ Parametrized tests
- ‚úÖ Better assertion messages
- ‚úÖ Plugin ecosystem

### Installation

```bash
pip install pytest
```

### Basic pytest Test

**File: test_calculator_pytest.py**
```python
"""pytest style tests - simpler!"""
from calculator import add, subtract, multiply, divide

def test_add():
    """Test addition - no class needed!"""
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
    assert add(0, 0) == 0

def test_subtract():
    """Test subtraction"""
    assert subtract(5, 3) == 2
    assert subtract(10, 10) == 0

def test_multiply():
    """Test multiplication"""
    assert multiply(2, 3) == 6
    assert multiply(5, 0) == 0

def test_divide():
    """Test division"""
    assert divide(6, 2) == 3
    assert divide(5, 2) == 2.5
```

### Running pytest

```bash
# Run all tests
pytest

# Verbose output
pytest -v

# Run specific file
pytest test_calculator_pytest.py

# Run specific test
pytest test_calculator_pytest.py::test_add

# Show print statements
pytest -s
```

### pytest Assertions

```python
def test_assertions():
    """pytest has smart assertion introspection"""
    
    # Simple comparisons
    assert 1 + 1 == 2
    assert "hello".upper() == "HELLO"
    
    # Membership
    assert 3 in [1, 2, 3, 4]
    assert "apple" in ["apple", "banana"]
    
    # Boolean
    assert True
    assert not False
    
    # None
    result = None
    assert result is None
    
    # Type checking
    assert isinstance(42, int)
    assert isinstance("hello", str)
```

### pytest Exception Testing

```python
import pytest

def test_divide_by_zero():
    """Test exception with pytest"""
    with pytest.raises(ValueError):
        divide(10, 0)

def test_exception_message():
    """Test exception message"""
    with pytest.raises(ValueError, match="Cannot divide by zero"):
        divide(10, 0)
```

### Parametrized Tests

**Test same function with multiple inputs:**

```python
import pytest

@pytest.mark.parametrize("a, b, expected", [
    (2, 3, 5),
    (0, 0, 0),
    (-1, 1, 0),
    (10, -5, 5),
])
def test_add_parametrized(a, b, expected):
    """Test add with multiple inputs"""
    assert add(a, b) == expected

@pytest.mark.parametrize("a, b, expected", [
    (6, 2, 3),
    (10, 5, 2),
    (7, 2, 3.5),
])
def test_divide_parametrized(a, b, expected):
    """Test divide with multiple inputs"""
    assert divide(a, b) == expected
```

---

## pytest Fixtures

**Fixtures provide test data and setup/cleanup.**

### Basic Fixture

```python
import pytest

@pytest.fixture
def sample_data():
    """Provide test data"""
    return [1, 2, 3, 4, 5]

def test_with_fixture(sample_data):
    """Test using fixture"""
    assert len(sample_data) == 5
    assert sum(sample_data) == 15

def test_another_with_fixture(sample_data):
    """Another test with same fixture"""
    sample_data.append(6)
    assert len(sample_data) == 6
```

### Fixture with Setup/Teardown

```python
import pytest
import tempfile
import os

@pytest.fixture
def temp_file():
    """Create and cleanup temp file"""
    # Setup
    file_path = tempfile.mktemp()
    with open(file_path, 'w') as f:
        f.write("Test content")
    
    yield file_path  # Provide to test
    
    # Teardown
    if os.path.exists(file_path):
        os.remove(file_path)

def test_read_temp_file(temp_file):
    """Test using temp file fixture"""
    with open(temp_file, 'r') as f:
        content = f.read()
    assert content == "Test content"
```

### Fixture Scopes

```python
@pytest.fixture(scope="function")  # Run for each test (default)
def per_test_fixture():
    return "Fresh data"

@pytest.fixture(scope="class")  # Run once per test class
def per_class_fixture():
    return "Shared by class"

@pytest.fixture(scope="module")  # Run once per module
def per_module_fixture():
    return "Shared by module"

@pytest.fixture(scope="session")  # Run once per test session
def per_session_fixture():
    return "Shared by all tests"
```

### Real-World Fixture Example

```python
import pytest
import sqlite3

@pytest.fixture
def database():
    """Create test database"""
    # Setup
    conn = sqlite3.connect(':memory:')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            name TEXT,
            email TEXT
        )
    ''')
    cursor.execute("INSERT INTO users VALUES (1, 'Alice', 'alice@example.com')")
    conn.commit()
    
    yield conn  # Provide to tests
    
    # Teardown
    conn.close()

def test_user_exists(database):
    """Test querying user"""
    cursor = database.cursor()
    cursor.execute("SELECT name FROM users WHERE id=1")
    result = cursor.fetchone()
    assert result[0] == "Alice"

def test_insert_user(database):
    """Test inserting user"""
    cursor = database.cursor()
    cursor.execute("INSERT INTO users VALUES (2, 'Bob', 'bob@example.com')")
    database.commit()
    
    cursor.execute("SELECT COUNT(*) FROM users")
    count = cursor.fetchone()[0]
    assert count == 2
```

---

## Mocking and Patching

**Mocking** replaces real objects with fake ones for testing.

### Why Mock?

**Use mocks to:**
- ‚úÖ Avoid external API calls
- ‚úÖ Simulate database operations
- ‚úÖ Test error conditions
- ‚úÖ Speed up tests
- ‚úÖ Isolate code under test

### unittest.mock

```python
from unittest.mock import Mock, patch
import unittest

def get_user_from_api(user_id):
    """Fetch user from API (expensive operation)"""
    import requests
    response = requests.get(f'https://api.example.com/users/{user_id}')
    return response.json()

class TestMocking(unittest.TestCase):
    """Test with mocks"""
    
    @patch('requests.get')
    def test_get_user_from_api(self, mock_get):
        """Mock API call"""
        # Setup mock response
        mock_response = Mock()
        mock_response.json.return_value = {
            'id': 1,
            'name': 'Alice',
            'email': 'alice@example.com'
        }
        mock_get.return_value = mock_response
        
        # Call function
        user = get_user_from_api(1)
        
        # Verify
        self.assertEqual(user['name'], 'Alice')
        mock_get.assert_called_once_with('https://api.example.com/users/1')
```

### Mock Object Methods

```python
class UserService:
    """Service that depends on database"""
    
    def __init__(self, db):
        self.db = db
    
    def get_user_name(self, user_id):
        """Get user name from database"""
        user = self.db.get_user(user_id)
        return user['name'] if user else None

class TestUserService(unittest.TestCase):
    """Test with mocked database"""
    
    def test_get_user_name(self):
        """Test with mock database"""
        # Create mock database
        mock_db = Mock()
        mock_db.get_user.return_value = {'id': 1, 'name': 'Alice'}
        
        # Test service
        service = UserService(mock_db)
        name = service.get_user_name(1)
        
        self.assertEqual(name, 'Alice')
        mock_db.get_user.assert_called_once_with(1)
    
    def test_get_user_not_found(self):
        """Test when user doesn't exist"""
        mock_db = Mock()
        mock_db.get_user.return_value = None
        
        service = UserService(mock_db)
        name = service.get_user_name(999)
        
        self.assertIsNone(name)
```

### pytest Mocking

```python
import pytest
from unittest.mock import Mock, patch

def test_with_mock():
    """Simple mock example"""
    # Create mock object
    mock_obj = Mock()
    mock_obj.method.return_value = "mocked value"
    
    # Use mock
    result = mock_obj.method()
    assert result == "mocked value"
    
    # Verify called
    mock_obj.method.assert_called_once()

@patch('module.external_function')
def test_with_patch(mock_func):
    """Patch external function"""
    mock_func.return_value = 42
    
    # Your code that calls external_function
    result = mock_func()
    assert result == 42
```

### Mock Side Effects

```python
from unittest.mock import Mock

def test_mock_side_effects():
    """Test different return values"""
    mock = Mock()
    
    # Return different values on each call
    mock.side_effect = [1, 2, 3]
    
    assert mock() == 1
    assert mock() == 2
    assert mock() == 3

def test_mock_exception():
    """Mock raising exception"""
    mock = Mock()
    mock.side_effect = ValueError("Error!")
    
    with pytest.raises(ValueError):
        mock()
```

---

## Test Coverage

**Coverage** measures how much of your code is tested.

### Installing Coverage

```bash
pip install coverage
pip install pytest-cov  # For pytest
```

### Running Coverage

**With unittest:**
```bash
# Run tests with coverage
coverage run -m unittest discover

# Generate report
coverage report

# Generate HTML report
coverage html
```

**With pytest:**
```bash
# Run with coverage
pytest --cov=mymodule

# HTML report
pytest --cov=mymodule --cov-report=html
```

### Example Coverage Output

```
Name                Stmts   Miss  Cover
---------------------------------------
calculator.py          15      0   100%
user_service.py        30      5    83%
utils.py              20     10    50%
---------------------------------------
TOTAL                 65     15    77%
```

### Coverage Best Practices

**‚úÖ Do:**
- Aim for 80%+ coverage
- Focus on critical code paths
- Test edge cases
- Test error conditions

**‚ùå Don't:**
- Chase 100% blindly
- Test getters/setters only
- Write tests just for coverage
- Ignore quality for quantity

---

## Real-Life Testing Examples

### Example 1: Testing User Authentication

**File: auth.py**
```python
"""User authentication module"""
import hashlib

class AuthService:
    """Handle user authentication"""
    
    def __init__(self):
        self.users = {}
    
    def register(self, username, password):
        """Register new user"""
        if username in self.users:
            raise ValueError("Username already exists")
        
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters")
        
        # Hash password
        hashed = hashlib.sha256(password.encode()).hexdigest()
        self.users[username] = hashed
        return True
    
    def login(self, username, password):
        """Login user"""
        if username not in self.users:
            return False
        
        hashed = hashlib.sha256(password.encode()).hexdigest()
        return self.users[username] == hashed
    
    def change_password(self, username, old_password, new_password):
        """Change user password"""
        if not self.login(username, old_password):
            raise ValueError("Invalid credentials")
        
        if len(new_password) < 8:
            raise ValueError("Password must be at least 8 characters")
        
        hashed = hashlib.sha256(new_password.encode()).hexdigest()
        self.users[username] = hashed
        return True
```

**File: test_auth.py**
```python
import pytest
from auth import AuthService

class TestAuthService:
    """Test authentication service"""
    
    @pytest.fixture
    def auth(self):
        """Create fresh auth service"""
        return AuthService()
    
    def test_register_success(self, auth):
        """Test successful registration"""
        result = auth.register("alice", "password123")
        assert result is True
        assert "alice" in auth.users
    
    def test_register_duplicate_username(self, auth):
        """Test registering duplicate username"""
        auth.register("alice", "password123")
        
        with pytest.raises(ValueError, match="Username already exists"):
            auth.register("alice", "password456")
    
    def test_register_short_password(self, auth):
        """Test password too short"""
        with pytest.raises(ValueError, match="at least 8 characters"):
            auth.register("alice", "pass")
    
    def test_login_success(self, auth):
        """Test successful login"""
        auth.register("alice", "password123")
        result = auth.login("alice", "password123")
        assert result is True
    
    def test_login_wrong_password(self, auth):
        """Test login with wrong password"""
        auth.register("alice", "password123")
        result = auth.login("alice", "wrongpass")
        assert result is False
    
    def test_login_nonexistent_user(self, auth):
        """Test login with nonexistent user"""
        result = auth.login("bob", "password123")
        assert result is False
    
    def test_change_password_success(self, auth):
        """Test changing password"""
        auth.register("alice", "oldpass123")
        auth.change_password("alice", "oldpass123", "newpass123")
        
        # Old password shouldn't work
        assert auth.login("alice", "oldpass123") is False
        # New password should work
        assert auth.login("alice", "newpass123") is True
    
    def test_change_password_wrong_old(self, auth):
        """Test change password with wrong old password"""
        auth.register("alice", "password123")
        
        with pytest.raises(ValueError, match="Invalid credentials"):
            auth.change_password("alice", "wrongpass", "newpass123")
```

### Example 2: Testing Shopping Cart

**File: cart.py**
```python
"""Shopping cart module"""

class ShoppingCart:
    """Shopping cart for e-commerce"""
    
    def __init__(self):
        self.items = {}
        self.discount = 0
    
    def add_item(self, item_name, price, quantity=1):
        """Add item to cart"""
        if price <= 0:
            raise ValueError("Price must be positive")
        if quantity <= 0:
            raise ValueError("Quantity must be positive")
        
        if item_name in self.items:
            self.items[item_name]['quantity'] += quantity
        else:
            self.items[item_name] = {'price': price, 'quantity': quantity}
    
    def remove_item(self, item_name):
        """Remove item from cart"""
        if item_name not in self.items:
            raise KeyError(f"Item {item_name} not in cart")
        del self.items[item_name]
    
    def update_quantity(self, item_name, quantity):
        """Update item quantity"""
        if item_name not in self.items:
            raise KeyError(f"Item {item_name} not in cart")
        if quantity <= 0:
            raise ValueError("Quantity must be positive")
        self.items[item_name]['quantity'] = quantity
    
    def apply_discount(self, discount_percent):
        """Apply discount to cart"""
        if discount_percent < 0 or discount_percent > 100:
            raise ValueError("Discount must be between 0 and 100")
        self.discount = discount_percent
    
    def get_subtotal(self):
        """Calculate subtotal before discount"""
        return sum(item['price'] * item['quantity'] 
                   for item in self.items.values())
    
    def get_total(self):
        """Calculate total after discount"""
        subtotal = self.get_subtotal()
        discount_amount = subtotal * (self.discount / 100)
        return subtotal - discount_amount
    
    def get_item_count(self):
        """Get total number of items"""
        return sum(item['quantity'] for item in self.items.values())
```

**File: test_cart.py**
```python
import pytest
from cart import ShoppingCart

class TestShoppingCart:
    """Test shopping cart functionality"""
    
    @pytest.fixture
    def cart(self):
        """Create empty cart"""
        return ShoppingCart()
    
    def test_add_item(self, cart):
        """Test adding item to cart"""
        cart.add_item("Apple", 1.50, 3)
        assert "Apple" in cart.items
        assert cart.items["Apple"]["quantity"] == 3
    
    def test_add_same_item_twice(self, cart):
        """Test adding same item increases quantity"""
        cart.add_item("Apple", 1.50, 2)
        cart.add_item("Apple", 1.50, 3)
        assert cart.items["Apple"]["quantity"] == 5
    
    def test_add_item_invalid_price(self, cart):
        """Test negative price raises error"""
        with pytest.raises(ValueError, match="Price must be positive"):
            cart.add_item("Apple", -1.50)
    
    def test_add_item_invalid_quantity(self, cart):
        """Test zero quantity raises error"""
        with pytest.raises(ValueError, match="Quantity must be positive"):
            cart.add_item("Apple", 1.50, 0)
    
    def test_remove_item(self, cart):
        """Test removing item"""
        cart.add_item("Apple", 1.50)
        cart.remove_item("Apple")
        assert "Apple" not in cart.items
    
    def test_remove_nonexistent_item(self, cart):
        """Test removing item not in cart"""
        with pytest.raises(KeyError):
            cart.remove_item("Banana")
    
    def test_update_quantity(self, cart):
        """Test updating quantity"""
        cart.add_item("Apple", 1.50, 2)
        cart.update_quantity("Apple", 5)
        assert cart.items["Apple"]["quantity"] == 5
    
    def test_apply_discount(self, cart):
        """Test applying discount"""
        cart.add_item("Apple", 10.00, 1)
        cart.apply_discount(20)
        assert cart.get_total() == 8.00
    
    def test_apply_invalid_discount(self, cart):
        """Test invalid discount"""
        with pytest.raises(ValueError, match="Discount must be between"):
            cart.apply_discount(150)
    
    def test_get_subtotal(self, cart):
        """Test calculating subtotal"""
        cart.add_item("Apple", 1.50, 2)
        cart.add_item("Banana", 2.00, 3)
        assert cart.get_subtotal() == 9.00  # 3.00 + 6.00
    
    def test_get_total_with_discount(self, cart):
        """Test total with discount"""
        cart.add_item("Apple", 10.00, 2)
        cart.apply_discount(25)
        assert cart.get_total() == 15.00  # 20 - 25%
    
    def test_get_item_count(self, cart):
        """Test counting items"""
        cart.add_item("Apple", 1.50, 2)
        cart.add_item("Banana", 2.00, 3)
        assert cart.get_item_count() == 5
    
    @pytest.mark.parametrize("items, expected_subtotal", [
        ([("Apple", 1.00, 1)], 1.00),
        ([("Apple", 1.00, 5)], 5.00),
        ([("Apple", 1.00, 2), ("Banana", 2.00, 3)], 8.00),
    ])
    def test_subtotal_parametrized(self, cart, items, expected_subtotal):
        """Test subtotal with various items"""
        for name, price, qty in items:
            cart.add_item(name, price, qty)
        assert cart.get_subtotal() == expected_subtotal
```

### Example 3: Testing File Processor

**File: file_processor.py**
```python
"""File processing utilities"""

class FileProcessor:
    """Process text files"""
    
    def read_file(self, filename):
        """Read file content"""
        try:
            with open(filename, 'r') as f:
                return f.read()
        except FileNotFoundError:
            return None
    
    def count_words(self, text):
        """Count words in text"""
        if not text:
            return 0
        return len(text.split())
    
    def count_lines(self, filename):
        """Count lines in file"""
        content = self.read_file(filename)
        if content is None:
            return 0
        return len(content.splitlines())
    
    def find_word(self, text, word):
        """Find word occurrences"""
        if not text or not word:
            return 0
        return text.lower().count(word.lower())
```

**File: test_file_processor.py**
```python
import pytest
import tempfile
import os
from file_processor import FileProcessor

class TestFileProcessor:
    """Test file processing"""
    
    @pytest.fixture
    def processor(self):
        """Create processor"""
        return FileProcessor()
    
    @pytest.fixture
    def temp_file(self):
        """Create temp file with content"""
        fd, path = tempfile.mkstemp(suffix='.txt')
        with os.fdopen(fd, 'w') as f:
            f.write("Hello World\nPython Testing\nUnit Tests")
        
        yield path
        
        os.remove(path)
    
    def test_read_file_success(self, processor, temp_file):
        """Test reading existing file"""
        content = processor.read_file(temp_file)
        assert content is not None
        assert "Hello World" in content
    
    def test_read_nonexistent_file(self, processor):
        """Test reading nonexistent file"""
        content = processor.read_file("nonexistent.txt")
        assert content is None
    
    def test_count_words(self, processor):
        """Test word counting"""
        text = "Hello World Python Testing"
        assert processor.count_words(text) == 4
    
    def test_count_words_empty(self, processor):
        """Test counting words in empty text"""
        assert processor.count_words("") == 0
        assert processor.count_words(None) == 0
    
    def test_count_lines(self, processor, temp_file):
        """Test line counting"""
        count = processor.count_lines(temp_file)
        assert count == 3
    
    def test_find_word(self, processor):
        """Test finding word"""
        text = "Python is great. Python rocks. I love Python!"
        count = processor.find_word(text, "python")
        assert count == 3
    
    def test_find_word_case_insensitive(self, processor):
        """Test word finding is case insensitive"""
        text = "Python python PYTHON"
        count = processor.find_word(text, "python")
        assert count == 3
```

---

## Common Mistakes

### Mistake 1: Tests Depend on Each Other

**‚ùå Wrong:**
```python
class TestBad(unittest.TestCase):
    def test_one(self):
        self.data = [1, 2, 3]
    
    def test_two(self):
        # Relies on test_one running first!
        self.data.append(4)
        self.assertEqual(len(self.data), 4)
```

**‚úÖ Correct:**
```python
class TestGood(unittest.TestCase):
    def setUp(self):
        self.data = [1, 2, 3]
    
    def test_one(self):
        self.assertEqual(len(self.data), 3)
    
    def test_two(self):
        self.data.append(4)
        self.assertEqual(len(self.data), 4)
```

### Mistake 2: Testing Implementation Instead of Behavior

**‚ùå Wrong:**
```python
def test_sort_uses_quicksort(self):
    """Don't test HOW it works"""
    # Testing internal implementation
    pass
```

**‚úÖ Correct:**
```python
def test_sort_returns_sorted_list(self):
    """Test WHAT it does"""
    result = sort_function([3, 1, 2])
    assert result == [1, 2, 3]
```

### Mistake 3: Not Cleaning Up Resources

**‚ùå Wrong:**
```python
def test_file_operation(self):
    f = open('test.txt', 'w')
    f.write('data')
    # File not closed! Resource leak
```

**‚úÖ Correct:**
```python
def test_file_operation(self):
    with open('test.txt', 'w') as f:
        f.write('data')
    # File automatically closed
```

---

## Best Practices

### ‚úÖ Do This:

1. **Test One Thing Per Test**
   ```python
   def test_add_positive_numbers():
       assert add(2, 3) == 5
   
   def test_add_negative_numbers():
       assert add(-2, -3) == -5
   ```

2. **Use Descriptive Test Names**
   ```python
   # Good
   def test_login_with_invalid_password_returns_false():
       pass
   
   # Bad
   def test_login():
       pass
   ```

3. **Arrange-Act-Assert Pattern**
   ```python
   def test_user_registration():
       # Arrange
       auth = AuthService()
       
       # Act
       result = auth.register("alice", "pass123")
       
       # Assert
       assert result is True
   ```

4. **Use Fixtures for Setup**
   ```python
   @pytest.fixture
   def database():
       db = create_database()
       yield db
       db.close()
   ```

5. **Test Edge Cases**
   ```python
   def test_divide():
       assert divide(10, 2) == 5      # Normal
       assert divide(0, 5) == 0        # Zero numerator
       with pytest.raises(ValueError):
           divide(10, 0)               # Zero denominator
   ```

### ‚ùå Avoid This:

1. **Don't Write Dependent Tests**
2. **Don't Test External Services (use mocks)**
3. **Don't Ignore Failing Tests**
4. **Don't Skip Edge Cases**
5. **Don't Write Tests Without Assertions**

---

## Summary

Congratulations! You've mastered unit testing in Python! üéâ

**üéØ Key Takeaways:**

**üìå unittest Module**
- Built-in testing framework
- TestCase classes
- setUp/tearDown fixtures
- Rich assertion methods

**üìå pytest Framework**
- Simpler syntax
- Powerful fixtures
- Parametrized tests
- Better output

**üìå Test Structure**
- One test per behavior
- Arrange-Act-Assert
- Descriptive names
- Independent tests

**üìå Mocking**
- Isolate code under test
- Replace external dependencies
- unittest.mock module
- Verify method calls

**üìå Coverage**
- Measure tested code
- Aim for 80%+
- Focus on critical paths
- Quality over quantity

**üí° Remember:**
- Write tests early
- Test behavior, not implementation
- Keep tests simple and fast
- Mock external dependencies
- Run tests frequently

---

## Practice Exercises

### Exercise 1: Test String Utils
Create `string_utils.py` with functions (capitalize, reverse, is_palindrome) and write comprehensive tests.

---

### Exercise 2: Test Math Library
Test functions for: factorial, fibonacci, is_prime, gcd. Include edge cases.

---

### Exercise 3: Test User Class
Create User class with validation and write tests for all methods.

---

### Exercise 4: Test API Client
Create simple API client and write tests using mocks.

---

### Exercise 5: Test Database Layer
Create database class and test CRUD operations with fixtures.

---

### Exercise 6: Parametrized Tests
Write parametrized tests for temperature conversion functions.

---

### Exercise 7: Test File Handler
Test file reading/writing with proper cleanup using fixtures.

---

### Exercise 8: Test with Coverage
Write tests for existing project and achieve 90%+ coverage.

---

### Exercise 9: Test Error Conditions
Create validator functions and test all error conditions.

---

### Exercise 10: Complete Test Suite
Build complete project with full test coverage using pytest.

---

**You're now ready to write professional tests!** üêç‚ú®

Test-driven development awaits! üöÄ

Happy testing! üíª
